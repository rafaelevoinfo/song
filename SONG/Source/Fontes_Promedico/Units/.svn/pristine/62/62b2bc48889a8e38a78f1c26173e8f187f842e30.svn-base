unit pChatTela;

interface

uses
  System.RegularExpressions, Winapi.ShellAPI, pChatComponentes, pChatTipos, pUtils,
  System.Generics.Collections, pDMChat, System.IniFiles, RVTable, CRVFData, RVItem,
  pZero, pMethod2009, System.Math, System.Win.ComObj, pZoomImg, System.Zip,
  dxGalleryControl, Vcl.FileCtrl, System.AnsiStrings,

  Vcl.Imaging.GIFImg, Vcl.Imaging.JPEG, Vcl.Imaging.PngImage,

  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, cxGraphics, cxControls, cxLookAndFeels,
  cxLookAndFeelPainters, cxContainer, cxEdit, dxBarBuiltInMenu, cxPC, cxStyles,
  cxCustomData, cxFilter, cxData, cxDataStorage, cxNavigator, Data.DB, cxDBData,
  RVStyle, Vcl.ImgList, Datasnap.DBClient, pmClientDataSet, System.Actions,
  Vcl.ActnList, cxGridLevel, cxGridCustomTableView, cxGridTableView,
  cxGridDBTableView, cxClasses, cxGridCustomView, cxGrid, cxMaskEdit,
  cxDropDownEdit, cxImageComboBox, cxDBEdit, cxCheckBox, dxDockPanel,
  dxDockControl, RVScroll, RichView, RVEdit, Vcl.Buttons, cxSplitter,
  Vcl.StdCtrls, cxTextEdit, dxGDIPlusClasses, cxScrollBox, Vcl.ExtCtrls, cxLabel,
  cxDBEditRepository, cxLookupEdit, cxDBLookupEdit, cxDBLookupComboBox,
  cxEditRepositoryItems, dxSkinsCore, pmPromedicoSkin, dxSkinscxPCPainter,
  cxGroupBox, cxSpinEdit, SclRView, RichViewActions, cxImage, Vcl.ComCtrls,
  dxCore, cxDateUtils, cxCalendar, cxRadioGroup, pFrameCapturaImg, Vcl.Samples.Gauges;

type
  TfrmChatTela = class(TfrmZero)
    pnlConversasListaUsuarios: TPanel;
    pgcPrincipal: TcxPageControl;
    tabInicial: TcxTabSheet;
    pnlUsuario: TPanel;
    tabConversa: TcxTabSheet;
    cxSplitter2: TcxSplitter;
    slbConversasListaUsuarios: TcxScrollBox;
    pnlConversa: TPanel;
    pnlTopicoConversa: TPanel;
    pnlPesquisa: TPanel;
    lblPesquisa: TLabel;
    EditPesquisaUsuario: TcxTextEdit;
    cxSplitter1: TcxSplitter;
    dockSitePesqUsuarios: TdxDockSite;
    dockPanelPesqUsuarios: TdxDockPanel;
    dxLayoutDockSite1: TdxLayoutDockSite;
    pnlPesqUsuario: TPanel;
    cxGrid1DBTableView1: TcxGridDBTableView;
    cxGrid1Level1: TcxGridLevel;
    cxGrid1: TcxGrid;
    Label2: TLabel;
    EditNomeUsuario: TcxTextEdit;
    ckbTodosHospitais: TcxCheckBox;
    ckbTodosGrupos: TcxCheckBox;
    pnlConversaEdit: TPanel;
    cxSplitter3: TcxSplitter;
    rveMensagens: TRichViewEdit;
    imgFotoUsuarioLogado: TImage;
    lblStatusUsuarioLogado: TLabel;
    pnlConversaEditBotoes: TPanel;
    rveMensagensEdit: TRichViewEdit;
    cxGrid1DBTableView1CODIGO: TcxGridDBColumn;
    cxGrid1DBTableView1CODIGO_HOSPITAL: TcxGridDBColumn;
    cxGrid1DBTableView1NOME: TcxGridDBColumn;
    cxGrid1DBTableView1FUNCAO: TcxGridDBColumn;
    cxGrid1DBTableView1ATIVO_INATIVO: TcxGridDBColumn;
    cxGrid1DBTableView1USUARIO_GRUPO: TcxGridDBColumn;
    cxGrid1DBTableView1STATUS: TcxGridDBColumn;
    spStatusUsuarioLogado: TShape;
    pgcDadosConversa: TcxPageControl;
    tabPerfil: TcxTabSheet;
    imgFotoUsuario: TImage;
    lblNomeUsuario: TLabel;
    lblFuncao: TLabel;
    lblEmail: TLabel;
    lblStatus: TLabel;
    lblHospital: TLabel;
    spStatus: TShape;
    tabGrupo: TcxTabSheet;
    slbListaUsuariosGrupo: TcxScrollBox;
    Panel3: TPanel;
    Label1: TLabel;
    lblNomeGrupo: TLabel;
    tabArquivos: TcxTabSheet;
    slbListaArquivos: TcxScrollBox;
    pnlConversaAnexos: TPanel;
    slbAnexos: TcxScrollBox;
    Panel1: TPanel;
    lblAnexosQtde: TLabel;
    lblAnexos: TLabel;
    cbGrupo: TcxLookupComboBox;
    cbHospital: TcxLookupComboBox;
    lblHospitalGrupo: TLabel;
    TabConfiguracao: TcxTabSheet;
    cxGroupBox1: TcxGroupBox;
    Label3: TLabel;
    Label4: TLabel;
    cbConfigFonteNome: TcxImageComboBox;
    EditConfigFonteTamanho: TcxSpinEdit;
    Panel2: TPanel;
    Button1: TButton;
    Button2: TButton;
    lblConfigFonteVisualizacao: TcxLabel;
    TabPesquisa: TcxTabSheet;
    Panel4: TPanel;
    rvePesquisa: TRichViewEdit;
    Label5: TLabel;
    EditPesquisaTabPesq: TEdit;
    Button3: TButton;
    imgFotoTabPesquisa: TImage;
    lblNomeUsuarioTabPesquisa: TLabel;
    lblFuncaoTabPesquisa: TLabel;
    lblHospitalTabPesquisa: TLabel;
    Label9: TLabel;
    EditPesquisaConversa: TEdit;
    Button4: TButton;
    dockSiteSmileys: TdxDockSite;
    dockPanelSmileys: TdxDockPanel;
    dxLayoutDockSite2: TdxLayoutDockSite;
    slbSmileys: TcxScrollBox;
    lblNomeUsuarioLogado: TLabel;
    bttEnviar: TButton;
    bttSmiley: TButton;
    bttAnexo: TButton;
    cbxPesquisarPeriodoConversa: TcxCheckBox;
    EditDataInicialConversa: TcxDateEdit;
    EditDataFinalConversa: TcxDateEdit;
    cbxPesquisarPeriodoTabPesq: TcxCheckBox;
    EditDataInicialTabPesq: TcxDateEdit;
    EditDataFinalTabPesq: TcxDateEdit;
    bttConfiguracoes: TButton;
    pnlAlertaConversa: TPanel;
    Label6: TLabel;
    pnlAlertaPesquisa: TPanel;
    Label7: TLabel;
    cxGroupBox2: TcxGroupBox;
    Button5: TButton;
    Button6: TButton;
    Label8: TLabel;
    Label10: TLabel;
    EditConfigEMail: TcxTextEdit;
    EditConfigTelefone: TcxTextEdit;
    cxGroupBox3: TcxGroupBox;
    ckbConfigNovaMensagemApenasAlerta: TcxCheckBox;
    imgConfigFotoUsuario: TImage;
    Label11: TLabel;
    tabCapturaFoto: TcxTabSheet;
    frmFrameCapturaImg1: TfrmFrameCapturaImg;
    procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure FormCreate(Sender: TObject);
    procedure EditPesquisaPropertiesChange(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormResize(Sender: TObject);
    procedure dockSitePesqUsuariosHideControl(Sender: TdxDockSite;
      AControl: TdxCustomDockControl);
    procedure FormMouseWheel(Sender: TObject; Shift: TShiftState;
      WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
    procedure pgcPrincipalPageChanging(Sender: TObject; NewPage: TcxTabSheet;
      var AllowChange: Boolean);
    procedure EditNomeUsuarioPropertiesChange(Sender: TObject);
    procedure cbTodosGruposPropertiesEditValueChanged(Sender: TObject);
    procedure ckbTodosHospitaisPropertiesEditValueChanged(Sender: TObject);
    procedure cbGrupoPropertiesEditValueChanged(Sender: TObject);
    procedure cbHospitalPropertiesEditValueChanged(Sender: TObject);
    procedure cxGrid1DBTableView1CellDblClick(Sender: TcxCustomGridTableView;
      ACellViewInfo: TcxGridTableDataCellViewInfo; AButton: TMouseButton;
      AShift: TShiftState; var AHandled: Boolean);
    procedure dockSitePesqUsuariosShowControl(Sender: TdxDockSite;
      AControl: TdxCustomDockControl);
    procedure FormDestroy(Sender: TObject);
    procedure cbConfigFonteNomePropertiesChange(Sender: TObject);
    procedure EditConfigFonteTamanhoPropertiesChange(Sender: TObject);
    procedure rveMensagensEditKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure cbxPesquisarPeriodoConversaClick(Sender: TObject);
    procedure cbxPesquisarPeriodoTabPesqClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure rveMensagensKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure rveMensagensEditKeyPress(Sender: TObject; var Key: Char);
    procedure frmFrameCapturaImg1btnConfigurarClick(Sender: TObject);
    procedure frmFrameCapturaImg1Button2Click(Sender: TObject);
  private
    DMChat: TDMChat;
    FAoConfirmarLeituraMensagens: TChatConfirmarLeituraMensagens;
    FAoEnviarMensagem: TChatEnviarMensagem;
    FAoFazerDownloadArquivo: TChatDownloadArquivo;
    FAoMudarStatusConversa: TChatMudarStatusConversa;
    FAoPesquisar: TChatPesquisarMensagens;
    FAoPesquisarConfiguracoes: TChatPesquisarConfiguracoes;
    FAoPesquisarLeitores: TChatPesquisarLeitoresMensagens;
    FAoSalvarConfiguracoes: TChatSalvarConfiguracoes;
    FChatPanelSelecionado: TChatPanelConversaAba;
    FCodigoUsuarioSistema: Integer;
    FConfiguracao: TChatConfiguracoes;
    FOriginalWindowProc: TWndMethod;
    FSmileys: TDictionary<string, string>;
    FSmileysExpressaoRegular: string;
    FUsuarioLogado: TDictionary<Integer, TChatUsuarioLogado>;
    function fpvClonarClientDataSet(const ipCdsOrigem: TpmClientDataSet): TpmClientDataSet;
    function fpvCodigoHospital(const ipIdentificador: string): Integer;
    function fpvCodigosUsuarioHospital(const ipIdentificador: string): Variant;
    function fpvCodigoUsuario(const ipIdentificador: string): Integer;
    function fpvDownloadArquivo(const ipCodigoHospital: Integer; const ipEnerecoArquivo: string): TBytesStream;
    function fpvFindGraphicClass(const ipBuffer; const ipBufferSize: Int64; out ioGraphicClass: TGraphicClass): Boolean; overload;
    function fpvFindGraphicClass(const ipStream: TStream; out ioGraphicClass: TGraphicClass): Boolean; overload;
    function fpvIconeArquivo(const ipExtensaoArquivo: string): TPicture;
    function fpvImagem(const ipBytesStream: TBytesStream; const ipFormatoSecundario: TWICImageFormat): TGraphic;
    function fpvImagemTamanhoMaximo(const ipBytesStream: TBytesStream; const ipHeight, ipWidth: Integer): TGraphic; overload;
    function fpvImagemTamanhoMaximo(const ipGraphic: TGraphic; const ipHeight, ipWidth: Integer): TGraphic; overload;
    function fpvMontaIdentificador(const ipCodigoUsuario, ipCodigoHospital: Integer): string;
    function fpvMouseSobreComponente(ipControl: TControl): Boolean; overload;
    function fpvMouseSobreComponente(ipControl: TControl; ipMousePos: TPoint): Boolean; overload;
    function fpvPesquisarConversa(const ipTipoPesquisa: TChatTipoPesquisa; const ipTexto: string; const ipDataInicial, ipDataFinal: TDate; const ipUsuarioLogado, ipUsuarioConversa: TChatIdentificacaoUsuario;
      const ipUsuarioSistema, ipCriarClientDataSet: Boolean; var ioCdsMensagem, ioCdsMensagemAnexo: TpmClientDataSet): Boolean;
    function fpvPesquisarLeitoresMensagens(const ipCodigoHospital: Integer; const ipCodigosMensagens: string; var ioLeitores: OleVariant): Boolean;
    function fpvTamanhoFormatado(const ipTamanho: Int64): string;
    function fpvUsuarioLogado(const ipCodigoHospital: Integer; var ioUsuarioLogado: Integer): Boolean; overload;
    function fpvUsuarioLogado(const ipCodigoHospital: Integer; var ioUsuarioLogado: TChatUsuarioLogado): Boolean; overload;
    function fpvUsuarioLogado(const ipCodigoHospital: Integer; var ioUsuarioLogado: TChatIdentificacaoUsuario): Boolean; overload;
    function fpvUsuarioPertenceGrupo(const ipCodigoUsuario, ipCodigoGrupo, ipCodigoHospital: Integer): Boolean;
    function fpvVisualizarSomenteMensagensEnviadas(const ipIdentificadorConversa: string): Boolean; overload;
    function fpvVisualizarSomenteMensagensEnviadas(const ipUsuarioConversa: TChatIdentificacaoUsuario): Boolean; overload;
    function fpvVisualizarSomenteMensagensEnviadas(const ipCodigoUsuarioConversa, ipCodigoHospital: Integer): Boolean; overload;
    procedure ppvAbrirTelaPesqUsuario;
    procedure ppvAcAnexar(Sender: TObject);
    procedure ppvAcConfigCapturarImagem(Sender: TObject);
    procedure ppvAcConfigGravar(Sender: TObject);
    procedure ppvAcConfigPegarArquivoImagem(Sender: TObject);
    procedure ppvAcConfigRestaurar(Sender: TObject);
    procedure ppvAcConfiguracao(Sender: TObject);
    procedure ppvAcEnviar(Sender: TObject);
    procedure ppvAcPesquisarConversa(Sender: TObject);
    procedure ppvAcSmiles(Sender: TObject);
    procedure ppvAdicionarConversa(const ipIdentificador: string; const ipSelecionarConversa, ipNotificar: Boolean);
    procedure ppvAdicionarPanelAnexo(const ipDadosArquivo: TChatAnexoPropriedades);
    procedure ppvAdicionarSmileys(Sender: TObject);
    procedure ppvAjustarImagem(const ipCdsUsuarios: TpmClientDataSet; const ipFoto, ipFotoThumbnail: Boolean);
    procedure ppvAnexarArquivos(ipArquivos: TStrings);
    procedure ppvAnexosLimiteAtingido(const ipArquivosRecusados: TStrings);
    procedure ppvAtualizarDadosUsuarioLogado;
    procedure ppvAtualizarDadosUsuarioTela(const ipIdentificador: string = ''; ipChatPanelConversaAba: TChatPanelConversaAba = nil; const ipSomenteStatus: Boolean = False);
    procedure ppvCarregarAnexos(const ipChatPanelConversaAba: TChatPanelConversaAba);
    procedure ppvCarregarArquivos(const ipIdentificador: string);
    procedure ppvCarregarImagemArquivo(ipChatPanelArquivo: TChatPanelArquivo; ipExtArquivo: string; ipImagem: TPicture = nil);
    procedure ppvCarregarMensgensBancoDados(const ipIdentificador: string);
    procedure ppvClickLink(Sender: TObject; id: Integer);
    procedure ppvConfigFonteAtualizarVisualizacao;
    procedure ppvDeletarAnexo(Sender: TObject);
    procedure ppvDescompactarArquivo(const ipArquivo: TBytesStream; const ipDestinoArquivo: string); overload;
    procedure ppvDescompactarArquivo(const ipArquivo: TBytesStream; var ioArquivoDescompactado: TBytesStream); overload;
    procedure ppvFecharConversa(Sender: TObject);
    procedure ppvFecharTelaVisualizacoesMensagem(Sender: TObject); overload;
    procedure ppvFecharTelaVisualizacoesMensagem(Sender: TObject; var Key: Word; Shift: TShiftState); overload;
    procedure ppvIncluirStatusMensagem(ipCelula: TRVTableCellData; const ipParagrafo: Integer; const ipCodigoLeitura: string);
    procedure ppvInformarMensagensLidas(const ipIdentificador: string);
    procedure ppvMudarStatusConversa(const ipIdentificador: string; const ipConversaAtiva: Boolean);
    procedure ppvPegarArquivoArrastato(var Msg: TMessage); message WM_DROPFILES;
    procedure ppvPesquisaUsuario;
    procedure ppvPreencherRichViewEdit(const ipCdsMensagem, ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit); overload;
    procedure ppvPreencherRichViewEdit(const ipCdsMensagem, ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit; ipSomenteRegistroSelecionado: Boolean); overload;
    procedure ppvPreencherRichViewEdit(const ipCdsMensagem, ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit; const ipDestacarTextoPesquisa: string; const ipExibirLinkVisualizacaoPesquisa, ipSomenteRegistroSelecionado: Boolean); overload;
    procedure ppvSalvarArquivo(const ipCodigoHospital: Integer; const ipLocalArquivo: string);
    procedure ppvSelecionarArquivo(Sender: TObject);
    procedure ppvSelecionarConversa(Sender: TObject);
    procedure ppvSelecionarUsuarioGrupo(Sender: TObject);
    procedure ppvTelaVisualizacoesMensagemMouseWeelDown(Sender: TObject; Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);
    procedure ppvTelaVisualizacoesMensagemMouseWeelUp(Sender: TObject; Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);
    procedure ppvVisualizarArquivo(const ipCodigoHospital: Integer; const ipLocalArquivo: string);
    procedure SetAoConfirmarLeituraMensagens(const Value: TChatConfirmarLeituraMensagens);
    procedure SetAoEnviarMensagem(const Value: TChatEnviarMensagem);
    procedure SetAoFazerDownloadArquivo(const Value: TChatDownloadArquivo);
    procedure SetAoMudarStatusConversa(const Value: TChatMudarStatusConversa);
    procedure SetAoPesquisar(const Value: TChatPesquisarMensagens);
    procedure SetAoPesquisarConfiguracoes(const Value: TChatPesquisarConfiguracoes);
    procedure SetAoPesquisarLeitores(const Value: TChatPesquisarLeitoresMensagens);
    procedure SetAoSalvarConfiguracoes(const Value: TChatSalvarConfiguracoes);
    { Private declarations }
  public
    function fpuAtualizarConfiguracoes(const ipConfiguracoes: TChatConfiguracoes): string;
    function fpuAtualizarStatus(const ipListaStatus: TList<TChatStatus>): string;
    function fpuAtualizarUsuarios(const ipListaUsuarios: TList<TChatUsuario>): string;
    function fpuAtualizarHospitais(const ipListaHospitais: TList<TChatHospital>): string;
    function fpuNovaMensagem(const ipMensagens: TList<TChatMensagem>): string; overload;
    function fpuNovaMensagem(const ipCodigoMensagens, ipCodigoRemetente, ipCodigoHospital, ipCodigoDestinatario: Integer): string; overload;
    function fpuRetornaImagem(const ipBytesStream: TBytesStream): TPicture;
    procedure ppuAbrirConversas(const ipUsuarios: TList<TChatConversa>);
    procedure ppuMensagensLidas(const ipCodigoUsuarioConversa, ipCodigoHospital: Integer; const ipCodigosMensagens: string);
    procedure ppuUsuarioLogado(const ipIdUsuario: TChatUsuarioLogado);
    property AoConfirmarLeituraMensagens: TChatConfirmarLeituraMensagens read FAoConfirmarLeituraMensagens write SetAoConfirmarLeituraMensagens;
    property AoEnviarMensagem: TChatEnviarMensagem read FAoEnviarMensagem write SetAoEnviarMensagem;
    property AoFazerDownloadArquivo: TChatDownloadArquivo read FAoFazerDownloadArquivo write SetAoFazerDownloadArquivo;
    property AoMudarStatusConversa: TChatMudarStatusConversa read FAoMudarStatusConversa write SetAoMudarStatusConversa;
    property AoPesquisar: TChatPesquisarMensagens read FAoPesquisar write SetAoPesquisar;
    property AoPesquisarConfiguracoes: TChatPesquisarConfiguracoes read FAoPesquisarConfiguracoes write SetAoPesquisarConfiguracoes;
    property AoPesquisarLeitores: TChatPesquisarLeitoresMensagens read FAoPesquisarLeitores write SetAoPesquisarLeitores;
    property AoSalvarConfiguracoes: TChatSalvarConfiguracoes read FAoSalvarConfiguracoes write SetAoSalvarConfiguracoes;
    { Public declarations }
  end;

const
  coMinGraphicSize = 44;

var
  frmChatTela: TfrmChatTela;

implementation

{$R *.dfm}


procedure TfrmChatTela.cbConfigFonteNomePropertiesChange(Sender: TObject);
begin
  ppvConfigFonteAtualizarVisualizacao;
end;

procedure TfrmChatTela.cbGrupoPropertiesEditValueChanged(Sender: TObject);
begin
  ppvPesquisaUsuario;
end;

procedure TfrmChatTela.cbHospitalPropertiesEditValueChanged(Sender: TObject);
begin
  ppvPesquisaUsuario;
end;

procedure TfrmChatTela.cbTodosGruposPropertiesEditValueChanged(Sender: TObject);
begin
  cbGrupo.Enabled := not ckbTodosGrupos.Checked;
  ppvPesquisaUsuario;
end;

procedure TfrmChatTela.cbxPesquisarPeriodoConversaClick(Sender: TObject);
begin
  inherited;
  EditDataInicialConversa.Enabled := cbxPesquisarPeriodoConversa.Checked;
  EditDataFinalConversa.Enabled := cbxPesquisarPeriodoConversa.Checked;
end;

procedure TfrmChatTela.cbxPesquisarPeriodoTabPesqClick(Sender: TObject);
begin
  inherited;
  EditDataInicialTabPesq.Enabled := cbxPesquisarPeriodoTabPesq.Checked;
  EditDataFinalTabPesq.Enabled := cbxPesquisarPeriodoTabPesq.Checked;
end;

procedure TfrmChatTela.ckbTodosHospitaisPropertiesEditValueChanged(
  Sender: TObject);
begin
  cbHospital.Enabled := not ckbTodosHospitais.Checked;
  ppvPesquisaUsuario;
end;

procedure TfrmChatTela.cxGrid1DBTableView1CellDblClick(
  Sender: TcxCustomGridTableView; ACellViewInfo: TcxGridTableDataCellViewInfo;
  AButton: TMouseButton; AShift: TShiftState; var AHandled: Boolean);
begin
  if DMChat.cdsUsuarios.RecordCount > 0 then
    begin
      // Não inverter a ordem destas duas linhas, pois ao fechar o dockPanelPesqUsuario a pesquisa é perdida (OnHideControl)
      ppvAdicionarConversa(fpvMontaIdentificador(DMChat.cdsUsuariosCODIGO.AsInteger, DMChat.cdsUsuariosCODIGO_HOSPITAL.AsInteger), True, False);
      dockPanelPesqUsuarios.Hide;
    end;
end;

procedure TfrmChatTela.dockSitePesqUsuariosHideControl(Sender: TdxDockSite;
  AControl: TdxCustomDockControl);
begin
  dockSitePesqUsuarios.Visible := False;
  EditNomeUsuario.Clear;
end;

procedure TfrmChatTela.dockSitePesqUsuariosShowControl(Sender: TdxDockSite;
  AControl: TdxCustomDockControl);
begin
  // Limpando os dados de pesquisa de hospital
  ckbTodosHospitais.Checked := True;
  cbHospital.Enabled := False;
  DMChat.cdsHospitais.Filtered := False;
  DMChat.cdsHospitais.Filter := '';
  DMChat.cdsHospitais.First;

  if DMChat.cdsHospitais.RecordCount > 0 then
    cbHospital.EditValue := DMChat.cdsHospitaisCODIGO.AsInteger;

  // Limpando os dados de pesquisa de grupo
  ckbTodosGrupos.Checked := True;
  cbGrupo.Enabled := False;
  DMChat.cdsGrupos.Filtered := False;
  DMChat.cdsGrupos.Filter := '';
  DMChat.cdsGrupos.First;

  if DMChat.cdsGrupos.RecordCount > 0 then
    cbGrupo.EditValue := DMChat.cdsGruposCODIGO.AsInteger;
end;

procedure TfrmChatTela.EditConfigFonteTamanhoPropertiesChange(Sender: TObject);
begin
  ppvConfigFonteAtualizarVisualizacao;
end;

procedure TfrmChatTela.EditNomeUsuarioPropertiesChange(Sender: TObject);
begin
  ppvPesquisaUsuario;
end;

procedure TfrmChatTela.EditPesquisaPropertiesChange(Sender: TObject);
begin
  ppvAbrirTelaPesqUsuario;
end;

procedure TfrmChatTela.FormCreate(Sender: TObject);
var
  vaArrayChaves: TArray<string>;

  procedure plcAdicionarSmiley(const ipChave, ipNome: string);
  begin
    SetLength(vaArrayChaves, Length(vaArrayChaves) + 1);
    vaArrayChaves[High(vaArrayChaves)] := ipChave;
    FSmileys.Add(ipChave, ipNome);
  end;

var
  vaLeft, vaTop, vaColuna, vaQtdeColuna: Integer;
  vaChave: string;
  vaImagem: TcxImageCollectionItem;
  vaImage: TImage;
begin
  inherited;

  // Inicializando as variáveis globais
  DMChat := TDMChat.Create(Self);
  DMChat.Name := '';
  FAoConfirmarLeituraMensagens := nil;
  FAoEnviarMensagem := nil;
  FAoPesquisar := nil;
  FAoPesquisarConfiguracoes := nil;
  FAoPesquisarLeitores := nil;
  FAoSalvarConfiguracoes := nil;
  FChatPanelSelecionado := nil;
  FCodigoUsuarioSistema := -2147483648;
  FUsuarioLogado := TDictionary<Integer, TChatUsuarioLogado>.Create;

  // Configurações iniciais da tela
  cbxPesquisarPeriodoConversa.Checked := False;
  cbxPesquisarPeriodoConversaClick(cbxPesquisarPeriodoConversa);
  cbxPesquisarPeriodoTabPesq.Checked := False;
  cbxPesquisarPeriodoTabPesqClick(cbxPesquisarPeriodoTabPesq);

  pgcPrincipal.ActivePage := tabInicial;
  pgcPrincipal.HideTabs := True;

  dockSitePesqUsuarios.Visible := False;
  dockPanelPesqUsuarios.AutoHide := True;
  dockPanelPesqUsuarios.CaptionButtons := [cbMaximize];

  dockSiteSmileys.Visible := False;
  dockSiteSmileys.AutoSize := False;
  dockPanelSmileys.AutoHide := True;
  dockPanelSmileys.CaptionButtons := [cbMaximize];

  pnlConversaAnexos.Visible := False;

  // Atualizando a configuração da fonte
  FConfiguracao := TChatConfiguracoes.Create;
  fpuAtualizarConfiguracoes(FConfiguracao);

  // Adicionando eventos aos RichViewEdits
  rveMensagens.OnJump := ppvClickLink;
  rvePesquisa.OnJump := ppvClickLink;

  // Configurando os actions
  DMChat.Ac_Anexar.OnExecute := ppvAcAnexar;
  DMChat.Ac_ConfigCapturarImagem.OnExecute := ppvAcConfigCapturarImagem;
  DMChat.Ac_ConfigGravar.OnExecute := ppvAcConfigGravar;
  DMChat.Ac_ConfigPegarArquivoImagem.OnExecute := ppvAcConfigPegarArquivoImagem;
  DMChat.Ac_ConfigRestaurar.OnExecute := ppvAcConfigRestaurar;
  DMChat.Ac_Configuracao.OnExecute := ppvAcConfiguracao;
  DMChat.Ac_Enviar.OnExecute := ppvAcEnviar;
  DMChat.Ac_PesquisarConversa.OnExecute := ppvAcPesquisarConversa;
  DMChat.Ac_Smiles.OnExecute := ppvAcSmiles;

  // Criando as tabelas
  DMChat.cdsUsuarios.CreateDataSet;
  DMChat.cdsUsuarios.LogChanges := False;

  DMChat.cdsGrupos.CreateDataSet;
  DMChat.cdsGrupos.LogChanges := False;

  DMChat.cdsGrupos_Usuarios.CreateDataSet;
  DMChat.cdsGrupos_Usuarios.LogChanges := False;

  DMChat.cdsHospitais.CreateDataSet;
  DMChat.cdsHospitais.LogChanges := False;

  DMChat.cdsMensagem_Anexo.CreateDataSet;
  DMChat.cdsMensagem_Anexo.LogChanges := False;

  DMChat.cdsMensagem.CreateDataSet;
  DMChat.cdsMensagem.LogChanges := False;

  // *********************
  // Montando os smileys *
  // *********************

  // "Códigos" para identificar os nomes dos ícones
  FSmileys := TDictionary<string, string>.Create;

  plcAdicionarSmiley('>:(', 'People_AngryFace');
  plcAdicionarSmiley(':angustiado:', 'People_AnguishedFace');
  plcAdicionarSmiley(':atonito:', 'People_AstonishedFace');
  plcAdicionarSmiley(':s', 'People_ConfoundedFace');
  plcAdicionarSmiley('O.o', 'People_ConfusedFace');
  plcAdicionarSmiley(':''(', 'People_CryingFace');
  plcAdicionarSmiley(':desapontadomasaliviado:', 'People_DisappointedButRelievedFace');
  plcAdicionarSmiley(':desapontado:', 'People_DisappointedFace');
  plcAdicionarSmiley(':tonto:', 'People_DizzyFace');
  plcAdicionarSmiley('-_-', 'People_ExpressionlessFace');
  plcAdicionarSmiley(':delicia:', 'People_FaceSavouringDeliciousFood');
  plcAdicionarSmiley(':@', 'People_FaceScreamingInFear');
  plcAdicionarSmiley(':*<3', 'People_FaceThrowingAKiss');
  plcAdicionarSmiley(''':<', 'People_FaceWithColdSweat');
  plcAdicionarSmiley(':trinunfo:', 'People_FaceWithLookOfTriumph');
  plcAdicionarSmiley(':#', 'People_FaceWithMedicalMask');
  plcAdicionarSmiley(':o', 'People_FaceWithOpenMouth');
  plcAdicionarSmiley(''':o', 'People_FaceWithOpenMouthAndColdSweat');
  plcAdicionarSmiley(':p', 'People_FaceWithStuckOutTongue');
  plcAdicionarSmiley('¦p', 'People_FaceWithStuckOutTongueAndTightlyClosedEyes');
  plcAdicionarSmiley(';p', 'People_FaceWithStuckOutTongueAndWinkingEye');
  plcAdicionarSmiley('kkkk', 'People_FaceWithTearsOfJoy');
  plcAdicionarSmiley(':silencio:', 'People_FaceWithoutMouth');
  plcAdicionarSmiley(':temeroso:', 'People_FearfulFace');
  plcAdicionarSmiley(':vergonha:', 'People_FlushedFace');
  plcAdicionarSmiley(':(', 'People_FrowningFaceWithOpenMouth');
  plcAdicionarSmiley(':careta:', 'People_GrimacingFace');
  plcAdicionarSmiley(':D', 'People_GrinningFace');
  plcAdicionarSmiley('3:<', 'People_Imp');
  plcAdicionarSmiley(':*', 'People_KissingFace');
  plcAdicionarSmiley('¦*', 'People_KissingFaceWithClosedEyes');
  plcAdicionarSmiley(':_(', 'People_LoudlyCryingFace');
  plcAdicionarSmiley(':|', 'People_NeutralFace');
  plcAdicionarSmiley(':pensativo:', 'People_PensiveFace');
  plcAdicionarSmiley(':raiva:', 'People_PoutingFace');
  plcAdicionarSmiley(':alivio:', 'People_RelievedFace');
  plcAdicionarSmiley('zzzz', 'People_SleepingFace');
  plcAdicionarSmiley(':sonolento:', 'People_SleepyFace');
  plcAdicionarSmiley('O:)', 'People_SmilingFaceWithHalo');
  plcAdicionarSmiley('<3)', 'People_SmilingFaceWithHeartShapedEyes');
  plcAdicionarSmiley('3:)', 'People_SmilingFaceWithHorns');
  plcAdicionarSmiley(''':D', 'People_SmilingFaceWithOpenMouthAndColdSweat');
  plcAdicionarSmiley('8-)', 'People_SmilingFaceWithSunglasses');
  plcAdicionarSmiley(':-1', 'People_SmirkingFace');
  plcAdicionarSmiley('(:|', 'People_TiredFace');
  plcAdicionarSmiley(':cansado:', 'People_WearyFace');
  plcAdicionarSmiley(';)', 'People_WinkingFace');
  plcAdicionarSmiley('>w<', 'People_WorriedFace');
  plcAdicionarSmiley('~:0', 'People_Baby');
  plcAdicionarSmiley('O~:0', 'People_BabyAngel');
  plcAdicionarSmiley('(:-)', 'People_Boy');
  plcAdicionarSmiley('8:^)', 'People_Girl');
  plcAdicionarSmiley(':princesa:', 'People_Princess');
  plcAdicionarSmiley(':homem:', 'People_Man');
  plcAdicionarSmiley(':mulher:', 'People_Woman');
  plcAdicionarSmiley(':noiva:', 'People_BrideWithVeil');
  plcAdicionarSmiley(':idoso:', 'People_OlderMan');
  plcAdicionarSmiley(':idosa:', 'People_OlderWoman');
  plcAdicionarSmiley(':casal:', 'People_ManAndWomanHoldingHands');
  plcAdicionarSmiley(':casalcoracao:', 'People_CoupleWithHeart');
  plcAdicionarSmiley(':familia:', 'People_Family');
  plcAdicionarSmiley(':noel:', 'People_FatherChristmas');
  plcAdicionarSmiley(':construcao:', 'People_ConstructionWorker');
  plcAdicionarSmiley(':policia:', 'People_PoliceOfficer');
  plcAdicionarSmiley(':caveira:', 'People_Skull');
  plcAdicionarSmiley(':fantasma:', 'People_Ghost');
  plcAdicionarSmiley('<3', 'Celebration_HeavyBlackHeart');
  plcAdicionarSmiley(':coracaopartido:', 'Celebration_BrokenHeart');
  plcAdicionarSmiley(':pegadas:', 'People_Footprints');
  plcAdicionarSmiley(':oracao:', 'People_PersonWithFoldedHands');
  plcAdicionarSmiley(':manicure:', 'People_NailPolish');
  plcAdicionarSmiley(':palmas:', 'People_ClappingHandsSign');
  plcAdicionarSmiley(':pare:', 'People_RaisedHand');
  plcAdicionarSmiley(':positivo:', 'People_ThumbsUpSign');
  plcAdicionarSmiley(':negativo:', 'People_ThumbsDownSign');
  plcAdicionarSmiley(':ok:', 'People_OkHandSign');
  plcAdicionarSmiley(':vitoria:', 'People_VictoryHand');
  plcAdicionarSmiley(':tchau:', 'People_WavingHandSign');
  plcAdicionarSmiley(':beijo:', 'People_KissMark');
  plcAdicionarSmiley(':cafe:', 'FoodDrink_HotBeverage');
  plcAdicionarSmiley(':cerveja:', 'FoodDrink_BeerMug');
  plcAdicionarSmiley(':brinde:', 'FoodDrink_ClinkingBeerMugs');
  plcAdicionarSmiley(':vinho:', 'FoodDrink_WineGlass');
  plcAdicionarSmiley(':coquitel:', 'FoodDrink_CocktailGlass');
  plcAdicionarSmiley(':coquiteltropical:', 'FoodDrink_TropicalDrink');
  plcAdicionarSmiley(':nuvem:', 'Nature_Cloud');
  plcAdicionarSmiley(':nublado:', 'Nature_SunBehindCloud');
  plcAdicionarSmiley(':chuva:', 'Nature_UmbrellaWithRainDrops');
  plcAdicionarSmiley(':fogo:', 'Nature_Fire');
  plcAdicionarSmiley(':cacto:', 'Nature_Cactus');
  plcAdicionarSmiley(':palmeira:', 'Nature_PalmTree');
  plcAdicionarSmiley(':pinheiro:', 'Nature_EvergreenTree');
  plcAdicionarSmiley(':arvore:', 'Nature_DeciduousTree');
  plcAdicionarSmiley(':flor:', 'Nature_CherryBlossom');
  plcAdicionarSmiley(':rosa:', 'Nature_Rose');
  plcAdicionarSmiley(':girassol:', 'Nature_Sunflower');
  plcAdicionarSmiley(':tulipa:', 'Nature_Tulip');

  if Length(vaArrayChaves) <> DMChat.ImgCollectionSmileys.Count then
    raise Exception.Create('A quantidade de imagens no componente ImgCollectionSmileys está' + sLineBreak + 'diferente da quantidade de imagens adicionadas na tela.');

  // Montando a expressão regular dos smileys para poder incluí-los no texto das mensagens e incluindo
  // o smiley na tela, par o usuário clicar
  FSmileysExpressaoRegular := ':[a-z1-9]{1,}:';
  vaLeft := 4;
  vaTop := 4;
  vaColuna := 1;
  vaQtdeColuna := (dockSiteSmileys.Width - 25) div 24; // 25 = 4 de espaçamento a esquerda, 4 de espaçamento a direita e 17 do scroll horizontal

  for vaChave in vaArrayChaves do
    begin
      // Montando a expressão regular
      if not TRegEx.IsMatch(vaChave, ':[a-z1-9]{1,}:', [roSingleLine, roIgnoreCase]) then
        FSmileysExpressaoRegular := FSmileysExpressaoRegular + '|' + TRegEx.Escape(vaChave);

      // Incluindo o "botão" dos smileys na tela, na mesma ordem em que foram informados
      vaImagem := nil;
      DMChat.ImgCollectionSmileys.Items.FindItemByName(FSmileys.Items[vaChave], vaImagem);

      if Assigned(vaImagem) then
        begin
          vaImage := TImage.Create(slbSmileys);
          vaImage.Parent := slbSmileys;
          vaImage.Height := 24;
          vaImage.Width := 24;
          vaImage.Center := True;
          vaImage.Hint := vaChave;
          vaImage.ShowHint := True;
          vaImage.Cursor := crHandPoint;
          vaImage.OnClick := ppvAdicionarSmileys;
          vaImage.Picture.Graphic := vaImagem.Picture.Graphic;
          vaImage.Top := vaTop;
          vaImage.Left := vaLeft;

          // Calculando o posicionamento da próxima imagem
          Inc(vaColuna);

          if vaColuna >= vaQtdeColuna then
            begin
              vaColuna := 1;
              vaTop := vaTop + vaImage.Height + 2;
            end;

          vaLeft := 4 + ((vaColuna - 1) * (vaImage.Width + 2));
        end;
    end;
end;

procedure TfrmChatTela.FormDestroy(Sender: TObject);
begin
  FSmileys.Clear;
  FreeAndNil(FSmileys);

  FUsuarioLogado.Clear;
  FreeAndNil(FUsuarioLogado);

  FreeAndNil(FConfiguracao);
  inherited;
end;

procedure TfrmChatTela.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
  procedure plcFoco;
  begin
    if pgcPrincipal.ActivePage = tabConversa then
      rveMensagensEdit.SetFocus
    else
      EditPesquisaUsuario.SetFocus;
  end;

begin
  inherited;

  case Key of
    VK_RETURN:
      begin
        if dockPanelPesqUsuarios.Visible then
          begin
            if DMChat.cdsUsuarios.RecordCount > 0 then
              begin
                // Não inverter a ordem destas duas linhas, pois ao fechar o dockPanelPesqUsuario a pesquisa é perdida (OnHideControl)
                ppvAdicionarConversa(fpvMontaIdentificador(DMChat.cdsUsuariosCODIGO.AsInteger, DMChat.cdsUsuariosCODIGO_HOSPITAL.AsInteger), True, False);
                dockPanelPesqUsuarios.Hide;
              end;
          end;
      end;
    VK_ESCAPE:
      begin
        if dockPanelPesqUsuarios.Visible then
          begin
            if EditNomeUsuario.Focused then
              begin
                if VarIsNull(EditNomeUsuario.EditingText) or (EditNomeUsuario.EditingText = '') then
                  begin
                    dockPanelPesqUsuarios.Hide;
                    plcFoco;
                  end;
              end
            else
              begin
                if cbGrupo.Focused then
                  begin
                    if not cbGrupo.DroppedDown then
                      begin
                        dockPanelPesqUsuarios.Hide;
                        plcFoco;
                      end;
                  end
                else
                  begin
                    if cbHospital.Focused then
                      begin
                        if not cbHospital.DroppedDown then
                          begin
                            dockPanelPesqUsuarios.Hide;
                            plcFoco;
                          end;
                      end
                    else
                      begin
                        dockPanelPesqUsuarios.Hide;
                        plcFoco;
                      end;
                  end;
              end;
          end;

        if dockPanelSmileys.Visible then
          begin
            dockPanelSmileys.Hide;
            rveMensagensEdit.SetFocus;
          end;
      end;
    VK_UP:
      begin
        if dockPanelPesqUsuarios.Visible and EditNomeUsuario.Focused then
          DMChat.cdsUsuarios.Prior;
      end;
    VK_DOWN:
      begin
        if dockPanelPesqUsuarios.Visible and EditNomeUsuario.Focused then
          DMChat.cdsUsuarios.Next;
      end;
    VK_F2:
      begin
        ppvAbrirTelaPesqUsuario;
      end;
    VK_F4:
      begin
        if ssAlt in Shift then
          Key := 0;
      end;
  end;
end;

procedure TfrmChatTela.FormKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  inherited;

  if (pgcPrincipal.ActivePage = tabConversa) and bttEnviar.Focused and rveMensagensEdit.Showing and rveMensagensEdit.Visible then
    rveMensagensEdit.SetFocus;
end;

procedure TfrmChatTela.FormMouseWheel(Sender: TObject; Shift: TShiftState;
  WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
begin
  inherited;

  if Sender is TRichViewEdit then
    begin
      if fpvMouseSobreComponente(TControl(Sender), MousePos) and
        ((not dockPanelSmileys.Visible) or (not fpvMouseSobreComponente(TControl(dockPanelSmileys), MousePos))) then
        TRichViewEdit(Sender).WheelStep := 2
      else
        TRichViewEdit(Sender).WheelStep := 0;
    end;
end;

procedure TfrmChatTela.FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
  procedure locRolarScroll(ipScrollBar: TcxScrollBoxScrollBarOptions);
  begin
    if (ipScrollBar.Position + ipScrollBar.Increment) <= ipScrollBar.Range then
      ipScrollBar.Position := ipScrollBar.Position + ipScrollBar.Increment
    else
      ipScrollBar.Position := ipScrollBar.Range;
  end;

  procedure locRolarScrollRVE(ipRVE: TRichViewEdit);
  begin
    if (ipRVE.VScrollPos + ipRVE.WheelStep) <= ipRVE.VScrollMax then
      ipRVE.VScrollPos := ipRVE.VScrollPos + ipRVE.WheelStep
    else
      ipRVE.VScrollPos := ipRVE.VScrollMax;
  end;

begin
  inherited;

  // Verificando se o mouse está sobre o componente
  if fpvMouseSobreComponente(slbConversasListaUsuarios) then
    locRolarScroll(slbConversasListaUsuarios.VertScrollBar);

  if (pgcPrincipal.ActivePage = tabConversa) then
    begin
      if (pgcDadosConversa.ActivePage = tabArquivos) and fpvMouseSobreComponente(slbListaArquivos) then
        locRolarScroll(slbListaArquivos.VertScrollBar)
      else
        begin
          if (pgcDadosConversa.ActivePage = tabGrupo) and fpvMouseSobreComponente(slbListaUsuariosGrupo) then
            locRolarScroll(slbListaUsuariosGrupo.VertScrollBar);
        end;

      if (dockPanelSmileys.Visible and fpvMouseSobreComponente(TControl(dockPanelSmileys), MousePos)) then
        locRolarScroll(slbSmileys.VertScrollBar)
      else
        begin
          if (not rveMensagens.Focused) and fpvMouseSobreComponente(rveMensagens) then
            locRolarScrollRVE(rveMensagens)
          else
            begin
              if (not rveMensagensEdit.Focused) and fpvMouseSobreComponente(rveMensagensEdit) then
                locRolarScrollRVE(rveMensagensEdit);
            end;
        end;
    end
  else
    begin
      if pgcPrincipal.ActivePage = TabPesquisa then
        begin
          if (not rvePesquisa.Focused) and fpvMouseSobreComponente(rvePesquisa) then
            locRolarScrollRVE(rvePesquisa);
        end;
    end;
end;

procedure TfrmChatTela.FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
  procedure locRolarScroll(ipScrollBar: TcxScrollBoxScrollBarOptions);
  begin
    if (ipScrollBar.Position - ipScrollBar.Increment) >= 0 then
      ipScrollBar.Position := ipScrollBar.Position - ipScrollBar.Increment
    else
      ipScrollBar.Position := 0;
  end;

  procedure locRolarScrollRVE(ipRVE: TRichViewEdit);
  begin
    if (ipRVE.VScrollPos - ipRVE.WheelStep) >= 0 then
      ipRVE.VScrollPos := ipRVE.VScrollPos - ipRVE.WheelStep
    else
      ipRVE.VScrollPos := 0;
  end;

begin
  inherited;

  // Verificando se o mouse está sobre o componente
  if fpvMouseSobreComponente(slbConversasListaUsuarios) then
    locRolarScroll(slbConversasListaUsuarios.VertScrollBar);

  if (pgcPrincipal.ActivePage = tabConversa) then
    begin
      if (pgcDadosConversa.ActivePage = tabArquivos) and fpvMouseSobreComponente(slbListaArquivos) then
        locRolarScroll(slbListaArquivos.VertScrollBar)
      else
        begin
          if (pgcDadosConversa.ActivePage = tabGrupo) and fpvMouseSobreComponente(slbListaUsuariosGrupo) then
            locRolarScroll(slbListaUsuariosGrupo.VertScrollBar);
        end;

      if (dockPanelSmileys.Visible and fpvMouseSobreComponente(TControl(dockPanelSmileys), MousePos)) then
        locRolarScroll(slbSmileys.VertScrollBar)
      else
        begin
          if (not rveMensagens.Focused) and fpvMouseSobreComponente(rveMensagens) then
            locRolarScrollRVE(rveMensagens)
          else
            begin
              if (not rveMensagensEdit.Focused) and fpvMouseSobreComponente(rveMensagensEdit) then
                locRolarScrollRVE(rveMensagensEdit);
            end;
        end;
    end
  else
    begin
      if pgcPrincipal.ActivePage = TabPesquisa then
        begin
          if (not rvePesquisa.Focused) and fpvMouseSobreComponente(rvePesquisa) then
            locRolarScrollRVE(rvePesquisa);
        end;
    end;
end;

procedure TfrmChatTela.FormResize(Sender: TObject);
var
  vaMaxWidth: TConstraintSize;
begin
  inherited;
  vaMaxWidth := Trunc(Self.Width / 3);

  if vaMaxWidth < 200 then
    vaMaxWidth := 200;

  pnlConversasListaUsuarios.Constraints.MaxWidth := vaMaxWidth;
  pgcDadosConversa.Constraints.MaxWidth := vaMaxWidth;
end;

procedure TfrmChatTela.FormShow(Sender: TObject);
begin
  inherited;
  DragAcceptFiles(Self.Handle, pgcPrincipal.ActivePage = tabConversa);
end;

function TfrmChatTela.fpvMouseSobreComponente(ipControl: TControl): Boolean;
var
  vaMousePos: TPoint;
begin
  Result := False;

  if GetCursorPos(vaMousePos) then
    Result := fpvMouseSobreComponente(ipControl, vaMousePos);
end;

function TfrmChatTela.fpuAtualizarConfiguracoes(
  const ipConfiguracoes: TChatConfiguracoes): string;
var
  vaFontes: TStringList;
begin
  Result := '';

  try
    try
      // Configurações de fonte
      // Validando as informações
      vaFontes := TUtils.fpuPegarFontesComputador;

      if TRegEx.IsMatch(vaFontes.Text, TRegEx.Escape(ipConfiguracoes.FonteNome), [roIgnoreCase, roSingleLine]) then
        FConfiguracao.FonteNome := ipConfiguracoes.FonteNome
      else
        FConfiguracao.FonteNome := 'Arial';

      case ipConfiguracoes.FonteTamanho of
        0 .. 100:
          FConfiguracao.FonteTamanho := ipConfiguracoes.FonteTamanho;
      else
        FConfiguracao.FonteTamanho := 10;
      end;

      // Configurando a fonte da mensagem
      DMChat.RVStyle1.TextStyles[0].FontName := FConfiguracao.FonteNome;
      DMChat.RVStyle1.TextStyles[0].Size := FConfiguracao.FonteTamanho;

      rvePesquisa.Change;
      rvePesquisa.Format;

      rveMensagens.Change;
      rveMensagens.Format;

      rveMensagensEdit.Change;
      rveMensagensEdit.Format;
    except
      on E: Exception do
        Result := E.Message;
    end;
  finally
    if Assigned(vaFontes) then
      FreeAndNil(vaFontes);
  end;
end;

function TfrmChatTela.fpuAtualizarHospitais(
  const ipListaHospitais: TList<TChatHospital>): string;
var
  vaChatHospital: TChatHospital;
  vaCdsHospitais: TpmClientDataSet;
begin
  Result := '';

  if Assigned(ipListaHospitais) then
    begin
      vaCdsHospitais := fpvClonarClientDataSet(DMChat.cdsHospitais);
      vaCdsHospitais.IndexFieldNames := 'CODIGO';

      try
        try
          for vaChatHospital in ipListaHospitais do
            begin
              if vaCdsHospitais.Locate('codigo', vaChatHospital.Codigo, []) then
                vaCdsHospitais.Edit
              else
                begin
                  vaCdsHospitais.Append;
                  vaCdsHospitais.FieldByName('CODIGO').AsInteger := vaChatHospital.Codigo;
                end;

              vaCdsHospitais.FieldByName('NOME_FANTASIA').AsString := vaChatHospital.NomeFantasia;
              vaCdsHospitais.FieldByName('RAZAO_SOCIAL').AsString := vaChatHospital.RazaoSocial;
              vaCdsHospitais.Post;
            end;
        except
          on E: Exception do
            Result := E.Message;
        end;
      finally
        if Assigned(vaCdsHospitais) then
          begin
            vaCdsHospitais.Close;
            FreeAndNil(vaCdsHospitais);
          end;
      end;
    end;
end;

function TfrmChatTela.fpuAtualizarStatus(
  const ipListaStatus: TList<TChatStatus>): string;
var
  vaStatus: TChatStatus;
  vaCdsUsuarios: TpmClientDataSet;
begin
  Result := '';

  if Assigned(ipListaStatus) then
    begin
      vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
      vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

      try
        try
          // Atualizando os registros no ClientDataSet
          for vaStatus in ipListaStatus do
            begin
              if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaStatus.IdentificacaoUsuario.CodigoUsuario, vaStatus.IdentificacaoUsuario.CodigoHospital]), []) then
                begin
                  // Se o usuário for um grupo, não tem que atualizar o status, pois grupo não possui status
                  if vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 0 then
                    begin
                      vaCdsUsuarios.Edit;
                      vaCdsUsuarios.FieldByName('STATUS').AsInteger := vaStatus.Status;
                      vaCdsUsuarios.Post;
                    end;
                end
              else
                begin
                  if Result <> '' then
                    Result := Result + ';';

                  Result := Result + IntToStr(vaStatus.IdentificacaoUsuario.CodigoUsuario) + '_' + IntToStr(vaStatus.IdentificacaoUsuario.CodigoHospital);
                end;
            end;

          // Fechando e liberando da memmóia a tabela temporária de usuários antes de executar o procedimento ppvAtualizarDadosUsuarioTela,
          // pois nesse procedimento ela é novamente criada, caso necessário, e a partir deste ponto ela não é mais necessária nesta função
          vaCdsUsuarios.Close;
          FreeAndNil(vaCdsUsuarios);

          // Atulizando os dados da tela (Otimizando a atulização da tela, escolhendo a forma que fará menos looping)
          if ipListaStatus.Count >= slbConversasListaUsuarios.ComponentCount then
            ppvAtualizarDadosUsuarioTela('', nil, True)
          else
            begin
              for vaStatus in ipListaStatus do
                ppvAtualizarDadosUsuarioTela(fpvMontaIdentificador(vaStatus.IdentificacaoUsuario.CodigoUsuario, vaStatus.IdentificacaoUsuario.CodigoHospital), nil, True);
            end;
        except
          on E: Exception do
            Result := E.Message;
        end;
      finally
        if Assigned(vaCdsUsuarios) then
          begin
            vaCdsUsuarios.Close;
            FreeAndNil(vaCdsUsuarios);
          end;
      end;
    end;
end;

function TfrmChatTela.fpuAtualizarUsuarios(
  const ipListaUsuarios: TList<TChatUsuario>): string;
var
  vaFoto: TBytesStream;
  vaChatUsuario: TChatUsuario;
  vaCdsUsuarios, vaCdsGrupos, vaCdsGruposUsuarios: TpmClientDataSet;
  vaCodigoUsuario: Integer;
begin
  Result := '';

  if Assigned(ipListaUsuarios) then
    begin
      vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
      vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

      vaCdsGrupos := fpvClonarClientDataSet(DMChat.cdsGrupos);
      vaCdsGrupos.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

      vaCdsGruposUsuarios := fpvClonarClientDataSet(DMChat.cdsGrupos_Usuarios);
      vaCdsGruposUsuarios.IndexFieldNames := 'CODIGO_GRUPO;CODIGO_HOSPITAL;CODIGO_USUARIO';

      try
        try
          // Atualizando os registros no ClientDataSet
          for vaChatUsuario in ipListaUsuarios do
            begin
              if (vaChatUsuario.IdentificacaoUsuario.CodigoUsuario = 0) and (vaChatUsuario.UsuarioGrupo = 0) then
                vaCodigoUsuario := FCodigoUsuarioSistema
              else
                vaCodigoUsuario := vaChatUsuario.IdentificacaoUsuario.CodigoUsuario;

              if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaCodigoUsuario, vaChatUsuario.IdentificacaoUsuario.CodigoHospital]), []) then
                // Usuário encontrado, basta atualizar os dados
                vaCdsUsuarios.Edit
              else
                begin
                  // Usuário não encontrado, então vamos adicioná-lo
                  vaCdsUsuarios.Append;
                  vaCdsUsuarios.FieldByName('CODIGO').AsInteger := vaCodigoUsuario;
                  vaCdsUsuarios.FieldByName('CODIGO_HOSPITAL').AsInteger := vaChatUsuario.IdentificacaoUsuario.CodigoHospital;
                end;

              // Atualizando os dados
              vaCdsUsuarios.FieldByName('EMAIL').AsString := vaChatUsuario.EMail;
              vaCdsUsuarios.FieldByName('NOME').AsString := vaChatUsuario.Nome;
              vaCdsUsuarios.FieldByName('PROMEDICO').AsInteger := vaChatUsuario.Promedico;
              vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger := vaChatUsuario.UsuarioGrupo;
              vaCdsUsuarios.FieldByName('ATIVO_INATIVO').AsInteger := vaChatUsuario.AtivoInativo;

              try
                if Assigned(vaChatUsuario.Foto) or (vaCodigoUsuario = FCodigoUsuarioSistema) then
                  begin
                    vaFoto := TBytesStream.Create;

                    if vaCodigoUsuario = FCodigoUsuarioSistema then
                      begin
                        DMChat.ImgCollectionItemIconeProMedico72x72.Picture.Graphic.SaveToStream(vaFoto);
                        vaCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 0;
                      end
                    else
                      begin
                        vaChatUsuario.Foto.Graphic.SaveToStream(vaFoto);
                        vaCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 1;
                      end;

                    vaFoto.Position := 0;
                    TBlobField(vaCdsUsuarios.FieldByName('FOTO')).LoadFromStream(vaFoto);
                  end
                else
                  begin
                    vaCdsUsuarios.FieldByName('FOTO').Clear;
                    vaCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 0;
                  end;

                if Assigned(vaChatUsuario.FotoThumbnail) or (vaCodigoUsuario = FCodigoUsuarioSistema) then
                  begin
                    if Assigned(vaFoto) then
                      vaFoto.Clear
                    else
                      vaFoto := TBytesStream.Create;

                    if vaCodigoUsuario = FCodigoUsuarioSistema then
                      begin
                        DMChat.ImgCollectionItemIconeProMedico32x32.Picture.Graphic.SaveToStream(vaFoto);
                        vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 0;
                      end
                    else
                      begin
                        vaChatUsuario.FotoThumbnail.Graphic.SaveToStream(vaFoto);
                        vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 1;
                      end;

                    vaFoto.Position := 0;
                    TBlobField(vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL')).LoadFromStream(vaFoto);
                  end
                else
                  begin
                    vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL').Clear;

                    if Assigned(vaChatUsuario.Foto) then
                      vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 1
                    else
                      vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 0;
                  end;

              finally
                if Assigned(vaFoto) then
                  FreeAndNil(vaFoto);
              end;

              if vaCdsUsuarios.State in [dsInsert] then
                vaCdsUsuarios.FieldByName('CARREGAR_MENSAGENS').AsInteger := 1;

              if vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 0 then
                begin
                  // Usuário do tipo Usuário
                  vaCdsUsuarios.FieldByName('FUNCAO').AsString := vaChatUsuario.Funcao;
                  vaCdsUsuarios.FieldByName('STATUS').AsInteger := vaChatUsuario.Status;
                end
              else
                begin
                  // Usuário do tipo Grupo
                  vaCdsUsuarios.FieldByName('FUNCAO').AsString := '';
                  vaCdsUsuarios.FieldByName('STATUS').AsInteger := -1;

                  // Atualizando a tabela de grupos
                  if vaCdsGrupos.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaChatUsuario.IdentificacaoUsuario.CodigoUsuario, vaChatUsuario.IdentificacaoUsuario.CodigoHospital]), []) then
                    vaCdsGrupos.Edit
                  else
                    begin
                      vaCdsGrupos.Append;
                      vaCdsGrupos.FieldByName('CODIGO').AsInteger := vaChatUsuario.IdentificacaoUsuario.CodigoUsuario;
                      vaCdsGrupos.FieldByName('CODIGO_HOSPITAL').AsInteger := vaChatUsuario.IdentificacaoUsuario.CodigoHospital;
                    end;

                  vaCdsGrupos.FieldByName('NOME').AsString := vaChatUsuario.Nome;

                  // Gravando o grupo
                  vaCdsGrupos.Post;

                  // Usuários do grupo
                  for vaCodigoUsuario in vaChatUsuario.GrupoUsuarios do
                    begin
                      // Atualizando a tabela de usuários do grupo
                      if not vaCdsGruposUsuarios.Locate('CODIGO_GRUPO;CODIGO_HOSPITAL;CODIGO_USUARIO', VarArrayOf([vaCdsGrupos.FieldByName('CODIGO').AsInteger, vaChatUsuario.IdentificacaoUsuario.CodigoHospital, vaCodigoUsuario]), []) then
                        begin
                          vaCdsGruposUsuarios.Append;
                          vaCdsGruposUsuarios.FieldByName('CODIGO_HOSPITAL').AsInteger := vaChatUsuario.IdentificacaoUsuario.CodigoHospital;
                          vaCdsGruposUsuarios.FieldByName('CODIGO_GRUPO').AsInteger := vaCdsGrupos.FieldByName('CODIGO').AsInteger;
                          vaCdsGruposUsuarios.FieldByName('CODIGO_USUARIO').AsInteger := vaCodigoUsuario;
                          vaCdsGruposUsuarios.Post;
                        end;
                    end;
                end;

              // Gravando o usuário
              vaCdsUsuarios.Post;
            end;

          // Fechando e liberando da memmóia a tabela temporária de usuários e grupos antes de executar o procedimento ppvAtualizarDadosUsuarioTela,
          // pois nesse procedimento essas tabelas são novamente criadas, caso necessário, e a partir deste ponto não são mais necessárias nesta função
          vaCdsUsuarios.Close;
          FreeAndNil(vaCdsUsuarios);

          vaCdsGrupos.Close;
          FreeAndNil(vaCdsGrupos);

          vaCdsGruposUsuarios.Close;
          FreeAndNil(vaCdsGruposUsuarios);

          // Atulizando os dados da tela (Otimizando a atulização da tela, escolhendo a forma que fará menos looping)
          if ipListaUsuarios.Count >= slbConversasListaUsuarios.ComponentCount then
            ppvAtualizarDadosUsuarioTela
          else
            begin
              for vaChatUsuario in ipListaUsuarios do
                ppvAtualizarDadosUsuarioTela(fpvMontaIdentificador(vaChatUsuario.IdentificacaoUsuario.CodigoUsuario, vaChatUsuario.IdentificacaoUsuario.CodigoHospital));
            end;

          // Atualizando os dados do usuário logado
          ppvAtualizarDadosUsuarioLogado;
        except
          on E: Exception do
            Result := E.Message;
        end;
      finally
        if Assigned(vaCdsUsuarios) then
          begin
            vaCdsUsuarios.Close;
            FreeAndNil(vaCdsUsuarios);
          end;

        if Assigned(vaCdsGrupos) then
          begin
            vaCdsGrupos.Close;
            FreeAndNil(vaCdsGrupos);
          end;

        if Assigned(vaCdsGruposUsuarios) then
          begin
            vaCdsGruposUsuarios.Close;
            FreeAndNil(vaCdsGruposUsuarios);
          end;
      end;
    end;
end;

function TfrmChatTela.fpuNovaMensagem(const ipCodigoMensagens,
  ipCodigoRemetente, ipCodigoHospital, ipCodigoDestinatario: Integer): string;
var
  vaCdsMensagem, vaCdsMensagem_Anexo, vaCdsUsuarios: TpmClientDataSet;
  vaDestinatario, vaRemetente, vaUsuarioLogado: TChatIdentificacaoUsuario;
  vaUsuarioSistema, vaSomenteRegistroSelecionado: Boolean;
  vaCodigoUsurio: Integer;
begin
  Result := '';
  vaSomenteRegistroSelecionado := True;
  vaDestinatario.CodigoHospital := ipCodigoHospital;
  vaDestinatario.CodigoUsuario := ipCodigoDestinatario;
  vaRemetente.CodigoHospital := ipCodigoHospital;
  vaRemetente.CodigoUsuario := ipCodigoRemetente;
  vaUsuarioSistema := ipCodigoRemetente = 0;

  vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);
  vaCdsMensagem.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
  vaCdsMensagem_Anexo := fpvClonarClientDataSet(DMChat.cdsMensagem_Anexo);
  vaCdsMensagem_Anexo.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
  vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
  vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

  try
    if fpvPesquisarConversa(
      TChatTipoPesquisa.tpqCodigo,
      IntToStr(ipCodigoMensagens),
      StrToDate('01/01/1900'),
      StrToDate('01/01/1900'),
      vaRemetente,
      vaDestinatario,
      vaUsuarioSistema,
      False,
      vaCdsMensagem,
      vaCdsMensagem_Anexo) then
      begin
        if vaCdsMensagem.RecordCount > 0 then
          begin
            if not fpvUsuarioLogado(ipCodigoHospital, vaUsuarioLogado) then
              begin
                MessageTela('Não foi possível identificar o usuário logado.');
                Exit;
              end;

            // Verificando se há a necessidade de carregar as mensagens da conversa antes de incluir a nova mensagem
            if (vaDestinatario.CodigoHospital = vaUsuarioLogado.CodigoHospital) or
              (vaDestinatario.CodigoUsuario = vaUsuarioLogado.CodigoUsuario) then
              begin
                // O usuário logado é o destinatário, então vamos pesquisar a conversa pelo remetente

                // Verificando se foi o usuário do sistema que enviou
                if vaRemetente.CodigoUsuario = 0 then
                  vaCodigoUsurio := FCodigoUsuarioSistema
                else
                  vaCodigoUsurio := vaRemetente.CodigoUsuario;
              end
            else
              begin
                // O usuário logado não é destinatário, então recebeu a mensagem por ser um grupo ou é o remetente, neste caso
                // pesquisar a conversa pelo destinatário
                vaCodigoUsurio := vaDestinatario.CodigoUsuario;
              end;

            if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaCodigoUsurio, ipCodigoHospital]), []) and
              (vaCdsUsuarios.FieldByName('CARREGAR_MENSAGENS').AsInteger = 1) then
              begin
                ppvCarregarMensgensBancoDados(fpvMontaIdentificador(vaCodigoUsurio, ipCodigoHospital));
                vaSomenteRegistroSelecionado := False;
              end;

            // Filtrando a mensagem
            vaCdsMensagem.Filtered := False;
            vaCdsMensagem.Filter := 'CODIGO = ' + IntToStr(ipCodigoMensagens) + ' AND CODIGO_HOSPITAL = ' + IntToStr(ipCodigoHospital);
            vaCdsMensagem.Filtered := True;

            vaCdsMensagem_Anexo.Filtered := False;
            vaCdsMensagem_Anexo.IndexFieldNames := 'CODIGO_MENSAGEM;CODIGO_HOSPITAL';
            vaCdsMensagem_Anexo.Filter := 'CODIGO_MENSAGEM = ' + IntToStr(vaCdsMensagem.FieldByName('CODIGO').AsInteger) + ' AND CODIGO_HOSPITAL = ' + IntToStr(ipCodigoHospital);
            vaCdsMensagem_Anexo.Filtered := True;

            // Inserindo a mensagem no RichViewEdit se a conversa estiver selecionada, senão emite uma notificação de nova mensagem
            if (vaRemetente.CodigoHospital <> vaUsuarioLogado.CodigoHospital) or
              (vaRemetente.CodigoUsuario <> vaUsuarioLogado.CodigoUsuario) then
              begin
                if Assigned(FChatPanelSelecionado) and
                  (((vaRemetente.CodigoHospital = fpvCodigoHospital(FChatPanelSelecionado.Identificador)) and
                  (vaRemetente.CodigoUsuario = fpvCodigoUsuario(FChatPanelSelecionado.Identificador))) or
                  ((vaDestinatario.CodigoHospital = fpvCodigoHospital(FChatPanelSelecionado.Identificador)) and
                  (vaDestinatario.CodigoUsuario = fpvCodigoUsuario(FChatPanelSelecionado.Identificador)))) then
                  begin
                    ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rveMensagens, vaSomenteRegistroSelecionado);
                    ppvInformarMensagensLidas(fpvMontaIdentificador(ipCodigoRemetente, ipCodigoHospital));
                  end
                else
                  begin
                    if (vaDestinatario.CodigoHospital = vaUsuarioLogado.CodigoHospital) or
                      (vaDestinatario.CodigoUsuario = vaUsuarioLogado.CodigoUsuario) then
                      ppvAdicionarConversa(fpvMontaIdentificador(vaRemetente.CodigoUsuario, vaRemetente.CodigoHospital), False, True)
                    else
                      ppvAdicionarConversa(fpvMontaIdentificador(vaDestinatario.CodigoUsuario, vaDestinatario.CodigoHospital), False, True);
                  end;
              end
            else
              ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rveMensagens, vaSomenteRegistroSelecionado);
          end;
      end;
  finally
    if Assigned(vaCdsUsuarios) then
      begin
        vaCdsUsuarios.Close;
        FreeAndNil(vaCdsUsuarios);
      end;

    if Assigned(vaCdsMensagem) then
      begin
        vaCdsMensagem.Close;
        FreeAndNil(vaCdsMensagem);
      end;

    if Assigned(vaCdsMensagem_Anexo) then
      begin
        vaCdsMensagem_Anexo.Close;
        FreeAndNil(vaCdsMensagem_Anexo);
      end;
  end;
end;

function TfrmChatTela.fpuNovaMensagem(
  const ipMensagens: TList<TChatMensagem>): string;
var
  vaMensagem: TChatMensagem;
  vaCdsMensagem, vaCdsMensagem_Anexo, vaCdsUsuarios: TpmClientDataSet;
  vaAnexo: TChatAnexo;
  vaCodigoUsurio, vaCodigoHospital: Integer;
  vaSomenteRegistroSelecionado: Boolean;
  vaUsuarioLogado: TChatIdentificacaoUsuario;
begin
  Result := '';
  vaCdsMensagem_Anexo := nil;
  vaSomenteRegistroSelecionado := True;

  if Assigned(ipMensagens) then
    begin
      vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);
      vaCdsMensagem.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
      vaCdsMensagem_Anexo := fpvClonarClientDataSet(DMChat.cdsMensagem_Anexo);
      vaCdsMensagem_Anexo.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
      vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
      vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

      try
        try
          for vaMensagem in ipMensagens do
            begin
              // Verificando se tem um usuário logado no hospital da conversa, se não tiver, ignora a mensagem
              if fpvUsuarioLogado(vaMensagem.Remetente.CodigoHospital, vaUsuarioLogado) then
                begin
                  // Verificando se há a necessidade de carregar as mensagens da conversa antes de incluir a nova mensagem
                  if (vaMensagem.Destinatario.CodigoHospital = vaUsuarioLogado.CodigoHospital) or
                    (vaMensagem.Destinatario.CodigoUsuario = vaUsuarioLogado.CodigoUsuario) then
                    begin
                      // O usuário logado é o destinatário, então vamos pesquisar a conversa pelo remetente

                      // Verificando se foi o usuário do sistema que enviou
                      if vaMensagem.Remetente.CodigoUsuario = 0 then
                        vaCodigoUsurio := FCodigoUsuarioSistema
                      else
                        vaCodigoUsurio := vaMensagem.Remetente.CodigoUsuario;

                      vaCodigoHospital := vaMensagem.Remetente.CodigoHospital;
                    end
                  else
                    begin
                      // O usuário logado não é destinatário, então recebeu a mensagem por ser um grupo ou é o remetente, neste caso
                      // pesquisar a conversa pelo destinatário
                      vaCodigoUsurio := vaMensagem.Destinatario.CodigoUsuario;
                      vaCodigoHospital := vaMensagem.Destinatario.CodigoHospital;
                    end;

                  if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaCodigoUsurio, vaCodigoHospital]), []) and
                    (vaCdsUsuarios.FieldByName('CARREGAR_MENSAGENS').AsInteger = 1) then
                    begin
                      ppvCarregarMensgensBancoDados(fpvMontaIdentificador(vaCodigoUsurio, vaCodigoHospital));
                      vaSomenteRegistroSelecionado := False;
                    end;

                  // Gravando a mensagem
                  if not vaCdsMensagem.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaMensagem.Codigo, vaMensagem.Remetente.CodigoHospital]), []) then
                    begin
                      // Gravando a mensagem no ClientDataSet
                      vaCdsMensagem.Append;
                      vaCdsMensagem.FieldByName('CODIGO').AsInteger := vaMensagem.Codigo;
                      vaCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsInteger := vaMensagem.Destinatario.CodigoUsuario;
                      vaCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger := vaMensagem.Remetente.CodigoHospital;
                      vaCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger := vaMensagem.Remetente.CodigoUsuario;
                      vaCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime := vaMensagem.DataHora;
                      vaCdsMensagem.FieldByName('MENSAGEM').AsString := vaMensagem.MensagemTXT;
                      vaCdsMensagem.FieldByName('TIPO_MENSAGEM').AsInteger := vaMensagem.TipoMensagem;
                      vaCdsMensagem.Post;

                      // Gravando os anexos da mensagem no ClientDateSet
                      if vaMensagem.AnexosQtde > 0 then
                        begin
                          vaCdsMensagem_Anexo := fpvClonarClientDataSet(DMChat.cdsMensagem_Anexo);

                          for vaAnexo in vaMensagem.Anexos do
                            begin
                              if not vaCdsMensagem_Anexo.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaAnexo.Codigo, vaMensagem.Remetente.CodigoHospital]), []) then
                                begin
                                  vaCdsMensagem_Anexo.Append;
                                  vaCdsMensagem_Anexo.FieldByName('CODIGO').AsInteger := vaAnexo.Codigo;
                                  vaCdsMensagem_Anexo.FieldByName('CODIGO_MENSAGEM').AsInteger := vaMensagem.Codigo;
                                  vaCdsMensagem_Anexo.FieldByName('CODIGO_DESTINATARIO').AsInteger := vaMensagem.Destinatario.CodigoUsuario;
                                  vaCdsMensagem_Anexo.FieldByName('CODIGO_HOSPITAL').AsInteger := vaMensagem.Destinatario.CodigoHospital;
                                  vaCdsMensagem_Anexo.FieldByName('CODIGO_REMETENTE').AsInteger := vaMensagem.Remetente.CodigoUsuario;
                                  vaCdsMensagem_Anexo.FieldByName('DATAHORA_ENVIO').AsDateTime := vaMensagem.DataHora;
                                  vaCdsMensagem_Anexo.FieldByName('LOCAL').AsString := vaAnexo.Endereco;
                                  vaCdsMensagem_Anexo.FieldByName('NOME').AsString := vaAnexo.Nome;
                                  vaCdsMensagem_Anexo.FieldByName('TAMANHO_COMP').AsLargeInt := vaAnexo.Tamanho;
                                  vaCdsMensagem_Anexo.FieldByName('TAMANHO_ORIG').AsLargeInt := vaAnexo.TamanhoOriginal;

                                  if Assigned(vaAnexo.ArquivoThumbnail) then
                                    begin
                                      vaAnexo.ArquivoThumbnail.Position := 0;
                                      TBlobField(vaCdsMensagem_Anexo.FieldByName('THUMBNAIL')).LoadFromStream(vaAnexo.ArquivoThumbnail);
                                    end
                                  else
                                    vaCdsMensagem_Anexo.FieldByName('THUMBNAIL').Clear;

                                  vaCdsMensagem_Anexo.Post;
                                end;
                            end;
                        end;

                      // Inserindo a mensagem no RichViewEdit se a conversa estiver selecionada, senão emite uma notificação de nova mensagem
                      if (vaMensagem.Remetente.CodigoHospital <> vaUsuarioLogado.CodigoHospital) or
                        (vaMensagem.Remetente.CodigoUsuario <> vaUsuarioLogado.CodigoUsuario) then
                        begin
                          if Assigned(FChatPanelSelecionado) and
                            (((vaMensagem.Remetente.CodigoHospital = fpvCodigoHospital(FChatPanelSelecionado.Identificador)) and
                            (vaMensagem.Remetente.CodigoUsuario = fpvCodigoUsuario(FChatPanelSelecionado.Identificador))) or
                            ((vaMensagem.Destinatario.CodigoHospital = fpvCodigoHospital(FChatPanelSelecionado.Identificador)) and
                            (vaMensagem.Destinatario.CodigoUsuario = fpvCodigoUsuario(FChatPanelSelecionado.Identificador)))) then
                            begin
                              ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rveMensagens, vaSomenteRegistroSelecionado);
                              ppvInformarMensagensLidas(FChatPanelSelecionado.Identificador);
                            end
                          else
                            begin
                              if (vaMensagem.Destinatario.CodigoHospital = vaUsuarioLogado.CodigoHospital) or
                                (vaMensagem.Destinatario.CodigoUsuario = vaUsuarioLogado.CodigoUsuario) then
                                ppvAdicionarConversa(fpvMontaIdentificador(vaMensagem.Remetente.CodigoUsuario, vaMensagem.Remetente.CodigoHospital), False, True)
                              else
                                ppvAdicionarConversa(fpvMontaIdentificador(vaMensagem.Destinatario.CodigoUsuario, vaMensagem.Destinatario.CodigoHospital), False, True);
                            end;
                        end
                      else
                        ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rveMensagens, vaSomenteRegistroSelecionado);
                    end;
                end;
            end;
        except
          on E: Exception do
            Result := E.Message;
        end;
      finally
        if Assigned(vaCdsMensagem) then
          begin
            vaCdsMensagem.Close;
            FreeAndNil(vaCdsMensagem);
          end;

        if Assigned(vaCdsMensagem_Anexo) then
          begin
            vaCdsMensagem_Anexo.Close;
            FreeAndNil(vaCdsMensagem_Anexo);
          end;

        if Assigned(vaCdsUsuarios) then
          begin
            vaCdsUsuarios.Close;
            FreeAndNil(vaCdsUsuarios);
          end;
      end;
    end;
end;

function TfrmChatTela.fpuRetornaImagem(
  const ipBytesStream: TBytesStream): TPicture;
var
  vaGraphic: TGraphic;
  vaGraphicClass: TGraphicClass;
begin
  Result := nil;

  try
    vaGraphic := fpvImagem(ipBytesStream, TWICImageFormat.wifJpeg);

    if Assigned(vaGraphic) then
      begin
        Result := TPicture.Create;
        Result.Graphic := vaGraphic;
      end;
  finally
    if Assigned(vaGraphic) then
      FreeAndNil(vaGraphic);
  end;
end;

function TfrmChatTela.fpvClonarClientDataSet(
  const ipCdsOrigem: TpmClientDataSet): TpmClientDataSet;
begin
  Result := nil;

  if Assigned(ipCdsOrigem) then
    begin
      Result := TpmClientDataSet.Create(nil);
      Result.CloneCursor(ipCdsOrigem, True);
      Result.pmAutoRefresh := False;
      Result.pmApplyUpdatesAutomatico := False;
      Result.pmGerarLog := False;
      Result.Filtered := False;
      Result.Filter := '';
      Result.First;
    end;
end;

function TfrmChatTela.fpvCodigoHospital(const ipIdentificador: string): Integer;
begin
  Result := StrToIntDef(TRegEx.Replace(TRegEx.Match(ipIdentificador, '(?<=_)n?\d{1,}$', [roIgnoreCase, roSingleLine]).Value, '^n', '-', [roIgnoreCase, roSingleLine]), 0);
end;

function TfrmChatTela.fpvCodigosUsuarioHospital(
  const ipIdentificador: string): Variant;
begin
  Result := VarArrayOf([fpvCodigoUsuario(ipIdentificador), fpvCodigoHospital(ipIdentificador)]);
end;

function TfrmChatTela.fpvCodigoUsuario(const ipIdentificador: string): Integer;
begin
  Result := StrToIntDef(TRegEx.Replace(TRegEx.Match(ipIdentificador, '^n?\d{1,}(?=_)', [roIgnoreCase, roSingleLine]).Value, '^n', '-', [roIgnoreCase, roSingleLine]), 0);
end;

function TfrmChatTela.fpvDownloadArquivo(const ipCodigoHospital: Integer;
  const ipEnerecoArquivo: string): TBytesStream;
begin
  Result := nil;

  if Assigned(FAoFazerDownloadArquivo) then
    Result := FAoFazerDownloadArquivo(ipCodigoHospital, ipEnerecoArquivo);
end;

function TfrmChatTela.fpvFindGraphicClass(const ipBuffer; const ipBufferSize: Int64;
  out ioGraphicClass: TGraphicClass): Boolean;
var
  vaLongWords: array [Byte] of LongWord absolute ipBuffer;
  vaWords: array [Byte] of Word absolute ipBuffer;
begin
  ioGraphicClass := nil;
  Result := False;

  if ipBufferSize < coMinGraphicSize then
    Exit;

  case vaWords[0] of
    $4D42:
      ioGraphicClass := TBitmap;
    $D8FF:
      ioGraphicClass := TJPEGImage;
    $4949:
      if vaWords[1] = $002A then
        ioGraphicClass := TWicImage; // i.e., TIFF
    $4D4D:
      if vaWords[1] = $2A00 then
        ioGraphicClass := TWicImage; // i.e., TIFF
  else
    if Int64(ipBuffer) = $A1A0A0D474E5089 then
      ioGraphicClass := TPNGImage
    else
      begin
        if vaLongWords[0] = $9AC6CDD7 then
          ioGraphicClass := TMetafile
        else
          begin
            if (vaLongWords[0] = 1) and (vaLongWords[10] = $464D4520) then
              ioGraphicClass := TMetafile
            else
              begin
                if System.AnsiStrings.StrLComp(PAnsiChar(@ipBuffer), 'GIF', 3) = 0 then
                  ioGraphicClass := TGIFImage
                else
                  begin
                    if vaWords[1] = 1 then
                      ioGraphicClass := TIcon;
                  end;
              end;
          end;
      end;
  end;

  Result := (ioGraphicClass <> nil);
end;

function TfrmChatTela.fpvFindGraphicClass(const ipStream: TStream;
  out ioGraphicClass: TGraphicClass): Boolean;
var
  vaBuffer: PByte;
  vaCurPos: Int64;
  vaBytesRead: Integer;
begin
  if ipStream is TCustomMemoryStream then
    begin
      vaBuffer := TCustomMemoryStream(ipStream).Memory;
      vaCurPos := ipStream.Position;
      Inc(vaBuffer, vaCurPos);
      Result := fpvFindGraphicClass(vaBuffer^, ipStream.Size - vaCurPos, ioGraphicClass);
    end
  else
    begin
      GetMem(vaBuffer, coMinGraphicSize);

      try
        vaBytesRead := ipStream.Read(vaBuffer^, coMinGraphicSize);
        ipStream.Seek(-vaBytesRead, soCurrent);
        Result := fpvFindGraphicClass(vaBuffer^, vaBytesRead, ioGraphicClass);
      finally
        FreeMem(vaBuffer);
      end;
    end;
end;

function TfrmChatTela.fpvIconeArquivo(const ipExtensaoArquivo: string): TPicture;
var
  vaImagemSelecionada: TPicture;
  vaBytesStream: TBytesStream;
  vaGraphic: TGraphic;
begin
  Result := TPicture.Create;
  vaBytesStream := nil;

  // Retornando o ícone de acordo com a extensão do arquivo

  // Excel - csv, ods, prn, slsm, xla, xlam, xls, xlsb, xlsx, xlt, xltm, xltx, xps
  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(csv|ods|prn|slsm|xlam?|xls(b|x)?|xlt(m|x)?|xps)$', [roIgnoreCase, roSingleLine]) then
    vaImagemSelecionada := DMChat.ImgCollectionItemArquivoExcel.Picture
  else
    begin
      // Word - doc, docm, docx, dot, dotm, dotx, odt, rtf
      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(do(c|t)(m|x)?|rtf|odt)$', [roIgnoreCase, roSingleLine]) then
        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoWord.Picture
      else
        begin
          // Power Point - odp, pot, potm, potx, ppam, ppa, pps, ppsm, ppsx, ppt, pptm, pptx
          if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(odp|pot(m|x)?|ppam?|pp(s|t)(m|x)?)$', [roIgnoreCase, roSingleLine]) then
            vaImagemSelecionada := DMChat.ImgCollectionItemArquivoPowerPoint.Picture
          else
            begin
              // Texto - TXT
              if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(txt)$', [roIgnoreCase, roSingleLine]) then
                vaImagemSelecionada := DMChat.ImgCollectionItemArquivoTexto.Picture
              else
                begin
                  // PDF
                  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?pdf$', [roIgnoreCase, roSingleLine]) then
                    vaImagemSelecionada := DMChat.ImgCollectionItemArquivoPDF.Picture
                  else
                    begin
                      // RAR
                      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?rar$', [roIgnoreCase, roSingleLine]) then
                        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoRar.Picture
                      else
                        begin
                          // ZIP
                          if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?zip$', [roIgnoreCase, roSingleLine]) then
                            vaImagemSelecionada := DMChat.ImgCollectionItemArquivoZip.Picture
                          else
                            begin
                              // XML
                              if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(xml)$', [roIgnoreCase, roSingleLine]) then
                                vaImagemSelecionada := DMChat.ImgCollectionItemArquivoXML.Picture
                              else
                                begin
                                  // Configuração - DLL, INI, SYS
                                  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(dll|ini|sys)$', [roIgnoreCase, roSingleLine]) then
                                    vaImagemSelecionada := DMChat.ImgCollectionItemArquivoConfiguracao.Picture
                                  else
                                    begin
                                      // Música - aac, ac3, mid, mp3, ogg, wav, wma
                                      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(aac|ac3|mid|mp3|ogg|wav|wma)$', [roIgnoreCase, roSingleLine]) then
                                        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoAudio.Picture
                                      else
                                        begin
                                          // Vídeo - avi, mkv, mov, mp4, mpeg, mpg, rm, rmvb, wmv
                                        if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(avi|mkv|mov|mp4|mpeg|mpg|rm|rmvb|wmv)$', [roIgnoreCase, roSingleLine]) then
                                        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoVideo.Picture
                                        else
                                        begin
                                              // vaBitmap - bmp, eps, gif, ico, jpeg, jpg, pic, png
                                        if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(bmp|eps|gif|ico|jpe?g|pic|png)$', [roIgnoreCase, roSingleLine]) then
                                        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoImagem.Picture
                                        else
                                                // Outros arquivos
                                        vaImagemSelecionada := DMChat.ImgCollectionItemArquivoDesconhecido.Picture;
                                        end;
                                        end;
                                    end;
                                end;
                            end;
                        end;
                    end;
                end;
            end;
        end;
    end;

  try
    vaBytesStream := TBytesStream.Create;
    vaImagemSelecionada.Graphic.SaveToStream(vaBytesStream);
    vaBytesStream.Position := 0;
    Result.Graphic := fpvImagem(vaBytesStream, TWICImageFormat.wifPng);
  finally
    if Assigned(vaBytesStream) then
      FreeAndNil(vaBytesStream);
  end;
end;

function TfrmChatTela.fpvImagem(const ipBytesStream: TBytesStream;
  const ipFormatoSecundario: TWICImageFormat): TGraphic;

  procedure plcLerImagem;
  begin
    try
      ipBytesStream.Position := 0;
      Result.LoadFromStream(ipBytesStream);
    except
      if Assigned(Result) then
        FreeAndNil(Result);
    end;
  end;

var
  vaGraphicClass: TGraphicClass;
begin
  Result := nil;
  vaGraphicClass := nil;

  if Assigned(ipBytesStream) then
    begin
      ipBytesStream.Position := 0;

      if not fpvFindGraphicClass(ipBytesStream, vaGraphicClass) then
        begin
          // Não foi possível determinar a classe da imagem, então vamos utilizar
          // a classe secundária informada e tentar ler a imagem
          case ipFormatoSecundario of
            wifBmp:
              vaGraphicClass := TBitmap;
            wifPng:
              vaGraphicClass := TPNGImage;
            wifJpeg:
              vaGraphicClass := TJPEGImage;
            wifGif:
              vaGraphicClass := TGIFImage;
          end;
        end;

      Result := TGraphicClass(vaGraphicClass).Create;
      plcLerImagem;

      // Não foi possível ler a imagem ou foi informado um tipo secundário diferente dos que estão logo acima,
      // então vamos utilizar a classe TWICImage, pois esta classe aceita vários formatos de imagens
      if not Assigned(Result) then
        begin
          Result := TWicImage.Create;
          plcLerImagem;
        end;
    end;
end;

function TfrmChatTela.fpvImagemTamanhoMaximo(const ipBytesStream: TBytesStream;
  const ipHeight, ipWidth: Integer): TGraphic;
var
  vaGraphic: TGraphic;
begin
  Result := nil;
  vaGraphic := nil;

  if Assigned(ipBytesStream) then
    begin
      try
        ipBytesStream.Position := 0;
        vaGraphic := fpvImagem(ipBytesStream, TWICImageFormat.wifJpeg);
        Result := fpvImagemTamanhoMaximo(vaGraphic, ipHeight, ipWidth);
      finally
        if Assigned(vaGraphic) then
          FreeAndNil(vaGraphic);
      end;
    end;
end;

function TfrmChatTela.fpvImagemTamanhoMaximo(const ipGraphic: TGraphic;
  const ipHeight, ipWidth: Integer): TGraphic;
var
  vaBytesStream: TBytesStream;
  vaGraphicBase, vaGraphicRedimensionado: TGraphic;
  vaGraphicClass: TGraphicClass;
  vadxSmartImage: TdxSmartImage;
  vaBitmap: TBitmap absolute vaGraphicRedimensionado;
  vaJPEGImage: TJPEGImage absolute vaGraphicRedimensionado;
begin
  Result := nil;
  vaBytesStream := nil;
  vaGraphicBase := nil;
  vaGraphicRedimensionado := nil;
  vaGraphicClass := nil;
  vadxSmartImage := nil;

  if Assigned(ipGraphic) then
    begin
      try
        Result := TGraphicClass(TJPEGImage).Create;

        if (ipGraphic.ClassType = TJPEGImage) and (ipGraphic.Height <= ipHeight) and (ipGraphic.Width <= ipWidth) then
          Result.Assign(ipGraphic)
        else
          begin
            vaBytesStream := TBytesStream.Create;
            ipGraphic.SaveToStream(vaBytesStream);
            vaBytesStream.Position := 0;

            vadxSmartImage := TdxSmartImage.Create;
            vadxSmartImage.LoadFromStream(vaBytesStream);
            vaGraphicBase := vadxSmartImage.GetAsBitmap;

            if ((vaGraphicBase.Height <= ipHeight) and (vaGraphicBase.Width <= ipWidth)) then
              Result.Assign(vaGraphicBase)
            else
              begin
                vaGraphicRedimensionado := TBitmap.Create;

                if (ipHeight / vaGraphicBase.Height) <= (ipWidth / vaGraphicBase.Width) then
                  begin
                    vaGraphicRedimensionado.Height := ipHeight;

                    if vaGraphicBase.Height = vaGraphicBase.Width then
                      vaGraphicRedimensionado.Width := vaGraphicRedimensionado.Height
                    else
                      vaGraphicRedimensionado.Width := Trunc(SimpleRoundTo(ipHeight / vaGraphicBase.Height * vaGraphicBase.Width, 0));
                  end
                else
                  begin
                    if vaGraphicBase.Height = vaGraphicBase.Width then
                      vaGraphicRedimensionado.Height := ipWidth
                    else
                      vaGraphicRedimensionado.Height := Trunc(SimpleRoundTo(ipWidth / vaGraphicBase.Width * vaGraphicBase.Height, 0));

                    vaGraphicRedimensionado.Width := ipWidth;
                  end;

                vaBitmap.Canvas.StretchDraw(vaBitmap.Canvas.ClipRect, vaGraphicBase);
                Result.Assign(vaGraphicRedimensionado);
              end;
          end;
      finally
        if Assigned(vaBytesStream) then
          FreeAndNil(vaBytesStream);

        if Assigned(vaGraphicBase) then
          FreeAndNil(vaGraphicBase);

        if Assigned(vaGraphicRedimensionado) then
          FreeAndNil(vaGraphicRedimensionado);

        if Assigned(vadxSmartImage) then
          FreeAndNil(vadxSmartImage);
      end;
    end;
end;

function TfrmChatTela.fpvMontaIdentificador(const ipCodigoUsuario,
  ipCodigoHospital: Integer): string;
begin
  Result :=
    TRegEx.Replace(IntToStr(ipCodigoUsuario), '-', 'n', [roIgnoreCase, roSingleLine]) +
    '_' +
    TRegEx.Replace(IntToStr(ipCodigoHospital), '-', 'n', [roIgnoreCase, roSingleLine]);
end;

function TfrmChatTela.fpvMouseSobreComponente(ipControl: TControl;
  ipMousePos: TPoint): Boolean;
var
  vaPosSE, vaPosID: TPoint;
begin
  vaPosSE := ipControl.ClientOrigin;
  vaPosID.X := vaPosSE.X + ipControl.Width;
  vaPosID.Y := vaPosSE.Y + ipControl.Height;
  Result := (ipMousePos.X >= vaPosSE.X) and (ipMousePos.X <= vaPosID.X) and (ipMousePos.Y >= vaPosSE.Y) and (ipMousePos.Y <= vaPosID.Y);
end;

function TfrmChatTela.fpvPesquisarConversa(const ipTipoPesquisa: TChatTipoPesquisa;
  const ipTexto: string; const ipDataInicial, ipDataFinal: TDate;
  const ipUsuarioLogado, ipUsuarioConversa: TChatIdentificacaoUsuario;
  const ipUsuarioSistema, ipCriarClientDataSet: Boolean; var ioCdsMensagem,
  ioCdsMensagemAnexo: TpmClientDataSet): Boolean;
var
  vaMensagem, vaMensagemAnexo: OleVariant;
  vaCdsMensagem: TpmClientDataSet;
  vaNomeArquivo: string;
  vaBytesStream: TBytesStream;

  vaPanel: TPanel;
  vaLabel: TLabel;
  vaGauge: TGauge;
begin
  Result := False;
  vaCdsMensagem := nil;
  vaBytesStream := nil;

  if Assigned(FAoPesquisar) then
    begin
      vaPanel := TPanel.Create(Self);
      vaPanel.Parent := Self;
      vaPanel.ShowCaption := False;
      vaPanel.Height := Self.Height;
      vaPanel.Left := 0;
      vaPanel.Top := 0;
      vaPanel.Width := Self.Width;

      vaLabel := TLabel.Create(vaPanel);
      vaLabel.Parent := vaPanel;
      vaLabel.Font.Size := 10;
      vaLabel.Font.Style := [fsBold];
      vaLabel.Caption := 'Aguarde. Pesquisando as mensagens no banco de dados';
      vaLabel.Left := Trunc((Self.Width - vaLabel.Width) / 2);
      vaLabel.Top := Trunc((Self.Height - vaLabel.Height) / 2);

      vaGauge := TGauge.Create(vaPanel);
      vaGauge.Parent := vaPanel;
      vaGauge.Height := 25;
      vaGauge.Left := vaLabel.Left;
      vaGauge.Top := vaLabel.Top + vaLabel.Height + 4;
      vaGauge.Width := vaLabel.Width;

      vaPanel.BringToFront;
      vaPanel.Refresh;

      try
        if ipCriarClientDataSet then
          begin
            ioCdsMensagem := TpmClientDataSet.Create(nil);
            ioCdsMensagem.pmAutoRefresh := False;
            ioCdsMensagem.pmApplyUpdatesAutomatico := False;
            ioCdsMensagem.pmGerarLog := False;
            ioCdsMensagem.FieldDefs.Assign(DMChat.cdsMensagem.FieldDefs);
            ioCdsMensagem.CreateDataSet;

            ioCdsMensagemAnexo := TpmClientDataSet.Create(nil);
            ioCdsMensagemAnexo.pmAutoRefresh := False;
            ioCdsMensagemAnexo.pmApplyUpdatesAutomatico := False;
            ioCdsMensagemAnexo.pmGerarLog := False;
            ioCdsMensagemAnexo.FieldDefs.Assign(DMChat.cdsMensagem_Anexo.FieldDefs);
            ioCdsMensagemAnexo.CreateDataSet;
          end;

        vaCdsMensagem := TpmClientDataSet.Create(nil);
        vaCdsMensagem.pmAutoRefresh := False;
        vaCdsMensagem.pmApplyUpdatesAutomatico := False;
        vaCdsMensagem.pmGerarLog := False;

        FAoPesquisar(ipTipoPesquisa, ipTexto, ipDataInicial, ipDataFinal, ipUsuarioLogado, ipUsuarioConversa, ipUsuarioSistema, fpvVisualizarSomenteMensagensEnviadas(ipUsuarioConversa), vaMensagem);

        try
          vaCdsMensagem.Data := vaMensagem;
          vaCdsMensagem.First;
          vaGauge.MaxValue := vaCdsMensagem.RecordCount;

          while not vaCdsMensagem.Eof do
            begin
              // Carregando as mensagens
              if not(ioCdsMensagem.State in [dsEdit, dsInsert]) then
                ioCdsMensagem.Append;

              ioCdsMensagem.FieldByName('CODIGO').AsInteger := vaCdsMensagem.FieldByName('CODIGO').AsInteger;
              ioCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsInteger := vaCdsMensagem.FieldByName('CODIGO_SENHA_DESTINATARIO').AsInteger;
              ioCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger := ipUsuarioConversa.CodigoHospital;

              if vaCdsMensagem.FieldByName('CODIGO_SENHAUS_REMETENTE').AsInteger = 0 then
                ioCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger := FCodigoUsuarioSistema
              else
                ioCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger := vaCdsMensagem.FieldByName('CODIGO_SENHAUS_REMETENTE').AsInteger;

              ioCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime := vaCdsMensagem.FieldByName('DATA_HORA_ENVIO').AsDateTime;
              ioCdsMensagem.FieldByName('MENSAGEM').AsString := vaCdsMensagem.FieldByName('TEXTO').AsString;
              ioCdsMensagem.FieldByName('TIPO_MENSAGEM').AsInteger := vaCdsMensagem.FieldByName('TIPO_MENSAGEM').AsInteger;
              ioCdsMensagem.FieldByName('MENSAGEM_LIDA').AsInteger := vaCdsMensagem.FieldByName('MENSAGEM_LIDA').AsInteger;
              ioCdsMensagem.Post;

              // Carregando os arquivos anexados nas mensagens
              if (not vaCdsMensagem.FieldByName('CODIGO_MENSAGEM_ANEXO').IsNull) then
                begin
                  if not(ioCdsMensagemAnexo.State in [dsEdit, dsInsert]) then
                    ioCdsMensagemAnexo.Append;

                  ioCdsMensagemAnexo.FieldByName('CODIGO').AsInteger := vaCdsMensagem.FieldByName('CODIGO_MENSAGEM_ANEXO').AsInteger;
                  ioCdsMensagemAnexo.FieldByName('CODIGO_MENSAGEM').AsInteger := vaCdsMensagem.FieldByName('CODIGO').AsInteger;
                  ioCdsMensagemAnexo.FieldByName('CODIGO_DESTINATARIO').AsInteger := vaCdsMensagem.FieldByName('CODIGO_SENHA_DESTINATARIO').AsInteger;
                  ioCdsMensagemAnexo.FieldByName('CODIGO_HOSPITAL').AsInteger := ipUsuarioConversa.CodigoHospital;

                  if vaCdsMensagem.FieldByName('CODIGO_SENHAUS_REMETENTE').AsInteger = 0 then
                    ioCdsMensagemAnexo.FieldByName('CODIGO_REMETENTE').AsInteger := FCodigoUsuarioSistema
                  else
                    ioCdsMensagemAnexo.FieldByName('CODIGO_REMETENTE').AsInteger := vaCdsMensagem.FieldByName('CODIGO_SENHAUS_REMETENTE').AsInteger;

                  ioCdsMensagemAnexo.FieldByName('DATAHORA_ENVIO').AsDateTime := vaCdsMensagem.FieldByName('DATA_HORA_ENVIO').AsDateTime;
                  ioCdsMensagemAnexo.FieldByName('LOCAL').AsString := vaCdsMensagem.FieldByName('ENDERECO_ANEXO').AsString;

                  vaNomeArquivo := ExtractFileName(vaCdsMensagem.FieldByName('ENDERECO_ANEXO').AsString);

                  if TRegEx.IsMatch(vaNomeArquivo, TRegEx.Escape(vaCdsMensagem.FieldByName('EXTENSAO').AsString) + '_\d{1,}\.zip$', [roIgnoreCase]) then
                    begin
                      vaNomeArquivo :=
                        TRegEx.Match(vaNomeArquivo, '.*(?=' + TRegEx.Escape(vaCdsMensagem.FieldByName('EXTENSAO').AsString) + '_' +
                        TRegEx.Match(vaNomeArquivo, '(?<=_)\d{1,}(?=\.zip)', [roIgnoreCase]).Value + '\.zip$)', [roIgnoreCase]).Value +
                        vaCdsMensagem.FieldByName('EXTENSAO').AsString;
                    end;

                  ioCdsMensagemAnexo.FieldByName('NOME').AsString := vaNomeArquivo;
                  ioCdsMensagemAnexo.FieldByName('TAMANHO_COMP').AsLargeInt := 0;
                  ioCdsMensagemAnexo.FieldByName('TAMANHO_ORIG').AsLargeInt := vaCdsMensagem.FieldByName('TAMANHO_KB').AsLargeInt;

                  if vaCdsMensagem.FieldByName('THUMBNAIL').IsNull then
                    ioCdsMensagemAnexo.FieldByName('THUMBNAIL').Clear
                  else
                    begin
                      vaBytesStream := TBytesStream.Create;

                      try
                        TBlobField(vaCdsMensagem.FieldByName('THUMBNAIL')).SaveToStream(vaBytesStream);
                        vaBytesStream.Position := 0;
                        TBlobField(ioCdsMensagemAnexo.FieldByName('THUMBNAIL')).LoadFromStream(vaBytesStream);
                      finally
                        FreeAndNil(vaBytesStream);
                      end;
                    end;

                  ioCdsMensagemAnexo.Post;
                end;

              vaGauge.Progress := vaGauge.Progress + 1;
              vaCdsMensagem.Next;
            end;

          Result := True;
        except
          on E: Exception do
            begin
              if (ioCdsMensagem.State in [dsEdit, dsInsert]) then
                ioCdsMensagem.Cancel;

              if (ioCdsMensagemAnexo.State in [dsEdit, dsInsert]) then
                ioCdsMensagemAnexo.Cancel;

              MessageTela('Falha realizar a pesquisa das mensagens.' + sLineBreak + E.Message);
            end;
        end;
      finally
        FreeAndNil(vaPanel);

        if Assigned(vaCdsMensagem) then
          begin
            vaCdsMensagem.Close;
            FreeAndNil(vaCdsMensagem);
          end;

        if Assigned(vaBytesStream) then
          FreeAndNil(vaBytesStream);
      end;
    end;
end;

function TfrmChatTela.fpvPesquisarLeitoresMensagens(
  const ipCodigoHospital: Integer; const ipCodigosMensagens: string;
  var ioLeitores: OleVariant): Boolean;
var
  vaCdsPesquisa: TpmClientDataSet;
begin
  Result := False;
  vaCdsPesquisa := nil;

  if Assigned(FAoPesquisarLeitores) then
    begin
      try
        FAoPesquisarLeitores(ipCodigoHospital, ipCodigosMensagens, ioLeitores);
        vaCdsPesquisa := TpmClientDataSet.Create(nil);
        vaCdsPesquisa.pmAutoRefresh := False;
        vaCdsPesquisa.pmApplyUpdatesAutomatico := False;
        vaCdsPesquisa.pmGerarLog := False;
        vaCdsPesquisa.Data := ioLeitores;
        Result := vaCdsPesquisa.RecordCount > 0;
      finally
        if Assigned(vaCdsPesquisa) then
          begin
            vaCdsPesquisa.Close;
            FreeAndNil(vaCdsPesquisa);
          end;
      end;
    end;
end;

function TfrmChatTela.fpvTamanhoFormatado(const ipTamanho: Int64): string;
const
  KB = 1024;
  MB = 1024 * KB;
  GB = 1024 * MB;
begin
  Result := '0B';

  if ipTamanho > 0 then
    begin
      case ipTamanho of
        0 .. (KB - 1):
          Result := FormatFloat(',0', ipTamanho) + 'B';
        KB .. (MB - 1):
          Result := FormatFloat(',0.00', ipTamanho / KB) + 'KB';
        MB .. (GB - 1):
          Result := FormatFloat(',0.00', ipTamanho / MB) + 'MB';
      else
        Result := FormatFloat(',0.00', ipTamanho / GB) + 'GB';
      end;
    end;
end;

function TfrmChatTela.fpvUsuarioLogado(const ipCodigoHospital: Integer;
  var ioUsuarioLogado: Integer): Boolean;
var
  vaUsuarioLogado: TChatUsuarioLogado;
begin
  Result := fpvUsuarioLogado(ipCodigoHospital, vaUsuarioLogado);
  ioUsuarioLogado := vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario;
end;

function TfrmChatTela.fpvUsuarioLogado(const ipCodigoHospital: Integer;
  var ioUsuarioLogado: TChatIdentificacaoUsuario): Boolean;
var
  vaUsuarioLogado: TChatUsuarioLogado;
begin
  Result := fpvUsuarioLogado(ipCodigoHospital, vaUsuarioLogado);
  ioUsuarioLogado.CodigoHospital := vaUsuarioLogado.IdentificacaoUsuario.CodigoHospital;
  ioUsuarioLogado.CodigoUsuario := vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario;
end;

function TfrmChatTela.fpvUsuarioLogado(const ipCodigoHospital: Integer;
  var ioUsuarioLogado: TChatUsuarioLogado): Boolean;
begin
  Result := FUsuarioLogado.ContainsKey(ipCodigoHospital);

  if Result then
    begin
      ioUsuarioLogado.IdentificacaoUsuario.CodigoHospital := FUsuarioLogado.Items[ipCodigoHospital].IdentificacaoUsuario.CodigoHospital;
      ioUsuarioLogado.IdentificacaoUsuario.CodigoUsuario := FUsuarioLogado.Items[ipCodigoHospital].IdentificacaoUsuario.CodigoUsuario;
      ioUsuarioLogado.EnviaMensagemGrupoTodos := FUsuarioLogado.Items[ipCodigoHospital].EnviaMensagemGrupoTodos;
    end
  else
    begin
      ioUsuarioLogado.IdentificacaoUsuario.CodigoHospital := 0;
      ioUsuarioLogado.IdentificacaoUsuario.CodigoUsuario := 0;
      ioUsuarioLogado.EnviaMensagemGrupoTodos := False;
    end;
end;

function TfrmChatTela.fpvUsuarioPertenceGrupo(const ipCodigoUsuario,
  ipCodigoGrupo, ipCodigoHospital: Integer): Boolean;
var
  vaCdsGruposUsuarios: TpmClientDataSet;
begin
  Result := False;
  vaCdsGruposUsuarios := fpvClonarClientDataSet(DMChat.cdsGrupos_Usuarios);

  try
    vaCdsGruposUsuarios.Filtered := False;
    vaCdsGruposUsuarios.Filter :=
      'codigo_grupo = ' + IntToStr(ipCodigoGrupo) + ' and ' +
      'codigo_hospital = ' + IntToStr(ipCodigoHospital) + ' and ' +
      'codigo_usuario = ' + IntToStr(ipCodigoUsuario);
    vaCdsGruposUsuarios.Filtered := True;

    // Verificando se o usuário pertence ao grupo
    Result := vaCdsGruposUsuarios.RecordCount > 0;
  finally
    vaCdsGruposUsuarios.Close;
    FreeAndNil(vaCdsGruposUsuarios);
  end;
end;

function TfrmChatTela.fpvVisualizarSomenteMensagensEnviadas(
  const ipIdentificadorConversa: string): Boolean;
begin
  Result := fpvVisualizarSomenteMensagensEnviadas(fpvCodigoUsuario(ipIdentificadorConversa), fpvCodigoHospital(ipIdentificadorConversa));
end;

function TfrmChatTela.fpvVisualizarSomenteMensagensEnviadas(
  const ipUsuarioConversa: TChatIdentificacaoUsuario): Boolean;
begin
  Result := fpvVisualizarSomenteMensagensEnviadas(ipUsuarioConversa.CodigoUsuario, ipUsuarioConversa.CodigoHospital);
end;

function TfrmChatTela.fpvVisualizarSomenteMensagensEnviadas(
  const ipCodigoUsuarioConversa, ipCodigoHospital: Integer): Boolean;
var
  vaCdsUsuarios, vaCdsGruposUsuarios: TpmClientDataSet;
  vaConversaEmGrupo: Boolean;
begin
  Result := False;

  // Zero é o grupo "Todos", então todos os usuários fazem parte dele, portanto todos podem ver todas as mensagens
  if ipCodigoUsuarioConversa <> 0 then
    begin
      vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);

      try
        vaCdsUsuarios.Filtered := False;
        vaCdsUsuarios.Filter := 'codigo = ' + IntToStr(ipCodigoUsuarioConversa) + ' and codigo_hospital = ' + IntToStr(ipCodigoHospital);
        vaCdsUsuarios.Filtered := True;
        vaConversaEmGrupo := (vaCdsUsuarios.RecordCount > 0) and (vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 1);
      finally
        vaCdsUsuarios.Close;
        FreeAndNil(vaCdsUsuarios);
      end;

      if vaConversaEmGrupo then
        begin
          vaCdsGruposUsuarios := fpvClonarClientDataSet(DMChat.cdsGrupos_Usuarios);

          try
            vaCdsGruposUsuarios.Filtered := False;
            vaCdsGruposUsuarios.Filter := 'codigo_grupo = ' + IntToStr(ipCodigoUsuarioConversa) + ' and codigo_hospital = ' + IntToStr(ipCodigoHospital) + ' and codigo_usuario = ' +
              IntToStr(FUsuarioLogado.Items[ipCodigoHospital].IdentificacaoUsuario.CodigoUsuario);
            vaCdsGruposUsuarios.Filtered := True;
            Result := vaCdsGruposUsuarios.RecordCount = 0;
          finally
            vaCdsGruposUsuarios.Close;
            FreeAndNil(vaCdsGruposUsuarios);
          end;
        end;
    end;
end;

procedure TfrmChatTela.frmFrameCapturaImg1btnConfigurarClick(Sender: TObject);
begin
  inherited;
  frmFrameCapturaImg1.Ac_ConfigurarExecute(Sender);
end;

procedure TfrmChatTela.frmFrameCapturaImg1Button2Click(Sender: TObject);
begin
  inherited;
  frmFrameCapturaImg1.Ac_CapturarExecute(Sender);
  frmFrameCapturaImg1.cap.StopCapture;
  pgcPrincipal.ActivePage := TabConfiguracao;
end;

procedure TfrmChatTela.pgcPrincipalPageChanging(Sender: TObject;
  NewPage: TcxTabSheet; var AllowChange: Boolean);
begin
  // Ativando e desativando a função arrastar e soltar arquivos de acordo com a aba selecionada
  DragAcceptFiles(Self.Handle, NewPage = tabConversa);

  if (NewPage = tabInicial) and EditPesquisaUsuario.Showing and EditPesquisaUsuario.Visible then
    EditPesquisaUsuario.SetFocus;
end;

procedure TfrmChatTela.ppuAbrirConversas(
  const ipUsuarios: TList<TChatConversa>);
var
  vaConversa: TChatConversa;
begin
  for vaConversa in ipUsuarios do
    ppvAdicionarConversa(fpvMontaIdentificador(vaConversa.IdentificacaoUsuario.CodigoUsuario, vaConversa.IdentificacaoUsuario.CodigoHospital), vaConversa.Selecionar, vaConversa.Notificar);
end;

procedure TfrmChatTela.ppuMensagensLidas(const ipCodigoUsuarioConversa,
  ipCodigoHospital: Integer; const ipCodigosMensagens: string);
var
  vaCdsPesquisa, vaCdsMensagem: TpmClientDataSet;
  vaCustomRVItemInfo: TCustomRVItemInfo;
  vaCelula: TRVTableCellData;
  vaData: OleVariant;
  i, vaCodigoMensagem, vaCodigoUsuarioLogado: Integer;
begin
  vaCdsPesquisa := nil;
  vaCdsMensagem := nil;

  if fpvUsuarioLogado(ipCodigoHospital, vaCodigoUsuarioLogado) then
    begin
      try
        if fpvPesquisarLeitoresMensagens(ipCodigoHospital, ipCodigosMensagens, vaData) then
          begin
            vaCdsPesquisa := TpmClientDataSet.Create(nil);
            vaCdsPesquisa.pmAutoRefresh := False;
            vaCdsPesquisa.pmApplyUpdatesAutomatico := False;
            vaCdsPesquisa.pmGerarLog := False;
            vaCdsPesquisa.Data := vaData;
            vaCdsPesquisa.First;
            vaCodigoMensagem := vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger - 1;

            vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);

            while not vaCdsPesquisa.Eof do
              begin
                if (vaCodigoMensagem <> vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger) and
                  (vaCdsPesquisa.FieldByName('CODIGO_SENHAUS_REMETENTE').AsInteger <> vaCodigoUsuarioLogado) then
                  begin
                    if vaCdsMensagem.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger, ipCodigoHospital]), []) and
                      (vaCdsMensagem.FieldByName('MENSAGEM_LIDA').AsInteger = 0) then
                      begin
                        if not(vaCdsMensagem.State in [dsEdit, dsInsert]) then
                          vaCdsMensagem.Edit;

                        vaCdsMensagem.FieldByName('MENSAGEM_LIDA').AsInteger := 1;
                        vaCdsMensagem.Post;

                        if Assigned(FChatPanelSelecionado) and (FChatPanelSelecionado.Identificador = fpvMontaIdentificador(ipCodigoUsuarioConversa, ipCodigoHospital)) and
                          (pgcPrincipal.ActivePage = tabConversa) then
                          begin
                            vaCelula := nil;
                            i := 0;

                            while (i < rveMensagens.ItemCount) and (vaCelula = nil) do
                              begin
                                vaCustomRVItemInfo := rveMensagens.GetItem(i);

                                if (vaCustomRVItemInfo.Tag = IntToStr(vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger) + '_' + IntToStr(ipCodigoHospital)) and (vaCustomRVItemInfo is TRVTableItemInfo) then
                                  begin
                                    vaCelula := TRVTableItemInfo(vaCustomRVItemInfo).Cells[TRVTableItemInfo(vaCustomRVItemInfo).RowCount - 1, 3];

                                    if vaCelula.ItemCount = 0 then
                                      begin
                                        ppvIncluirStatusMensagem(
                                        vaCelula,
                                        2,
                                        IntToStr(vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger) + '_' +
                                        IntToStr(ipCodigoHospital));
                                      end;
                                  end;

                                Inc(i);
                              end;
                          end;
                      end;
                  end;

                vaCodigoMensagem := vaCdsPesquisa.FieldByName('CODIGO_MENSAGEM').AsInteger;
                vaCdsPesquisa.Next;
              end;

            rveMensagens.Change;
            rveMensagens.Format;
          end;
      finally
        if Assigned(vaCdsPesquisa) then
          begin
            vaCdsPesquisa.Close;
            FreeAndNil(vaCdsPesquisa);
          end;

        if Assigned(vaCdsMensagem) then
          begin
            vaCdsMensagem.Close;
            FreeAndNil(vaCdsMensagem);
          end;
      end;
    end;
end;

procedure TfrmChatTela.ppuUsuarioLogado(Const ipIdUsuario: TChatUsuarioLogado);
var
  vaUsuarioLogado: TChatUsuarioLogado;
begin
  if DMChat.cdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([ipIdUsuario.IdentificacaoUsuario.CodigoUsuario, ipIdUsuario.IdentificacaoUsuario.CodigoHospital]), []) then
    begin
      vaUsuarioLogado.IdentificacaoUsuario.CodigoHospital := ipIdUsuario.IdentificacaoUsuario.CodigoHospital;
      vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario := ipIdUsuario.IdentificacaoUsuario.CodigoUsuario;
      vaUsuarioLogado.EnviaMensagemGrupoTodos := ipIdUsuario.EnviaMensagemGrupoTodos;
      FUsuarioLogado.AddOrSetValue(ipIdUsuario.IdentificacaoUsuario.CodigoHospital, vaUsuarioLogado);
    end
  else
    FUsuarioLogado.Remove(ipIdUsuario.IdentificacaoUsuario.CodigoHospital);

  ppvAtualizarDadosUsuarioLogado;
end;

procedure TfrmChatTela.ppvAbrirTelaPesqUsuario;
begin
  // Este código faz com que não apareça aba no dock site, pois heigth é muito pequeno, então a aba não fica visível
  dockSitePesqUsuarios.AutoSize := False;
  dockSitePesqUsuarios.Height := 1;
  dockSitePesqUsuarios.Visible := True;

  // Ativando o dock panel
  dockPanelPesqUsuarios.Visible := True;
  dockPanelPesqUsuarios.Activate;

  if (not VarIsNull(EditPesquisaUsuario.EditingText)) and (Trim(EditPesquisaUsuario.EditingText) <> '') then
    EditNomeUsuario.EditingText := EditPesquisaUsuario.EditingText;

  if not VarIsNull(EditNomeUsuario.EditValue) then
    EditNomeUsuario.SelStart := Length(EditNomeUsuario.EditingText);

  EditPesquisaUsuario.Clear;
end;

procedure TfrmChatTela.ppvAcAnexar(Sender: TObject);
begin
  DMChat.OpenDialog1.Filter := '';
  DMChat.OpenDialog1.Options := [ofHideReadOnly, ofAllowMultiSelect, ofEnableSizing];

  if DMChat.OpenDialog1.Execute then
    ppvAnexarArquivos(DMChat.OpenDialog1.Files);

  if rveMensagensEdit.Showing and rveMensagensEdit.Visible then
    rveMensagensEdit.SetFocus;
end;

procedure TfrmChatTela.ppvAcConfigCapturarImagem(Sender: TObject);
begin
  pgcPrincipal.ActivePage := tabCapturaFoto;
  frmFrameCapturaImg1.ppuIniciarCaptura(DMChat.cdsUsuarios, 'FOTO', True, False);
  frmFrameCapturaImg1.Align := alClient;
end;

procedure TfrmChatTela.ppvAcConfigGravar(Sender: TObject);
var
  vaUsuarioLogado: TDictionary<Integer, TChatUsuarioLogado>.TPairEnumerator;
begin
  // Dados do usuário
  FConfiguracao.EMail := EditConfigEMail.EditValue;
  FConfiguracao.Telefone := EditConfigTelefone.EditValue;
  FConfiguracao.Foto := imgConfigFotoUsuario.Picture;

  // Configurações de fonte
  if (not VarIsNull(cbConfigFonteNome.EditValue)) and (cbConfigFonteNome.EditValue <> '') then
    FConfiguracao.FonteNome := cbConfigFonteNome.EditValue;

  EditConfigFonteTamanho.PostEditValue;
  FConfiguracao.FonteTamanho := EditConfigFonteTamanho.EditValue;

  // Outras configurações
  FConfiguracao.NovasMensagensApenasAlerta := BoolToInt(ckbConfigNovaMensagemApenasAlerta.Checked);

  // Atulizando as configurações e gravando no banco
  fpuAtualizarConfiguracoes(FConfiguracao);
  FChatPanelSelecionado.Close;

  if Assigned(FAoSalvarConfiguracoes) then
    begin
      vaUsuarioLogado := FUsuarioLogado.GetEnumerator;

      while vaUsuarioLogado.MoveNext do
        FAoSalvarConfiguracoes(FConfiguracao, vaUsuarioLogado.Current.Value.IdentificacaoUsuario);
    end;
end;

procedure TfrmChatTela.ppvAcConfigPegarArquivoImagem(Sender: TObject);
var
  vaBytesStream: TBytesStream;
  vaGraphic: TGraphic;
begin
  vaBytesStream := nil;
  vaGraphic := nil;

  DMChat.OpenDialog1.Filter := 'Imagens|*.bmp;*.gif;*.ico;*.jpeg;*.jpg;*.png;*.tiff|BMP|*.bmp|GIF|*.gif|ICO|*.ico|JPG|*.jpeg;*.jpg|PNG|*.png|TIFF|*.tiff';
  DMChat.OpenDialog1.Options := [ofHideReadOnly, ofEnableSizing];

  if (DMChat.OpenDialog1.Execute) and FileExists(Trim(DMChat.OpenDialog1.Files.Text)) then
    begin
      try
        vaBytesStream := TBytesStream.Create;
        vaBytesStream.LoadFromFile(Trim(DMChat.OpenDialog1.Files.Text));
        vaBytesStream.Position := 0;
        vaGraphic := fpvImagemTamanhoMaximo(vaBytesStream, 256, 256);
        imgConfigFotoUsuario.Picture.Graphic := vaGraphic;
      finally
        if Assigned(vaBytesStream) then
          FreeAndNil(vaBytesStream);

        if Assigned(vaGraphic) then
          FreeAndNil(vaGraphic);
      end;
    end;
end;

procedure TfrmChatTela.ppvAcConfigRestaurar(Sender: TObject);
begin
  // Dados do usuário
  EditConfigEMail.EditValue := FConfiguracao.EMail;
  EditConfigTelefone.EditValue := FConfiguracao.Telefone;
  imgConfigFotoUsuario.Picture := FConfiguracao.Foto;

  // Configurações de fonte
  cbConfigFonteNome.EditValue := FConfiguracao.FonteNome;
  EditConfigFonteTamanho.EditValue := FConfiguracao.FonteTamanho;

  // Outras configurações
  ckbConfigNovaMensagemApenasAlerta.Enabled := FConfiguracao.PermitirAlterarAlertaMensagens;
  ckbConfigNovaMensagemApenasAlerta.Checked := FConfiguracao.PermitirAlterarAlertaMensagens and (FConfiguracao.NovasMensagensApenasAlerta = 1);
end;

procedure TfrmChatTela.ppvAcConfiguracao(Sender: TObject);
var
  vaChatPanelConversaAba: TChatPanelConversaAba;
  vaIcon: TIcon;
  vaBytesStream: TBytesStream;
  vaGraphic: TGraphic;
  vaPicture: TPicture;
  vaFontes: TStringList;
  vaFonte: string;
  vaComboBoxItem: TcxImageComboBoxItem;
  vaConfiguracao: TChatConfiguracoes;
  vaUsuarioLogado: TDictionary<Integer, TChatUsuarioLogado>.TPairEnumerator;
begin
  // Pesquisando a conversa para saber se ela está no painel de conversas ou se tem que adicioná-la
  vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.FindComponent('pnlConfiguracoes'));

  if not Assigned(vaChatPanelConversaAba) then
    begin
      // A tela de configuração ainda não existe, então vamos criá-la

      // Carregando as fontes disponíveis
      try
        vaFontes := TUtils.fpuPegarFontesComputador;
        cbConfigFonteNome.Properties.Items.Clear;

        for vaFonte in vaFontes do
          begin
            if TRegEx.IsMatch(vaFonte, '^[a-z]', [roSingleLine, roIgnoreCase]) then
              begin
                vaComboBoxItem := cbConfigFonteNome.Properties.Items.Add;
                vaComboBoxItem.Description := vaFonte;
                vaComboBoxItem.Value := vaFonte;
              end;
          end;
      finally
        if Assigned(vaFontes) then
          FreeAndNil(vaFontes);
      end;

      // Pesquisando as configurações
      if Assigned(FAoPesquisarConfiguracoes) then
        begin
          vaUsuarioLogado := FUsuarioLogado.GetEnumerator;
          vaUsuarioLogado.MoveNext;

          // Não pode dar "Free" na variável vaConfiguracao porque ela veio do server e o DataSnap já faz
          // isso, então se der "Free" vai gerar um erro
          vaConfiguracao := FAoPesquisarConfiguracoes(vaUsuarioLogado.Current.Value.IdentificacaoUsuario);

          if Assigned(vaConfiguracao) then
            begin
              FConfiguracao.EMail := vaConfiguracao.EMail;
              FConfiguracao.FonteNome := vaConfiguracao.FonteNome;
              FConfiguracao.FonteTamanho := vaConfiguracao.FonteTamanho;
              FConfiguracao.NovasMensagensApenasAlerta := vaConfiguracao.NovasMensagensApenasAlerta;
              FConfiguracao.PermitirAlterarAlertaMensagens := vaConfiguracao.PermitirAlterarAlertaMensagens;
              FConfiguracao.Telefone := vaConfiguracao.Telefone;

              vaGraphic := nil;
              vaPicture := nil;

              if Assigned(vaConfiguracao.Foto) then
                begin
                  try
                    vaGraphic := fpvImagemTamanhoMaximo(vaConfiguracao.Foto.Graphic, 256, 256);
                    vaPicture := TPicture.Create;
                    vaPicture.Graphic := vaGraphic;
                    FConfiguracao.Foto := vaPicture;
                  finally
                    if Assigned(vaGraphic) then
                      FreeAndNil(vaGraphic);

                    if Assigned(vaPicture) then
                      FreeAndNil(vaPicture);
                  end;
                end;
            end;
        end;

      // Carregando as configurações para a tela
      ppvAcConfigRestaurar(Self);

      // Criando o panel e definindo suas características. Este panel será uma a "guia do usuário" na tela
      vaChatPanelConversaAba := TChatPanelConversaAba.Create(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Align := alTop;
      vaChatPanelConversaAba.Visible := False;
      vaChatPanelConversaAba.Name := 'pnlConfiguracoes';
      vaChatPanelConversaAba.Identificador := '';
      vaChatPanelConversaAba.Parent := TWinControl(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Top := slbConversasListaUsuarios.ComponentCount * vaChatPanelConversaAba.Height;
      vaChatPanelConversaAba.Visible := True;
      vaChatPanelConversaAba.Selecionado := True;
      vaChatPanelConversaAba.OnClose := ppvFecharConversa;
      vaChatPanelConversaAba.OnChangeSelect := ppvAcConfiguracao;
      vaChatPanelConversaAba.LabelSuperior := 'Configurações';
      vaChatPanelConversaAba.TipoAba := TChatTipoAba.taConfiguracao;
      vaChatPanelConversaAba.Status := -1;
      vaChatPanelConversaAba.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

      vaIcon := TIcon.Create;
      vaBytesStream := TBytesStream.Create;
      vaGraphic := TGraphicClass(Vcl.Graphics.TIcon).Create;

      try
        DMChat.ImgListBotoes32x32.GetIcon(2, vaIcon);
        vaIcon.SaveToStream(vaBytesStream);
        vaBytesStream.Position := 0;
        vaGraphic.LoadFromStream(vaBytesStream);
        vaChatPanelConversaAba.FotoThumbnail.Graphic := vaGraphic;
      finally
        FreeAndNil(vaIcon);
        FreeAndNil(vaBytesStream);
        FreeAndNil(vaGraphic);
      end;

      // Posicionando a barra de rolagem no lugar do novo panel
      if (vaChatPanelConversaAba.Top + vaChatPanelConversaAba.Height) > slbConversasListaUsuarios.Height then
        slbConversasListaUsuarios.VertScrollBar.Position := slbConversasListaUsuarios.VertScrollBar.Range;
    end;

  // Se foi chamado pelo action, então vamos selecioná-lo, caso não esteja selecionado
  if (not vaChatPanelConversaAba.Selecionado) and (not(Sender is TChatPanel)) then
    vaChatPanelConversaAba.Selecionado := True;

  // Verificando se a tela de configuração foi selecionada
  if vaChatPanelConversaAba.Selecionado and ((not Assigned(FChatPanelSelecionado)) or (FChatPanelSelecionado <> vaChatPanelConversaAba)) then
    begin
      if Assigned(FChatPanelSelecionado) then
        FChatPanelSelecionado.Selecionado := False;

      FChatPanelSelecionado := vaChatPanelConversaAba;

      // Selecionando a aba de configurações
      pgcPrincipal.ActivePage := TabConfiguracao;

      if EditConfigEMail.Showing and EditConfigEMail.Visible then
        EditConfigEMail.SetFocus;
    end;
end;

procedure TfrmChatTela.ppvAcEnviar(Sender: TObject);
var
  vaBytesStream: TBytesStream;
  vaUsuarioLogado: TChatUsuarioLogado;
begin
  if fpvUsuarioLogado(fpvCodigoHospital(FChatPanelSelecionado.Identificador), vaUsuarioLogado) and
    (vaUsuarioLogado.IdentificacaoUsuario.CodigoHospital = FChatPanelSelecionado.Mensagem.Remetente.CodigoHospital) and
    (vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario = FChatPanelSelecionado.Mensagem.Remetente.CodigoUsuario) then
    begin
      if DMChat.cdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(FChatPanelSelecionado.Identificador), []) then
        begin
          if DMChat.cdsUsuariosCODIGO.AsInteger = FCodigoUsuarioSistema then
            begin
              MessageTela('Usuário do sistema. A mensagem não pode ser enviada.' + sLineBreak + 'Este usuário é exclusivo para recebimento de mensagens do sistema.');
              Exit;
            end
          else
            begin
              if DMChat.cdsUsuariosATIVO_INATIVO.AsInteger = 1 then
                begin
                  MessageTela('Usuário inativo. A mensagem não pode ser enviada.');
                  Exit;
                end
              else
                begin
                  if (not vaUsuarioLogado.EnviaMensagemGrupoTodos) and (DMChat.cdsUsuariosNOME.AsString = 'TODOS') then
                    begin
                      MessageTela('Usuário sem permissão para enviar mensgem para o grupo "Todos"');
                      Exit;
                    end;
                end;
            end;
        end
      else
        begin
          MessageTela('Usuário não localizado.');
          Exit;
        end;

      // Salvando a mensagem para enviá-la
      vaBytesStream := TBytesStream.Create;

      try
        rveMensagensEdit.SaveRVFToStream(vaBytesStream, False);
        FChatPanelSelecionado.Mensagem.MensagemRVF := vaBytesStream;
      finally
        FreeAndNil(vaBytesStream);
      end;

      if (FChatPanelSelecionado.Mensagem.AnexosQtde = 0) and (Trim(FChatPanelSelecionado.Mensagem.MensagemTXT) = '') then
        begin
          MessageTela('Escreva uma mensagem ou anexe algum arquivo antes de enviar.');
          rveMensagensEdit.SetFocus;
          Exit;
        end;

      // Enviando a mensagem
      try
        if Assigned(FAoEnviarMensagem) then
          FAoEnviarMensagem(FChatPanelSelecionado.Mensagem);
      except
        on E: Exception do
          MessageTela(E.Message);
      end;

      // Limpando a mensagem
      FChatPanelSelecionado.Mensagem.ppuLimparAnexos;
      FChatPanelSelecionado.Mensagem.ppuLimparMensagem;
      rveMensagensEdit.Clear;
      rveMensagensEdit.Change;
      rveMensagensEdit.Format;

      // Limpando os anexos da conversa
      while slbAnexos.ComponentCount > 0 do
        slbAnexos.Components[0].Free;

      // Fechando o panel dos anexos
      pnlConversaAnexos.Visible := False;

      // Voltando o foco para o edit da mensagem
      rveMensagensEdit.SetFocus;
    end
  else
    begin
      if (vaUsuarioLogado.IdentificacaoUsuario.CodigoHospital <> FChatPanelSelecionado.Mensagem.Remetente.CodigoHospital) or
        (vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario <> FChatPanelSelecionado.Mensagem.Remetente.CodigoUsuario) then
        MessageTela('O usuário logado está diferente do usuário remetente da mensagem.' + sLineBreak + 'A mensagem não foi enviada.')
      else
        MessageTela('O usuário logado não foi localizado.' + sLineBreak + 'A mensagem não foi enviada.');
    end;
end;

procedure TfrmChatTela.ppvAcPesquisarConversa(Sender: TObject);
var
  vaChatPanelConversaAba: TChatPanelConversaAba;
  vaIdUsuarioConversa: TChatIdentificacaoUsuario;
  vaDataInicial, vaDataFinal, vaDataTemp: TDate;
  vaCdsMensagem, vaCdsMensagem_Anexo: TpmClientDataSet;
  vaTipoPesquisa: TChatTipoPesquisa;
  vaIcon: TIcon;
  vaBytesStream: TBytesStream;
  vaGraphic: TGraphic;
begin
  // Pesquisando a conversa para saber se ela está no painel de conversas ou se tem que adicioná-la
  vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.FindComponent('pnlPesquisa'));

  if not Assigned(vaChatPanelConversaAba) then
    begin
      // Criando o panel e definindo suas características. Este panel será uma a "guia do usuário" na tela
      vaChatPanelConversaAba := TChatPanelConversaAba.Create(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Align := alTop;
      vaChatPanelConversaAba.Visible := False;
      vaChatPanelConversaAba.Name := 'pnlPesquisa';
      vaChatPanelConversaAba.Identificador := '';
      vaChatPanelConversaAba.Parent := TWinControl(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Top := slbConversasListaUsuarios.ComponentCount * vaChatPanelConversaAba.Height;
      vaChatPanelConversaAba.Visible := True;
      vaChatPanelConversaAba.Selecionado := True;
      vaChatPanelConversaAba.OnClose := ppvFecharConversa;
      vaChatPanelConversaAba.OnChangeSelect := ppvAcPesquisarConversa;
      vaChatPanelConversaAba.LabelSuperior := 'Resultado da';
      vaChatPanelConversaAba.LabelInferior := 'Pesquisa';
      vaChatPanelConversaAba.TipoAba := TChatTipoAba.taPesquisa;
      vaChatPanelConversaAba.Status := -1;
      vaChatPanelConversaAba.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

      vaIcon := TIcon.Create;
      vaBytesStream := TBytesStream.Create;
      vaGraphic := TGraphicClass(Vcl.Graphics.TIcon).Create;

      try
        DMChat.ImgListBotoes32x32.GetIcon(3, vaIcon);
        vaIcon.SaveToStream(vaBytesStream);
        vaBytesStream.Position := 0;
        vaGraphic.LoadFromStream(vaBytesStream);
        vaChatPanelConversaAba.FotoThumbnail.Graphic := vaGraphic;
      finally
        FreeAndNil(vaIcon);
        FreeAndNil(vaBytesStream);
        FreeAndNil(vaGraphic);
      end;

      // Posicionando a barra de rolagem no lugar do novo panel
      if (vaChatPanelConversaAba.Top + vaChatPanelConversaAba.Height) > slbConversasListaUsuarios.Height then
        slbConversasListaUsuarios.VertScrollBar.Position := slbConversasListaUsuarios.VertScrollBar.Range;
    end;

  // Foi chamado pelo action
  if (Sender is TAction) then
    begin
      // Se tem um panel selecionado com identificador válido, a tabConversa está selecionada e nome do panel não é pnlPesquisa,
      // então vamos carregar os dados do usuário e os parâmetros da pesquisa
      if Assigned(FChatPanelSelecionado) and TRegEx.IsMatch(FChatPanelSelecionado.Identificador, '^n?\d{1,}_n?\d{1,}$', [roIgnoreCase, roSingleLine]) and
        (pgcPrincipal.ActivePage = tabConversa) and (not TRegEx.IsMatch(FChatPanelSelecionado.Name, 'pnlPesquisa', [roIgnoreCase])) then
        begin
          vaChatPanelConversaAba.Identificador := FChatPanelSelecionado.Identificador;

          // Passando para o panel da pesquisa o remetente da mensagem, para poder pesquisar a conversa
          vaChatPanelConversaAba.Mensagem.Remetente := FChatPanelSelecionado.Mensagem.Remetente;

          // Confirmando os valores das datas da tela de conversa
          EditDataInicialConversa.PostEditValue;
          EditDataFinalConversa.PostEditValue;

          // Limpando as datas da tela de pesquisa
          EditDataInicialTabPesq.Clear;
          EditDataFinalTabPesq.Clear;

          // Passando os paramentros da pesquisa da tela de conversa para a tela de pesquisa
          EditPesquisaTabPesq.Text := EditPesquisaConversa.Text;
          EditPesquisaConversa.Text := '';

          cbxPesquisarPeriodoTabPesq.Checked := cbxPesquisarPeriodoConversa.Checked;
          cbxPesquisarPeriodoConversa.Checked := False;

          if cbxPesquisarPeriodoTabPesq.Checked then
            begin
              if not VarIsNull(EditDataInicialConversa.EditValue) then
                begin
                  EditDataInicialTabPesq.EditValue := EditDataInicialConversa.EditValue;
                  EditDataInicialTabPesq.PostEditValue;
                end;

              if not VarIsNull(EditDataFinalConversa.EditValue) then
                begin
                  EditDataFinalTabPesq.EditValue := EditDataFinalConversa.EditValue;
                  EditDataFinalTabPesq.PostEditValue;
                end;
            end;

          EditDataInicialConversa.Clear;
          EditDataFinalConversa.Clear;

          // Carregando os dados o usuário
          imgFotoTabPesquisa.Picture := FChatPanelSelecionado.FotoThumbnail;

          DMChat.cdsUsuarios.Filtered := False;
          DMChat.cdsUsuarios.Filter := '';

          if DMChat.cdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(FChatPanelSelecionado.Identificador), []) then
            begin
              lblNomeUsuarioTabPesquisa.Caption := TUtils.fpuCapitalize(DMChat.cdsUsuariosNOME.AsString);
              lblFuncaoTabPesquisa.Caption := TUtils.fpuCapitalize(DMChat.cdsUsuariosFUNCAO.AsString);
              lblFuncaoTabPesquisa.Visible := DMChat.cdsUsuariosUSUARIO_GRUPO.AsInteger = 0;

              // Ajustando o posicionamento dos labels
              if DMChat.cdsUsuariosUSUARIO_GRUPO.AsInteger = 0 then
                begin
                  // Usuário
                  lblNomeUsuarioTabPesquisa.Top := imgFotoTabPesquisa.Top;
                  lblHospitalTabPesquisa.Top := lblFuncaoTabPesquisa.Top + lblFuncaoTabPesquisa.Height - 1;
                end
              else
                begin
                  // Grupo
                  lblNomeUsuarioTabPesquisa.Top := ((imgFotoTabPesquisa.Height - 27) div 2) + imgFotoTabPesquisa.Top;
                  lblHospitalTabPesquisa.Top := lblNomeUsuarioTabPesquisa.Top + lblNomeUsuarioTabPesquisa.Height + 1;
                end;

              DMChat.cdsHospitais.Filtered := False;
              DMChat.cdsHospitais.Filter := '';

              if DMChat.cdsHospitais.Locate('codigo', fpvCodigoHospital(FChatPanelSelecionado.Identificador), []) then
                lblHospitalTabPesquisa.Caption := TUtils.fpuCapitalize(DMChat.cdsHospitaisRAZAO_SOCIAL.AsString);
            end;
        end;

      // Selecionando o panel da pesquisa
      if not vaChatPanelConversaAba.Selecionado then
        vaChatPanelConversaAba.Selecionado := True;
    end;

  // Verificando se a tela de pesquisa foi selecionada
  if vaChatPanelConversaAba.Selecionado and ((not Assigned(FChatPanelSelecionado)) or (FChatPanelSelecionado <> vaChatPanelConversaAba)) then
    begin
      if Assigned(FChatPanelSelecionado) then
        FChatPanelSelecionado.Selecionado := False;

      FChatPanelSelecionado := vaChatPanelConversaAba;

      // Selecionando a aba de configurações
      pgcPrincipal.ActivePage := TabPesquisa;
      pnlAlertaPesquisa.Visible := fpvVisualizarSomenteMensagensEnviadas(vaChatPanelConversaAba.Identificador);
    end;

  // Veio de um action e existe um identicador válido, então vamos realizar a pesquisa
  if (Sender is TAction) and TRegEx.IsMatch(vaChatPanelConversaAba.Identificador, '^n?\d{1,}_n?\d{1,}$', [roIgnoreCase, roSingleLine]) then
    begin
      if (EditPesquisaTabPesq.Text = '') and VarIsNull(EditDataInicialTabPesq.EditValue) and VarIsNull(EditDataFinalTabPesq.EditValue) then
        begin
          MessageTela('Informe um parâmetro para realizar a pesquisa.');
          EditPesquisaTabPesq.SetFocus;
          Exit;
        end;

      if VarIsNull(EditDataInicialTabPesq.EditValue) and VarIsNull(EditDataFinalTabPesq.EditValue) then
        begin
          vaDataInicial := StrToDate('01/01/1900');
          vaDataFinal := StrToDate('01/01/1900');
        end
      else
        begin
          if VarIsNull(EditDataInicialTabPesq.EditValue) or VarIsNull(EditDataFinalTabPesq.EditValue) then
            begin
              if VarIsNull(EditDataInicialTabPesq.EditValue) then
                begin
                  EditDataInicialTabPesq.EditValue := EditDataFinalTabPesq.EditValue;
                  EditDataInicialTabPesq.PostEditValue;
                end
              else
                begin
                  EditDataFinalTabPesq.EditValue := EditDataInicialTabPesq.EditValue;
                  EditDataFinalTabPesq.PostEditValue;
                end;
            end;

          if EditDataInicialTabPesq.EditValue > EditDataFinalTabPesq.EditValue then
            begin
              vaDataTemp := EditDataInicialTabPesq.EditValue;

              EditDataInicialTabPesq.EditValue := EditDataFinalTabPesq.EditValue;
              EditDataInicialTabPesq.PostEditValue;

              EditDataFinalTabPesq.EditValue := vaDataTemp;
              EditDataFinalTabPesq.PostEditValue;
            end;

          vaDataInicial := EditDataInicialTabPesq.EditValue;
          vaDataFinal := EditDataFinalTabPesq.EditValue;
        end;

      vaCdsMensagem := nil;
      vaCdsMensagem_Anexo := nil;

      try
        // Definindo o tipo da pesquisa
        if (EditPesquisaTabPesq.Text <> '') and cbxPesquisarPeriodoTabPesq.Checked then
          vaTipoPesquisa := TChatTipoPesquisa.tpqDataTexto
        else
          begin
            if cbxPesquisarPeriodoTabPesq.Checked then
              vaTipoPesquisa := TChatTipoPesquisa.tpqData
            else
              vaTipoPesquisa := TChatTipoPesquisa.tpqTexto;
          end;

        // Identificando o usuário da conversa
        vaIdUsuarioConversa.CodigoHospital := fpvCodigoHospital(vaChatPanelConversaAba.Identificador);

        if fpvCodigoUsuario(vaChatPanelConversaAba.Identificador) = FCodigoUsuarioSistema then
          vaIdUsuarioConversa.CodigoUsuario := 0
        else
          vaIdUsuarioConversa.CodigoUsuario := fpvCodigoUsuario(vaChatPanelConversaAba.Identificador);

        // Realizando a pesquisa
        if fpvPesquisarConversa(
          vaTipoPesquisa,
          EditPesquisaTabPesq.Text,
          vaDataInicial,
          vaDataFinal,
          vaChatPanelConversaAba.Mensagem.Remetente,
          vaIdUsuarioConversa,
          (fpvCodigoUsuario(vaChatPanelConversaAba.Identificador) = FCodigoUsuarioSistema),
          True,
          vaCdsMensagem,
          vaCdsMensagem_Anexo) then
          begin
            vaCdsMensagem.IndexFieldNames := 'DATAHORA_ENVIO;CODIGO';
            vaCdsMensagem_Anexo.IndexFieldNames := 'CODIGO_MENSAGEM;CODIGO_HOSPITAL;CODIGO';
            ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rvePesquisa, EditPesquisaTabPesq.Text, True, False);
            EditPesquisaTabPesq.SetFocus;
          end;
      finally
        if Assigned(vaCdsMensagem) then
          begin
            vaCdsMensagem.Close;
            FreeAndNil(vaCdsMensagem);
          end;

        if Assigned(vaCdsMensagem_Anexo) then
          begin
            vaCdsMensagem_Anexo.Close;
            FreeAndNil(vaCdsMensagem_Anexo);
          end;
      end;
    end;
end;

procedure TfrmChatTela.ppvAcSmiles(Sender: TObject);
begin
  dockSiteSmileys.AutoSize := False;
  dockSiteSmileys.Height := 1;
  dockPanelSmileys.Height := 190;
  dockSiteSmileys.Top := pnlConversaEdit.Top - dockPanelSmileys.Height - 2;
  dockSiteSmileys.Left := pnlConversaEditBotoes.Left - dockSiteSmileys.Width + bttSmiley.Width - 1;

  dockPanelSmileys.Visible := True;
  dockPanelSmileys.Activate;
end;

procedure TfrmChatTela.ppvAdicionarConversa(const ipIdentificador: string;
  const ipSelecionarConversa, ipNotificar: Boolean);
var
  vaChatPanelConversaAba: TChatPanelConversaAba;
  vaUsuarioLogado: TChatIdentificacaoUsuario;
  vaCdsHospitais, vaCdsUsuarios: TpmClientDataSet;
  vaNomeHospital: string;
begin
  // Observações:
  // A opção ipSelecionarConversa é superior a ipNotificar, ou seja, se a
  // opção ipSelecionarConversa estivar "True" a opção ipNotificar será ignorada.

  // Pesquisando a conversa para saber se ela está no painel de conversas ou se tem que adicioná-la
  vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.FindComponent('pnl' + ipIdentificador));

  if Assigned(vaChatPanelConversaAba) then
    begin
      // A conversa já existe, então vamos selecioná-la, caso tenha sido solicitado
      if ipSelecionarConversa then
        vaChatPanelConversaAba.Selecionado := True;
    end
  else
    begin
      // A conversa ainda não existe, então vamos montar todos os itens da conversa

      // Pesquisando o usuario logado de acordo com o hospital do destinatário
      if not fpvUsuarioLogado(fpvCodigoHospital(ipIdentificador), vaUsuarioLogado) then
        begin
          try
            vaCdsHospitais := fpvClonarClientDataSet(DMChat.cdsHospitais);

            if vaCdsHospitais.Locate('CODIGO', fpvCodigoHospital(ipIdentificador), []) then
              vaNomeHospital := Capitalize(vaCdsHospitais.FieldByName('RAZAO_SOCIAL').AsString)
            else
              vaNomeHospital := '(' + IntToStr(fpvCodigoHospital(ipIdentificador)) + ')';
          finally
            if Assigned(vaCdsHospitais) then
              begin
                vaCdsHospitais.Close;
                FreeAndNil(vaCdsHospitais);
              end;
          end;

          MessageTela('Não foi possível identificar o usuário logado para' + sLineBreak + 'o hospital ' + vaNomeHospital + '.');
          Exit;
        end;

      // Criando o panel e definindo suas características. Este panel será uma a "guia do usuário" na tela
      vaChatPanelConversaAba := TChatPanelConversaAba.Create(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Align := alTop;
      vaChatPanelConversaAba.Visible := False;
      vaChatPanelConversaAba.Name := 'pnl' + ipIdentificador;
      vaChatPanelConversaAba.Identificador := ipIdentificador;
      vaChatPanelConversaAba.Parent := TWinControl(slbConversasListaUsuarios);
      vaChatPanelConversaAba.Top := ((slbConversasListaUsuarios.ControlCount - 1) * vaChatPanelConversaAba.Height) + 1;
      vaChatPanelConversaAba.Visible := True;
      vaChatPanelConversaAba.OnClose := ppvFecharConversa;
      vaChatPanelConversaAba.OnChangeSelect := ppvSelecionarConversa;
      vaChatPanelConversaAba.Mensagem.AnexosLimite := 5242880; // Definindo um limite de 5MB para os anexos
      vaChatPanelConversaAba.Mensagem.AoAtingirLimiteAnexos := ppvAnexosLimiteAtingido;
      vaChatPanelConversaAba.Mensagem.TipoMensagem := 0; // Mensagem normal
      vaChatPanelConversaAba.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

      // Selecionando o tipo da conversa (usuário ou grupo)
      vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);

      try
        if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(ipIdentificador), []) and (vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 1) then
          vaChatPanelConversaAba.TipoAba := TChatTipoAba.taConversaGrupo
        else
          vaChatPanelConversaAba.TipoAba := TChatTipoAba.taConversaUsuario;
      finally
        vaCdsUsuarios.Close;
        FreeAndNil(vaCdsUsuarios);
      end;

      // Definindo o destinatário da mensagem
      vaChatPanelConversaAba.Mensagem.Destinatario.CodigoHospital := fpvCodigoHospital(ipIdentificador);
      vaChatPanelConversaAba.Mensagem.Destinatario.CodigoUsuario := fpvCodigoUsuario(ipIdentificador);

      // Definindo o remetente da mensagem
      vaChatPanelConversaAba.Mensagem.Remetente := vaUsuarioLogado;

      ppvAtualizarDadosUsuarioTela(vaChatPanelConversaAba.Identificador, vaChatPanelConversaAba);

      // A conversa será selecionada, caso tenha sido solicitado
      if ipSelecionarConversa then
        vaChatPanelConversaAba.Selecionado := True;

      // Posicionando a barra de rolagem no lugar do novo panel
      if (vaChatPanelConversaAba.Top + vaChatPanelConversaAba.Height) > slbConversasListaUsuarios.Height then
        slbConversasListaUsuarios.VertScrollBar.Position := slbConversasListaUsuarios.VertScrollBar.Range;

      // Verificando se deve ser notificada a abertura da conversa
      if (not(fpvCodigoUsuario(vaChatPanelConversaAba.Identificador) in [0, FCodigoUsuarioSistema])) then
        begin
          // Informando que a conversa está ativa
          ppvMudarStatusConversa(vaChatPanelConversaAba.Identificador, True);
        end;
    end;

  // A notificação ocorrerá se houve a solicitação e a conversa não estiver selecionada
  if ipNotificar and (vaChatPanelConversaAba <> FChatPanelSelecionado) then
    vaChatPanelConversaAba.Notificacao := True;
end;

procedure TfrmChatTela.ppvAdicionarPanelAnexo(
  const ipDadosArquivo: TChatAnexoPropriedades);
var
  vaChatPanelArquivo: TChatPanelArquivo;
begin
  pnlConversaAnexos.Visible := True;
  pnlConversaAnexos.Top := pnlConversaEdit.Top * 2;

  vaChatPanelArquivo := TChatPanelArquivo.Create(slbAnexos);
  vaChatPanelArquivo.Align := alLeft;
  vaChatPanelArquivo.Visible := False;
  vaChatPanelArquivo.Parent := slbAnexos;
  vaChatPanelArquivo.Left := slbAnexos.ControlCount * vaChatPanelArquivo.Width;
  vaChatPanelArquivo.Tag := ipDadosArquivo.id;
  vaChatPanelArquivo.LabelSuperior := ipDadosArquivo.Nome;
  vaChatPanelArquivo.LabelInferior := 'Comp.: ' + ipDadosArquivo.TamanhoFomatado + ' Desc.: ' + ipDadosArquivo.TamanhoOriginalFtd;
  vaChatPanelArquivo.Width := 220;
  vaChatPanelArquivo.OnClose := ppvDeletarAnexo;
  vaChatPanelArquivo.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

  ppvCarregarImagemArquivo(vaChatPanelArquivo, ipDadosArquivo.Extencao);
  vaChatPanelArquivo.Visible := True;
  slbAnexos.HorzScrollBar.Position := slbAnexos.HorzScrollBar.Range;
  lblAnexos.Caption := TRegEx.Replace(lblAnexos.Caption, '(?<=Tot: ).*', FormatFloat(',0.00', FChatPanelSelecionado.Mensagem.AnexosTotal / 1048576) + 'MB', [roIgnoreCase, roSingleLine]);
  lblAnexosQtde.Caption := TRegEx.Replace(lblAnexosQtde.Caption, '\d{1,}', IntToStr(FChatPanelSelecionado.Mensagem.AnexosQtde), [roIgnoreCase, roSingleLine]);
end;

procedure TfrmChatTela.ppvAdicionarSmileys(Sender: TObject);
begin
  if (Sender is TImage) and (TImage(Sender).Hint <> '') then
    begin
      rveMensagensEdit.AddTextBlockNLA(TRegEx.Split(TImage(Sender).Hint, '\r\n', [])[0], 0, -1);
      rveMensagensEdit.Change;
      rveMensagensEdit.Format;
    end;
end;

procedure TfrmChatTela.ppvAjustarImagem(const ipCdsUsuarios: TpmClientDataSet;
  const ipFoto, ipFotoThumbnail: Boolean);
  function flcCalculaLarguraAltura(const ipOldHeight, ipOldWidth, ipTamMax: Integer; var ioNewHeight, ioNewWidth: Integer): Boolean;
  begin
    Result := False;

    if (ipOldHeight > ipTamMax) or (ipOldWidth > ipTamMax) then
      begin
        Result := True;

        if ipOldHeight >= ipOldWidth then
          begin
            ioNewHeight := ipTamMax;

            if ipOldHeight = ipOldWidth then
              ioNewWidth := ioNewHeight
            else
              ioNewWidth := Trunc(SimpleRoundTo(ipTamMax / ipOldHeight * ipOldWidth, 0));
          end
        else
          begin
            ioNewHeight := Trunc(SimpleRoundTo(ipTamMax / ipOldWidth * ipOldHeight, 0));
            ioNewWidth := ipTamMax;
          end;
      end;
  end;

var
  vadxSmartImage: TdxSmartImage;
  vaImagem: TBytesStream;
  vaBitmap, vaBitmapAjustado: TBitmap;
  vaJPEGImage: TJPEGImage;
  vaNewHeight, vaNewWidth: Integer;
begin
  vadxSmartImage := nil;
  vaImagem := nil;
  vaBitmap := nil;
  vaBitmapAjustado := nil;
  vaJPEGImage := nil;

  if ipFoto then
    begin
      if (not ipCdsUsuarios.FieldByName('FOTO').IsNull) then
        begin
          // Ajustando a imagem
          try
            // Lendo a imagem do ClientDataSet
            vaImagem := TBytesStream.Create;
            TBlobField(ipCdsUsuarios.FieldByName('FOTO')).SaveToStream(vaImagem);
            vaImagem.Position := 0;

            vadxSmartImage := TdxSmartImage.Create;
            vadxSmartImage.LoadFromStream(vaImagem);
            vaBitmap := vadxSmartImage.GetAsBitmap;

            // Ajustando o tamanho da imagem
            if flcCalculaLarguraAltura(vaBitmap.Height, vaBitmap.Width, 128, vaNewHeight, vaNewWidth) then
              begin
                // Redimencionando
                vaBitmapAjustado := TBitmap.Create;
                vaBitmapAjustado.Height := vaNewHeight;
                vaBitmapAjustado.Width := vaNewWidth;
                vaBitmapAjustado.Canvas.StretchDraw(vaBitmapAjustado.Canvas.ClipRect, vaBitmap);

                // Convertentdo a imagem ajusta para JPG
                vaJPEGImage := TJPEGImage.Create;
                vaJPEGImage.Assign(vaBitmapAjustado);
                vaImagem.Clear;
                vaJPEGImage.SaveToStream(vaImagem);
                vaImagem.Position := 0;

                // Gravando a nova imagem
                if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
                  ipCdsUsuarios.Edit;

                TBlobField(ipCdsUsuarios.FieldByName('FOTO')).LoadFromStream(vaImagem);
                ipCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 0;
                ipCdsUsuarios.Post;
              end
            else
              begin
                // A imagem está dentro do tamanho máximo, não foi preciso ajustar
                if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
                  ipCdsUsuarios.Edit;

                ipCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 0;
                ipCdsUsuarios.Post;
              end;
          finally
            if Assigned(vadxSmartImage) then
              FreeAndNil(vadxSmartImage);

            if Assigned(vaBitmap) then
              FreeAndNil(vaBitmap);

            if Assigned(vaBitmapAjustado) then
              FreeAndNil(vaBitmapAjustado);

            if Assigned(vaJPEGImage) then
              FreeAndNil(vaJPEGImage);

            if Assigned(vaImagem) then
              FreeAndNil(vaImagem);
          end;
        end
      else
        begin
          // Não tem como ajustar porque o campo referente a imagem está nulo
          if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
            ipCdsUsuarios.Edit;

          ipCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger := 0;
          ipCdsUsuarios.Post;
        end;
    end;

  if ipFotoThumbnail then
    begin
      // O thumbnail está nulo, então vamos copiar da foto
      if (not ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL').IsNull) or (not ipCdsUsuarios.FieldByName('FOTO').IsNull) then
        begin
          // Copiando a imagem da foto e ajustando para o thumbnail
          try
            // Lendo a imagem do ClientDataSet
            vaImagem := TBytesStream.Create;

            if not ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL').IsNull then
              TBlobField(ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL')).SaveToStream(vaImagem)
            else
              TBlobField(ipCdsUsuarios.FieldByName('FOTO')).SaveToStream(vaImagem);

            vaImagem.Position := 0;

            vadxSmartImage := TdxSmartImage.Create;
            vadxSmartImage.LoadFromStream(vaImagem);
            vaBitmap := vadxSmartImage.GetAsBitmap;

            // Ajustando o tamanho da imagem
            if flcCalculaLarguraAltura(vaBitmap.Height, vaBitmap.Width, 32, vaNewHeight, vaNewWidth) then
              begin
                // Redimencionando
                vaBitmapAjustado := TBitmap.Create;
                vaBitmapAjustado.Height := vaNewHeight;
                vaBitmapAjustado.Width := vaNewWidth;
                vaBitmapAjustado.Canvas.StretchDraw(vaBitmapAjustado.Canvas.ClipRect, vaBitmap);

                // Convertentdo a imagem ajusta para JPG
                vaJPEGImage := TJPEGImage.Create;
                vaJPEGImage.Assign(vaBitmapAjustado);
                vaImagem.Clear;
                vaJPEGImage.SaveToStream(vaImagem);
                vaImagem.Position := 0;

                // Gravando a nova imagem
                if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
                  ipCdsUsuarios.Edit;

                TBlobField(ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL')).LoadFromStream(vaImagem);
                ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 0;
                ipCdsUsuarios.Post;
              end
            else
              begin
                // A imagem está dentro do tamanho máximo, não foi preciso ajustar
                if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
                  ipCdsUsuarios.Edit;

                ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 0;
                ipCdsUsuarios.Post;
              end;
          finally
            if Assigned(vadxSmartImage) then
              FreeAndNil(vadxSmartImage);

            if Assigned(vaBitmap) then
              FreeAndNil(vaBitmap);

            if Assigned(vaBitmapAjustado) then
              FreeAndNil(vaBitmapAjustado);

            if Assigned(vaJPEGImage) then
              FreeAndNil(vaJPEGImage);

            if Assigned(vaImagem) then
              FreeAndNil(vaImagem);
          end;
        end
      else
        begin
          // Não tem como ajustar porque os dois campos referentes a imagem estão nulos
          if not(ipCdsUsuarios.State in [dsEdit, dsInsert]) then
            ipCdsUsuarios.Edit;

          ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger := 0;
          ipCdsUsuarios.Post;
        end;
    end;
end;

procedure TfrmChatTela.ppvAnexarArquivos(ipArquivos: TStrings);
var
  vaPropriedades: TChatAnexoPropriedades;
  vaDadosAnexos: TArray<TChatAnexoPropriedades>;
begin
  if Assigned(FChatPanelSelecionado) then
    begin
      vaDadosAnexos := FChatPanelSelecionado.Mensagem.fpuAnexarArquivos(ipArquivos);

      for vaPropriedades in vaDadosAnexos do
        ppvAdicionarPanelAnexo(vaPropriedades);
    end;
end;

procedure TfrmChatTela.ppvAnexosLimiteAtingido(
  const ipArquivosRecusados: TStrings);
var
  vaArquivo, vaMensagem: string;
begin
  vaMensagem := '';

  for vaArquivo in ipArquivosRecusados do
    begin
      if vaMensagem <> '' then
        vaMensagem := vaMensagem + sLineBreak;

      vaMensagem := vaMensagem + vaArquivo;
    end;

  if vaMensagem <> '' then
    MessageTela('O arquivo possui um tamanho maior que o permitido' + sLineBreak + 'ou o limite de anexos foi atingido.' + sLineBreak + 'Os arquivos abaixo não foram anexados:' + sLineBreak + vaMensagem);
end;

procedure TfrmChatTela.ppvAtualizarDadosUsuarioLogado;
var
  vaCdsUsuarios: TpmClientDataSet;
  vaBytesStream: TBytesStream;
  vaPicture: TPicture;
  vaAjustarFoto, vaAjustarThumbnail: Boolean;
  i: Integer;
begin
  vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
  vaBytesStream := nil;
  vaPicture := nil;

  if FUsuarioLogado.Count > 0 then
    i := FUsuarioLogado.Keys.ToArray[0]
  else
    i := 0;

  try
    if (FUsuarioLogado.Count > 0) and
      (FUsuarioLogado.Items[i].IdentificacaoUsuario.CodigoUsuario <> 0) and
      (FUsuarioLogado.Items[i].IdentificacaoUsuario.CodigoHospital <> 0) and
      vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([FUsuarioLogado.Items[i].IdentificacaoUsuario.CodigoUsuario, FUsuarioLogado.Items[i].IdentificacaoUsuario.CodigoHospital]), []) then
      begin
        // Ajustando as fotos
        vaAjustarFoto := vaCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger = 1;
        vaAjustarThumbnail := vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger = 1;
        ppvAjustarImagem(vaCdsUsuarios, vaAjustarFoto, vaAjustarThumbnail);

        // Atualizando o nome do usuario
        lblNomeUsuarioLogado.Caption := TUtils.fpuCapitalize(vaCdsUsuarios.FieldByName('NOME').AsString);

        // Atualizando o status do usuário
        case vaCdsUsuarios.FieldByName('STATUS').AsInteger of
          0: // Desconectado
            begin
              lblStatusUsuarioLogado.Caption := 'Desconectado';
              spStatusUsuarioLogado.Brush.Color := clGrayText;
            end;
          1: // Conectado
            begin
              lblStatusUsuarioLogado.Caption := 'Conectado';
              spStatusUsuarioLogado.Brush.Color := clGreen;
            end;
        else // Ausente
          begin
            lblStatusUsuarioLogado.Caption := 'Ausente';
            spStatusUsuarioLogado.Brush.Color := $0001C8EB;
          end;
        end;

        // Atualizando a foto do usuário
        if not vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL').IsNull then
          begin
            vaBytesStream := TBytesStream.Create;
            TBlobField(vaCdsUsuarios.FieldByName('FOTO_THUMBNAIL')).SaveToStream(vaBytesStream);
            vaBytesStream.Position := 0;
            vaPicture := fpuRetornaImagem(vaBytesStream);

            if Assigned(vaPicture) then
              imgFotoUsuarioLogado.Picture := vaPicture
            else
              imgFotoUsuarioLogado.Picture := DMChat.ImgCollectionItemUsuario.Picture;
          end
        else
          imgFotoUsuarioLogado.Picture := DMChat.ImgCollectionItemUsuario.Picture;
      end
    else
      begin
        // Atualizando o nome do usuario
        lblNomeUsuarioLogado.Caption := '';

        // Atualizando o status do usuário
        lblStatusUsuarioLogado.Caption := 'Desconectado';
        spStatusUsuarioLogado.Brush.Color := clGrayText;

        // Atualizando a foto do usuário
        imgFotoUsuarioLogado.Picture := DMChat.ImgCollectionItemUsuario.Picture;
      end;
  finally
    if Assigned(vaPicture) then
      FreeAndNil(vaPicture);

    if Assigned(vaBytesStream) then
      FreeAndNil(vaBytesStream);

    vaCdsUsuarios.Close;
    FreeAndNil(vaCdsUsuarios);
  end;
end;

procedure TfrmChatTela.ppvAtualizarDadosUsuarioTela(
  const ipIdentificador: string; ipChatPanelConversaAba: TChatPanelConversaAba;
  const ipSomenteStatus: Boolean);

  // Este procedimento concentra as atulizações de infomações nos panels
  // O ClientDataSet passado como parâmetro, deve está posicionado no registro correto
  procedure plcAtualizarChatPanel(ipChatPanelConversa: TChatPanelConversa; const ipCdsUsuarios: TpmClientDataSet; const ipAtualizarSomenteStatus: Boolean);
  var
    vaPicture: TPicture;
    vaBytesStream: TBytesStream;
  begin
    // Atualizando o status
    ipChatPanelConversa.Status := ipCdsUsuarios.FieldByName('STATUS').AsInteger;

    // Atualizando os demais dados
    if not ipAtualizarSomenteStatus then
      begin
        ipChatPanelConversa.LabelSuperior := TUtils.fpuCapitalize(ipCdsUsuarios.FieldByName('NOME').AsString);
        ipChatPanelConversa.LabelInferior := TUtils.fpuCapitalize(ipCdsUsuarios.FieldByName('FUNCAO').AsString);

        // Antes de incluir a imagem tem ajustá-la, caso necessário
        if ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL_AJUSTAR').AsInteger = 1 then
          ppvAjustarImagem(ipCdsUsuarios, False, True);

        // Thumbnail do usuário
        if ipCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 0 then
          begin
            if not ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL').IsNull then
              begin
                vaPicture := nil;

                try
                  vaBytesStream := TBytesStream.Create;
                  TBlobField(ipCdsUsuarios.FieldByName('FOTO_THUMBNAIL')).SaveToStream(vaBytesStream);
                  vaBytesStream.Position := 0;
                  vaPicture := fpuRetornaImagem(vaBytesStream);

                  if Assigned(vaPicture) then
                    ipChatPanelConversa.FotoThumbnail.Graphic := vaPicture.Graphic
                  else
                    ipChatPanelConversa.FotoThumbnail.Assign(DMChat.ImgCollectionItemUsuario.Picture);
                finally
                  FreeAndNil(vaBytesStream);

                  if Assigned(vaPicture) then
                    FreeAndNil(vaPicture);
                end;
              end
            else
              ipChatPanelConversa.FotoThumbnail.Assign(DMChat.ImgCollectionItemUsuario.Picture);
          end
        else
          ipChatPanelConversa.FotoThumbnail.Assign(DMChat.ImgCollectionItemGrupo.Picture);
      end;
  end;

  // Este procedimento exclui todos os usuários do grupo que estão na tela
  procedure plcRemoverUsuariosGrupo;
  begin
    if Assigned(slbListaUsuariosGrupo) then
      FreeAndNil(slbListaUsuariosGrupo);

    slbListaUsuariosGrupo := TcxScrollBox.Create(Self);
    slbListaUsuariosGrupo.Parent := tabGrupo;
    slbListaUsuariosGrupo.Align := alClient;
    slbListaUsuariosGrupo.Name := 'slbListaUsuariosGrupo';
  end;

  // Este procedimento atualiza somente o panel de um usuário específico e se estiver selecionado a aba do perfil do usuário
  // O ClientDataSet passado como parâmetro, deve está posicionado no registro correto
  procedure plcAtualizarUsuario(ipChatPanelConversaAba: TChatPanelConversaAba; const ipCdsUsuarios: TpmClientDataSet; const ipAtualizarSomenteStatus: Boolean);
  var
    vaGraphic: TGraphic;
    vaBytesStream: TBytesStream;
    vaCdsHospitais: TpmClientDataSet;
  begin
    // Atualizando os dados o panel
    plcAtualizarChatPanel(ipChatPanelConversaAba, ipCdsUsuarios, ipAtualizarSomenteStatus);

    // Se a conversa está selecionada, então vamos atualizar também a aba do perfil do usuário
    if ipChatPanelConversaAba = FChatPanelSelecionado then
      begin
        tabPerfil.TabVisible := True;
        tabGrupo.TabVisible := False;
        pgcDadosConversa.ActivePage := tabPerfil;
        plcRemoverUsuariosGrupo;

        // Atualizando o status do usuário
        case ipCdsUsuarios.FieldByName('STATUS').AsInteger of
          0: // Desconectado
            begin
              lblStatus.Caption := 'Desconectado';
              spStatus.Brush.Color := clGrayText;
            end;
          1: // Conectado
            begin
              lblStatus.Caption := 'Conectado';
              spStatus.Brush.Color := clGreen;
            end;
        else // Ausente
          begin
            lblStatus.Caption := 'Ausente';
            spStatus.Brush.Color := $0001C8EB;
          end;
        end;

        // Atualizando os demais dados
        if not ipAtualizarSomenteStatus then
          begin
            // Antes de incluir a imagem tem ajustá-la, caso necessário
            if ipCdsUsuarios.FieldByName('FOTO_AJUSTAR').AsInteger = 1 then
              ppvAjustarImagem(ipCdsUsuarios, True, False);

            // Carregando a foto do perfil
            if not ipCdsUsuarios.FieldByName('FOTO').IsNull then
              begin
                vaGraphic := nil;

                try
                  vaBytesStream := TBytesStream.Create;
                  TBlobField(ipCdsUsuarios.FieldByName('FOTO')).SaveToStream(vaBytesStream);
                  vaBytesStream.Position := 0;
                  vaGraphic := fpvImagem(vaBytesStream, TWICImageFormat.wifJpeg);

                  if Assigned(vaGraphic) then
                    imgFotoUsuario.Picture.Graphic := vaGraphic
                  else
                    imgFotoUsuario.Picture := DMChat.ImgCollectionItemUsuarioPerfil.Picture;
                finally
                  FreeAndNil(vaGraphic);
                  FreeAndNil(vaBytesStream);
                end;
              end
            else
              imgFotoUsuario.Picture := DMChat.ImgCollectionItemUsuarioPerfil.Picture;

            lblNomeUsuario.Caption := TUtils.fpuCapitalize(ipCdsUsuarios.FieldByName('NOME').AsString);
            lblFuncao.Caption := TUtils.fpuCapitalize(ipCdsUsuarios.FieldByName('FUNCAO').AsString);
            lblEmail.Caption := ipCdsUsuarios.FieldByName('EMAIL').AsString;

            if ipCdsUsuarios.FieldByName('PROMEDICO').AsInteger = 1 then
              lblHospital.Caption := 'Pró-Médico'
            else
              begin
                vaCdsHospitais := fpvClonarClientDataSet(DMChat.cdsHospitais);

                try
                  if vaCdsHospitais.Locate('CODIGO', ipCdsUsuarios.FieldByName('CODIGO_HOSPITAL').AsInteger, []) then
                    lblHospital.Caption := TUtils.fpuCapitalize(vaCdsHospitais.FieldByName('RAZAO_SOCIAL').AsString)
                  else
                    lblHospital.Caption := '';
                finally
                  vaCdsHospitais.Close;
                  FreeAndNil(vaCdsHospitais);
                end;
              end;
          end;
      end;
  end;

  // Este procedimento atualiza os dados do grupo e se esitver selecionada a conversa,
  // atualiza também os dados dos integrantes do grupo
  // O ClientDataSet passado como parâmetro, deve está posicionado no registro correto
  procedure plcAtualizarGrupo(ipChatPanelConversaAba: TChatPanelConversaAba; const ipCdsUsuarios: TpmClientDataSet; const ipAtualizarSomenteStatus: Boolean);
  var
    i: Integer;
    vaChatPanelConversa: TChatPanelConversa;
    vaCdsHospitais, vaCdsGrupoUsuarios: TpmClientDataSet;
    vaUsuarioLogado: TChatIdentificacaoUsuario;
  begin
    // Atualizando o panel da conversa do grupo
    plcAtualizarChatPanel(ipChatPanelConversaAba, ipCdsUsuarios, False);

    // Se o grupo estiver selecionado, então vamos atualizar o perfil do grupo e os dados dos usuários do grupo
    if ipChatPanelConversaAba = FChatPanelSelecionado then
      begin
        // Atualizando o perfil do grupo
        tabPerfil.TabVisible := False;
        tabGrupo.TabVisible := True;
        pgcDadosConversa.ActivePage := tabGrupo;

        if not ipAtualizarSomenteStatus then
          begin
            lblNomeGrupo.Caption := TUtils.fpuCapitalize(ipCdsUsuarios.FieldByName('NOME').AsString);
            vaCdsHospitais := fpvClonarClientDataSet(DMChat.cdsHospitais);

            try
              vaCdsHospitais.Filtered := False;
              vaCdsHospitais.Filter := 'codigo = ' + ipCdsUsuarios.FieldByName('CODIGO_HOSPITAL').AsString;
              vaCdsHospitais.Filtered := True;

              lblHospitalGrupo.Caption := TUtils.fpuCapitalize(vaCdsHospitais.FieldByName('RAZAO_SOCIAL').AsString);
            finally
              vaCdsHospitais.Close;
              FreeAndNil(vaCdsHospitais);
            end;
          end;

        // Atualizando as informações dos usuários do grupo
        if ipAtualizarSomenteStatus then
          begin
            // ***************************************************
            // Atualizando somente o status dos usuáros do grupo *
            // ***************************************************

            // Percorrendo os usuários que estão sendo exibidos e atualizando somente o status
            for i := 0 to slbListaUsuariosGrupo.ComponentCount - 1 do
              begin
                if ipCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(TChatPanel(slbListaUsuariosGrupo.Components[i]).Identificador), []) then
                  plcAtualizarUsuario(TChatPanelConversaAba(slbListaUsuariosGrupo.Components[i]), ipCdsUsuarios, True);
              end;
          end
        else
          begin
            // *******************************************************
            // Atualizando todas a informações dos usuários do grupo *
            // *******************************************************

            // Removendo todos os usuários do grupo
            tabGrupo.Visible := False;
            Application.ProcessMessages;
            plcRemoverUsuariosGrupo;
            slbListaUsuariosGrupo.LockScrollBars;

            try
              // Selecionando somente os usuários do hospital referentes ao grupo
              ipCdsUsuarios.Filter := 'codigo_hospital = ' + IntToStr(fpvCodigoHospital(ipChatPanelConversaAba.Identificador)) + ' and usuario_grupo = 0';

              // Filtrando os usuários do grupo, exceto o grupo "todos", pois esse serão selecionados todos os usuários do hospital
              if fpvCodigoUsuario(ipChatPanelConversaAba.Identificador) <> 0 then
                begin
                  vaCdsGrupoUsuarios := fpvClonarClientDataSet(DMChat.cdsGrupos_Usuarios);

                  try
                    vaCdsGrupoUsuarios.Filtered := False;
                    vaCdsGrupoUsuarios.Filter :=
                      'codigo_grupo = ' + IntToStr(fpvCodigoUsuario(ipChatPanelConversaAba.Identificador)) + ' and ' +
                      'codigo_hospital = ' + IntToStr(fpvCodigoHospital(ipChatPanelConversaAba.Identificador));
                    vaCdsGrupoUsuarios.Filtered := True;
                    vaCdsGrupoUsuarios.First;

                    if vaCdsGrupoUsuarios.RecordCount > 0 then
                      begin
                        ipCdsUsuarios.Filter := ipCdsUsuarios.Filter + ' and (';

                        // Pesquisando os usuários do grupo
                        while not vaCdsGrupoUsuarios.Eof do
                          begin
                            ipCdsUsuarios.Filter := ipCdsUsuarios.Filter + ' or codigo = ' + IntToStr(vaCdsGrupoUsuarios.FieldByName('CODIGO_USUARIO').AsInteger);
                            vaCdsGrupoUsuarios.Next;
                          end;

                        ipCdsUsuarios.Filter := TRegEx.Replace(ipCdsUsuarios.Filter, '\( or ', '(', [roIgnoreCase, roSingleLine]) + ')';
                      end;
                  finally
                    vaCdsGrupoUsuarios.Close;
                    FreeAndNil(vaCdsGrupoUsuarios);
                  end;
                end;

              // Eliminando da pesquisa o usuário logado, pois não precisa mostrá-lo no grupo porque ele não irá enviar mensagem para ele mesmo
              fpvUsuarioLogado(fpvCodigoHospital(ipChatPanelConversaAba.Identificador), vaUsuarioLogado);
              ipCdsUsuarios.Filter := ipCdsUsuarios.Filter + ' and codigo <> ' + IntToStr(vaUsuarioLogado.CodigoUsuario);

              // Eliminando da pesquisa o usuário do sistema, pois este usuário é apenas para ver a mensagens recebidas do sistema
              ipCdsUsuarios.Filter := ipCdsUsuarios.Filter + ' and codigo <> ' + IntToStr(FCodigoUsuarioSistema);

              ipCdsUsuarios.DisableControls;

              // Efetuando a pesquisa
              try
                ipCdsUsuarios.IndexFieldNames := 'NOME;CODIGO;CODIGO_HOSPITAL';
                ipCdsUsuarios.Filtered := True;
                ipCdsUsuarios.First;

                // Adicionando todos os usuários do grupo
                while not ipCdsUsuarios.Eof do
                  begin
                    // Criando o panel e definindo suas características. Este panel pertence a lista de usuários do grupo
                    vaChatPanelConversa := TChatPanelConversa.Create(slbListaUsuariosGrupo);
                    vaChatPanelConversa.Align := alTop;
                    vaChatPanelConversa.Visible := False;
                    vaChatPanelConversa.Identificador := fpvMontaIdentificador(ipCdsUsuarios.FieldByName('CODIGO').AsInteger, ipCdsUsuarios.FieldByName('CODIGO_HOSPITAL').AsInteger);
                    vaChatPanelConversa.Name := 'pnl' + vaChatPanelConversa.Identificador;
                    vaChatPanelConversa.Parent := TWinControl(slbListaUsuariosGrupo);
                    vaChatPanelConversa.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

                    // Incluir o panel na última posição
                    vaChatPanelConversa.Top := slbListaUsuariosGrupo.ComponentCount * vaChatPanelConversa.Height;

                    vaChatPanelConversa.PodeFechar := False;
                    vaChatPanelConversa.Visible := True;
                    vaChatPanelConversa.OnClick := ppvSelecionarUsuarioGrupo;

                    plcAtualizarChatPanel(vaChatPanelConversa, ipCdsUsuarios, False);
                    ipCdsUsuarios.Next;
                  end;
              finally
                ipCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
                ipCdsUsuarios.Filtered := False;
                ipCdsUsuarios.Filter := '';
                ipCdsUsuarios.First;
                ipCdsUsuarios.EnableControls;
              end;
            finally
              slbListaUsuariosGrupo.UnlockScrollBars;
            end;

            tabGrupo.Visible := True;
          end;
      end;
  end;

var
  i: Integer;
  vaUsuarioPertenceAoGrupox: Boolean;
  vaCdsUsuarios: TpmClientDataSet;
  vaChatPanelConversaAba: TChatPanelConversaAba;
begin
  vaCdsUsuarios := nil;

  try
    if TRegEx.IsMatch(ipIdentificador, '^n?\d{1,}_n?\d{1,}$', [roSingleLine]) then
      begin
        // ********************************************
        // Atualizando um usuário ou grupo específico *
        // ********************************************

        // Pesquisando o panel da conversa
        if Assigned(ipChatPanelConversaAba) and (ipChatPanelConversaAba.Parent = slbConversasListaUsuarios) then
          // Se passou o panel como parâmetro, então não precisa pesquisar a conversa aberta
          vaChatPanelConversaAba := ipChatPanelConversaAba
        else
          // Pesquisando uma conversa aberta do usário
          vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.FindComponent('pnl' + ipIdentificador));

        // Se a conversa existe, então vamos atualizá-la
        if Assigned(vaChatPanelConversaAba) then
          begin
            // Clonando o ClientDataSet de usuários, caso haja alguma conversa aberta
            vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
            vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

            // Localizando o registro do usuário
            if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(ipIdentificador), []) then
              begin
                case vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger of
                  0: // Usuário específico
                    begin
                      // Atualizando os dados do usuário
                      plcAtualizarUsuario(vaChatPanelConversaAba, vaCdsUsuarios, ipSomenteStatus);

                      // Esta parte será executada, somente se não passou um TChatPanel como parâmetros.
                      // Verificando se existe uma conversa selecionada e se esta conversa é em grupo
                      if (not Assigned(ipChatPanelConversaAba)) and
                        Assigned(FChatPanelSelecionado) and
                        (FChatPanelSelecionado.TipoAba = TChatTipoAba.taConversaGrupo) and
                         // Verificando se o usuário pertence ao grupo
                        ((fpvCodigoUsuario(FChatPanelSelecionado.Identificador) = 0) or fpvUsuarioPertenceGrupo(vaCdsUsuarios.FieldByName('CODIGO').AsInteger, fpvCodigoUsuario(FChatPanelSelecionado.Identificador),
                        fpvCodigoHospital(FChatPanelSelecionado.Identificador))) then
                        begin
                          plcAtualizarGrupo(FChatPanelSelecionado, vaCdsUsuarios, ipSomenteStatus);
                        end;
                    end;
                  1: // Grupo específico
                    plcAtualizarGrupo(vaChatPanelConversaAba, vaCdsUsuarios, ipSomenteStatus);
                end;
              end;
          end;
      end
    else
      begin
        // ****************************************
        // Atualizando todas as conversas abertas *
        // ****************************************

        // Clonando o ClientDataSet de usuários, caso haja alguma conversa aberta
        if slbConversasListaUsuarios.ComponentCount > 0 then
          begin
            vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
            vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
          end;

        // Passando em todas as conversas abertas
        for i := 0 to slbConversasListaUsuarios.ComponentCount - 1 do
          begin
            vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.Components[i]);

            if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(vaChatPanelConversaAba.Identificador), []) then
              begin
                case vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger of
                  0: // Usuário
                    plcAtualizarUsuario(vaChatPanelConversaAba, vaCdsUsuarios, ipSomenteStatus);
                  1: // Grupo
                    plcAtualizarGrupo(vaChatPanelConversaAba, vaCdsUsuarios, ipSomenteStatus);
                end;
              end;
          end;
      end;
  finally
    if Assigned(vaCdsUsuarios) then
      begin
        vaCdsUsuarios.Close;
        FreeAndNil(vaCdsUsuarios);
      end;
  end;
end;

procedure TfrmChatTela.ppvCarregarAnexos(const ipChatPanelConversaAba: TChatPanelConversaAba);
var
  vaListaPropAnexos: TArray<TChatAnexoPropriedades>;
  vaPropAnexo: TChatAnexoPropriedades;
begin
  // Limpando os anexos da conversa anterior e carregando os anexos da nova conversa
  while slbAnexos.ComponentCount > 0 do
    slbAnexos.Components[0].Free;

  // Carregando os novos anexos
  vaListaPropAnexos := ipChatPanelConversaAba.Mensagem.AnexosPropriedades;
  pnlConversaAnexos.Visible := Length(vaListaPropAnexos) > 0;

  for vaPropAnexo in vaListaPropAnexos do
    ppvAdicionarPanelAnexo(vaPropAnexo);
end;

procedure TfrmChatTela.ppvCarregarArquivos(
  const ipIdentificador: string);
var
  vaChatPanelArquivo: TChatPanelArquivo;
  vaPicture: TPicture;
  vaGraphic: TGraphic;
  vaBytesStream: TBytesStream;
  vaConversaEmGrupo: Boolean;
  vaCdsUsuarios: TpmClientDataSet;
  vaUsuarioLogado: TChatIdentificacaoUsuario;
begin
  vaPicture := nil;
  vaGraphic := nil;
  vaBytesStream := nil;

  if not fpvUsuarioLogado(fpvCodigoHospital(ipIdentificador), vaUsuarioLogado) then
    begin
      MessageTela('Falha ao carregar os arquvios.' + sLineBreak + 'Não foi possível identificar o usuário logado.');
      Exit;
    end;

  vaConversaEmGrupo := fpvCodigoUsuario(ipIdentificador) = 0;

  if not vaConversaEmGrupo then
    begin
      try
        vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);

        if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(ipIdentificador), []) then
          vaConversaEmGrupo := vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 1;
      finally
        if Assigned(vaCdsUsuarios) then
          begin
            vaCdsUsuarios.Close;
            FreeAndNil(vaCdsUsuarios);
          end;
      end;
    end;

  // Removendo da listas todos os arquivos antes de incluir os novos
  while slbListaArquivos.ComponentCount > 0 do
    slbListaArquivos.Components[0].Free;

  // Filtrando os arquivos
  DMChat.cdsMensagem_Anexo.Filtered := False;

  if vaConversaEmGrupo then
    begin
      DMChat.cdsMensagem_Anexo.Filter :=
        'codigo_hospital = ' + IntToStr(fpvCodigoHospital(ipIdentificador)) + ' and ' +
        ' codigo_destinatario = ' + IntToStr(fpvCodigoUsuario(ipIdentificador));
    end
  else
    begin
      DMChat.cdsMensagem_Anexo.Filter :=
        'codigo_hospital = ' + IntToStr(fpvCodigoHospital(ipIdentificador)) + ' and ' +
        '((codigo_destinatario = ' + IntToStr(fpvCodigoUsuario(ipIdentificador)) + ' and ' +
        '  codigo_remetente = ' + IntToStr(vaUsuarioLogado.CodigoUsuario) + ') or ' +
        ' (codigo_destinatario = ' + IntToStr(vaUsuarioLogado.CodigoUsuario) + ' and ' +
        '  codigo_remetente = ' + IntToStr(fpvCodigoUsuario(ipIdentificador)) + '))';
    end;

  try
    DMChat.cdsMensagem_Anexo.Filtered := True;
    DMChat.cdsMensagem_Anexo.First;

    while not DMChat.cdsMensagem_Anexo.Eof do
      begin
        try
          // Filtrando o usuário
          DMChat.cdsUsuarios.Filtered := False;
          DMChat.cdsUsuarios.Filter := 'codigo = ' + DMChat.cdsMensagem_AnexoCODIGO_REMETENTE.AsString + ' and codigo_hospital = 0' + IntToStr(fpvCodigoHospital(ipIdentificador));
          DMChat.cdsUsuarios.Filtered := True;

          // Adicionando o panel do arquivo
          vaChatPanelArquivo := TChatPanelArquivo.Create(slbListaArquivos);
          vaChatPanelArquivo.Align := alTop;
          vaChatPanelArquivo.Visible := False;
          vaChatPanelArquivo.PodeFechar := False;
          vaChatPanelArquivo.Identificador := fpvMontaIdentificador(DMChat.cdsMensagem_AnexoCODIGO.AsInteger, DMChat.cdsMensagem_AnexoCODIGO_HOSPITAL.AsInteger);
          vaChatPanelArquivo.Name := 'pnl' + vaChatPanelArquivo.Identificador;
          vaChatPanelArquivo.Parent := TWinControl(slbListaArquivos);
          vaChatPanelArquivo.Top := ((slbConversasListaUsuarios.ControlCount - 1) * vaChatPanelArquivo.Height) + 1;
          vaChatPanelArquivo.EnderecoArquivo := DMChat.cdsMensagem_AnexoLOCAL.AsString;
          vaChatPanelArquivo.OnClick := ppvSelecionarArquivo;
          vaChatPanelArquivo.LabelSuperior := DMChat.cdsMensagem_AnexoNOME.AsString;
          vaChatPanelArquivo.LabelInferior := FormatDateTime('dd/mm/yyyy', DMChat.cdsMensagem_AnexoDATAHORA_ENVIO.AsDateTime) + ' | ' + fpvTamanhoFormatado(DMChat.cdsMensagem_AnexoTAMANHO_ORIG.AsLargeInt) + ' | ' + DMChat.cdsUsuariosNOME.AsString;
          vaChatPanelArquivo.ppuImagemBotaoFechar(DMChat.ImgListBotoes16x16, 0);

          if DMChat.cdsMensagem_AnexoTHUMBNAIL.IsNull then
            vaChatPanelArquivo.TipoArquivo := TChatTipoArquivo.taqOutros
          else
            begin
              vaChatPanelArquivo.TipoArquivo := TChatTipoArquivo.taqImagem;
              vaBytesStream := TBytesStream.Create;
              DMChat.cdsMensagem_AnexoTHUMBNAIL.SaveToStream(vaBytesStream);
              vaBytesStream.Position := 0;
              vaGraphic := fpvImagem(vaBytesStream, TWICImageFormat.wifJpeg);

              if Assigned(vaGraphic) then
                begin
                  vaPicture := TPicture.Create;
                  vaPicture.Graphic := vaGraphic;
                end;
            end;

          ppvCarregarImagemArquivo(vaChatPanelArquivo, ExtractFileExt(DMChat.cdsMensagem_AnexoNOME.AsString), vaPicture);
          vaChatPanelArquivo.Visible := True;

          if (vaChatPanelArquivo.Top + vaChatPanelArquivo.Height) > slbListaArquivos.Height then
            slbListaArquivos.VertScrollBar.Position := slbListaArquivos.VertScrollBar.Range;
        finally
          DMChat.cdsUsuarios.Filtered := False;
          DMChat.cdsUsuarios.Filter := '';

          if Assigned(vaPicture) then
            FreeAndNil(vaPicture);

          if Assigned(vaGraphic) then
            FreeAndNil(vaGraphic);

          if Assigned(vaBytesStream) then
            FreeAndNil(vaBytesStream);
        end;

        DMChat.cdsMensagem_Anexo.Next;
      end;
  finally
    DMChat.cdsMensagem_Anexo.Filtered := False;
    DMChat.cdsMensagem_Anexo.Filter := '';
  end;
end;

procedure TfrmChatTela.ppvCarregarImagemArquivo(
  ipChatPanelArquivo: TChatPanelArquivo; ipExtArquivo: string;
  ipImagem: TPicture);
var
  vaPicture: TPicture;
begin
  vaPicture := nil;

  // Incluindo o ícone de acordo com a extensão do arquivo
  if Assigned(ipImagem) and Assigned(ipImagem.Graphic) then
    ipChatPanelArquivo.FotoThumbnail := ipImagem
  else
    begin
      try
        vaPicture := fpvIconeArquivo(ipExtArquivo);
        ipChatPanelArquivo.FotoThumbnail := vaPicture;
      finally
        if Assigned(vaPicture) then
          FreeAndNil(vaPicture);
      end;
    end;
end;

procedure TfrmChatTela.ppvCarregarMensgensBancoDados(
  const ipIdentificador: string);
var
  vaCdsUsuarios, vaCdsMensagem, vaCdsMensagem_Anexo: TpmClientDataSet;
  vaIdUsuarioConversa, vaUsuarioLogado: TChatIdentificacaoUsuario;
begin
  if not fpvUsuarioLogado(fpvCodigoHospital(ipIdentificador), vaUsuarioLogado) then
    begin
      MessageTela('Falha ao pesquisar as mensagens.' + sLineBreak + 'Não foi possível identificar o usuário logado.');
      Exit;
    end;

  vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
  vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);
  vaCdsMensagem_Anexo := fpvClonarClientDataSet(DMChat.cdsMensagem_Anexo);

  vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
  vaCdsMensagem.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
  vaCdsMensagem_Anexo.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';

  vaIdUsuarioConversa.CodigoHospital := fpvCodigoHospital(ipIdentificador);

  if fpvCodigoUsuario(ipIdentificador) = FCodigoUsuarioSistema then
    vaIdUsuarioConversa.CodigoUsuario := 0
  else
    vaIdUsuarioConversa.CodigoUsuario := fpvCodigoUsuario(ipIdentificador);

  try
    if fpvPesquisarConversa(
      TChatTipoPesquisa.tpqUltimasMensagens,
      '',
      StrToDate('01/01/1900'),
      StrToDate('01/01/1900'),
      vaUsuarioLogado,
      vaIdUsuarioConversa,
      (fpvCodigoUsuario(ipIdentificador) = FCodigoUsuarioSistema),
      False,
      vaCdsMensagem,
      vaCdsMensagem_Anexo) then
      begin
        // Mensangens carregadas, então vamos desmarcar esta opção para não carregar novamente
        if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(ipIdentificador), []) then
          begin
            if not(vaCdsUsuarios.State in [dsEdit, dsInsert]) then
              vaCdsUsuarios.Edit;

            vaCdsUsuarios.FieldByName('CARREGAR_MENSAGENS').AsInteger := 0;
            vaCdsUsuarios.Post;
          end;
      end;
  finally
    if Assigned(vaCdsUsuarios) then
      begin
        vaCdsUsuarios.Close;
        FreeAndNil(vaCdsUsuarios);
      end;

    if Assigned(vaCdsMensagem) then
      begin
        vaCdsMensagem.Close;
        FreeAndNil(vaCdsMensagem);
      end;

    if Assigned(vaCdsMensagem_Anexo) then
      begin
        vaCdsMensagem_Anexo.Close;
        FreeAndNil(vaCdsMensagem_Anexo);
      end;
  end;
end;

procedure TfrmChatTela.ppvClickLink(Sender: TObject; id: Integer);
  procedure plcLink(ipTag: TRVTag; ipItemNo: Integer; ipRVFormattedData: TCustomRVFormattedData);
  var
    vaLink: string;
  begin
    // O usuário está abrindo um link

    ipRVFormattedData.GetTextInfo(ipItemNo, vaLink, ipTag);

    if TRegEx.IsMatch(ipTag, 'e-mail', [roIgnoreCase, roSingleLine]) then
      vaLink := 'mailto:' + vaLink;

    ShellExecute(Application.Handle, '', PChar(vaLink), '', '', SW_SHOWNORMAL);
  end;

  procedure plcLeitoresMensagem(const ipTag: string);
    procedure plcCarragarLeitoresMensagem(const ipNome, ipNomePC: string; ipDataHora: TDateTime; const ipPosicao: Integer; const ipWinControl: TWinControl);
    var
      vaLabelNome, vaLabelNomePC, vaLabelDataHora, vaLabelCabecalhoNome, vaLabelCabecalhoNomePC, vaLabelCabecalhoDataHora: TLabel;
      vaShape: TShape;
    begin
      if ipPosicao = 1 then
        begin
          // Criando e posicionando os labels do cabeçalho

          // Nome
          vaLabelCabecalhoNome := TLabel.Create(ipWinControl);
          vaLabelCabecalhoNome.Parent := ipWinControl;
          vaLabelCabecalhoNome.Name := 'lblCabecalhoNome';
          vaLabelCabecalhoNome.AutoSize := False;
          vaLabelCabecalhoNome.Font.Style := [fsBold];
          vaLabelCabecalhoNome.Caption := 'Nome do Leitor';
          vaLabelCabecalhoNome.Left := 4;
          vaLabelCabecalhoNome.Top := 4;
          vaLabelCabecalhoNome.Width := 170;

          // Data e hora
          vaLabelCabecalhoDataHora := TLabel.Create(ipWinControl);
          vaLabelCabecalhoDataHora.Parent := ipWinControl;
          vaLabelCabecalhoDataHora.Name := 'lblCabecalhoDataHora';
          vaLabelCabecalhoDataHora.AutoSize := False;
          vaLabelCabecalhoDataHora.Font.Style := [fsBold];
          vaLabelCabecalhoDataHora.Alignment := TAlignment.taCenter;
          vaLabelCabecalhoDataHora.Caption := 'Data e Hora';
          vaLabelCabecalhoDataHora.Left := vaLabelCabecalhoNome.Left + vaLabelCabecalhoNome.Width + 8;
          vaLabelCabecalhoDataHora.Top := vaLabelCabecalhoNome.Top;
          vaLabelCabecalhoDataHora.Width := 90;

          // Nome do computador
          vaLabelCabecalhoNomePC := TLabel.Create(ipWinControl);
          vaLabelCabecalhoNomePC.Parent := ipWinControl;
          vaLabelCabecalhoNomePC.Name := 'lblCabecalhoNomePC';
          vaLabelCabecalhoNomePC.AutoSize := False;
          vaLabelCabecalhoNomePC.Font.Style := [fsBold];
          vaLabelCabecalhoNomePC.Caption := 'Nome do Computador';
          vaLabelCabecalhoNomePC.Left := vaLabelCabecalhoDataHora.Left + vaLabelCabecalhoDataHora.Width + 8;
          vaLabelCabecalhoNomePC.Top := vaLabelCabecalhoDataHora.Top;
          vaLabelCabecalhoNomePC.Width := 170;
        end;

      // Criando e posicionando o label do nome
      vaLabelNome := TLabel.Create(ipWinControl);
      vaLabelNome.Parent := ipWinControl;
      vaLabelNome.Name := 'lblNome' + IntToStr(ipPosicao);
      vaLabelNome.AutoSize := False;
      vaLabelNome.Caption := ipNome;
      vaLabelNome.Left := 4;
      vaLabelNome.Top := (vaLabelNome.Height * ipPosicao) + 4;
      vaLabelNome.Width := 170;

      // Criando e posicionando o label da data e hora
      vaLabelDataHora := TLabel.Create(ipWinControl);
      vaLabelDataHora.Parent := ipWinControl;
      vaLabelDataHora.Name := 'lblDataHora' + IntToStr(ipPosicao);
      vaLabelDataHora.AutoSize := False;
      vaLabelDataHora.Alignment := TAlignment.taCenter;
      vaLabelDataHora.Caption := FormatDateTime('dd/mm/yyyy hh:mm', ipDataHora);
      vaLabelDataHora.Left := vaLabelNome.Left + vaLabelNome.Width + 8;
      vaLabelDataHora.Top := vaLabelNome.Top;
      vaLabelDataHora.Width := 90;

      // Criando e posicionando o label do nome do computador
      vaLabelNomePC := TLabel.Create(ipWinControl);
      vaLabelNomePC.Parent := ipWinControl;
      vaLabelNomePC.Name := 'lblNomePC' + IntToStr(ipPosicao);
      vaLabelNomePC.AutoSize := False;
      vaLabelNomePC.Caption := ipNomePC;
      vaLabelNomePC.Left := vaLabelDataHora.Left + vaLabelDataHora.Width + 8;
      vaLabelNomePC.Top := vaLabelDataHora.Top;
      vaLabelNomePC.Width := 170;

      // Criando e posicionando uma linha para diferenciar um registro do outro
      if (ipPosicao mod 2) = 0 then
        begin
          vaShape := TShape.Create(ipWinControl);
          vaShape.Parent := ipWinControl;
          vaShape.Name := 'shpCorLinha' + IntToStr(ipPosicao);
          vaShape.SendToBack;
          vaShape.Pen.Style := TPenStyle.psClear;
          vaShape.Brush.Color := clSilver;
          vaShape.Anchors := [akLeft, akTop, akRight];
          vaShape.Left := 0;
          vaShape.Width := Parent.Width;
          vaShape.Height := vaLabelNome.Height;
          vaShape.Top := vaLabelNome.Top;
        end;
    end;

  var
    vaForm: TForm;
    vaScrollBox: TcxScrollBox;
    vaPanel: TPanel;
    vaButton: TButton;
    vaCdsMensagemLeitores: TpmClientDataSet;
    vaData: OleVariant;
  begin
    // O usuário está vendo quem leu a mensagem
    vaForm := nil;
    vaCdsMensagemLeitores := nil;

    try
      Application.CreateForm(TForm, vaForm);
      vaForm.BorderStyle := bsDialog;
      vaForm.Position := poScreenCenter;
      vaForm.Caption := 'Mensagem Lida Por';
      vaForm.Width := 454;
      vaForm.Height := 205;
      vaForm.KeyPreview := True;
      vaForm.OnKeyDown := ppvFecharTelaVisualizacoesMensagem;
      vaForm.OnMouseWheelDown := ppvTelaVisualizacoesMensagemMouseWeelDown;
      vaForm.OnMouseWheelUp := ppvTelaVisualizacoesMensagemMouseWeelUp;

      vaPanel := TPanel.Create(vaForm);
      vaPanel.Parent := vaForm;
      vaPanel.Align := alBottom;
      vaPanel.BevelOuter := bvNone;

      vaButton := TButton.Create(vaForm);
      vaButton.Parent := vaPanel;
      vaButton.Caption := 'Ok';
      vaButton.Left := (vaForm.Width - vaButton.Width) div 2;
      vaButton.Top := (vaPanel.Height - vaButton.Height) div 2;
      vaButton.OnClick := ppvFecharTelaVisualizacoesMensagem;

      vaScrollBox := TcxScrollBox.Create(vaForm);
      vaScrollBox.Parent := vaForm;
      vaScrollBox.Name := 'sbxListaNomes';
      vaScrollBox.Align := alClient;
      vaScrollBox.HorzScrollBar.Visible := False;
      vaScrollBox.Color := clWhite;
      vaScrollBox.BorderStyle := cxcbsNone;
      vaScrollBox.VertScrollBar.Increment := 13;

      // Pesquisando os usuários que leram a mensagem
      if fpvPesquisarLeitoresMensagens(StrToInt(TRegEx.Match(ipTag, '(?<=_)\d{1,}$', [roIgnoreCase]).Value), TRegEx.Match(ipTag, '(?<=status)\d{1,}(?=_)', [roIgnoreCase]).Value, vaData) then
        begin
          vaCdsMensagemLeitores := TpmClientDataSet.Create(nil);
          vaCdsMensagemLeitores.pmAutoRefresh := False;
          vaCdsMensagemLeitores.pmApplyUpdatesAutomatico := False;
          vaCdsMensagemLeitores.pmGerarLog := False;
          vaCdsMensagemLeitores.Data := vaData;
          vaCdsMensagemLeitores.First;

          while not vaCdsMensagemLeitores.Eof do
            begin
              plcCarragarLeitoresMensagem(
                Capitalize(vaCdsMensagemLeitores.FieldByName('NOME_LEITOR').AsString),
                vaCdsMensagemLeitores.FieldByName('NOME_PC').AsString,
                vaCdsMensagemLeitores.FieldByName('DATA_HORA').AsDateTime,
                vaCdsMensagemLeitores.RecNo,
                vaScrollBox);

              vaCdsMensagemLeitores.Next;
            end;
        end;

      vaForm.ShowModal;
    finally
      if Assigned(vaForm) then
        FreeAndNil(vaForm);

      if Assigned(vaCdsMensagemLeitores) then
        begin
          vaCdsMensagemLeitores.Close;
          FreeAndNil(vaCdsMensagemLeitores);
        end;
    end;
  end;

  procedure plcPesquisar(const ipTag: string);
  var
    vaIdUsuarioConversa, vaUsuarioLogado: TChatIdentificacaoUsuario;
    vaUsuarioSistema: Boolean;
    vaCdsMensagem, vaCdsMensagem_Anexo: TpmClientDataSet;
  begin
    // O usuário está pesquisando a continuidade de uma conversa

    vaCdsMensagem := nil;
    vaCdsMensagem_Anexo := nil;

    try
      vaIdUsuarioConversa.CodigoHospital := fpvCodigoHospital(TRegEx.Match(ipTag, '(?<=#idUserConversa).*?(?=#DestacarTexto)', [roIgnoreCase]).Value);
      vaUsuarioSistema := fpvCodigoUsuario(TRegEx.Match(ipTag, '(?<=#idUserConversa).*?(?=#DestacarTexto)', [roIgnoreCase]).Value) = FCodigoUsuarioSistema;
      fpvUsuarioLogado(vaIdUsuarioConversa.CodigoHospital, vaUsuarioLogado);

      if vaUsuarioSistema then
        vaIdUsuarioConversa.CodigoUsuario := 0
      else
        vaIdUsuarioConversa.CodigoUsuario := fpvCodigoUsuario(TRegEx.Match(ipTag, '(?<=#idUserConversa).*?(?=#DestacarTexto)', [roIgnoreCase]).Value);

      if fpvPesquisarConversa(
        TChatTipoPesquisa.tpqCodigoMesagensProximas,
        TRegEx.Match(ipTag, '(?<=#CodMsg)\d{1,}', [roIgnoreCase]).Value,
        StrToDate('01/01/1900'),
        StrToDate('01/01/1900'),
        vaUsuarioLogado,
        vaIdUsuarioConversa,
        vaUsuarioSistema,
        True,
        vaCdsMensagem,
        vaCdsMensagem_Anexo) then
        begin
          vaCdsMensagem.IndexFieldNames := 'datahora_envio;codigo';
          ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagem_Anexo, rvePesquisa, TRegEx.Match(ipTag, '(?<=#idUserConversa).*', [roIgnoreCase]).Value, False, False);
          EditPesquisaTabPesq.SetFocus;
        end;
    finally
      if Assigned(vaCdsMensagem) then
        begin
          vaCdsMensagem.Close;
          FreeAndNil(vaCdsMensagem);
        end;

      if Assigned(vaCdsMensagem_Anexo) then
        begin
          vaCdsMensagem_Anexo.Close;
          FreeAndNil(vaCdsMensagem_Anexo);
        end;
    end;
  end;

  procedure plcArquivo(const ipTag: string);
  var
    vaLocalArquivo: string;
    vaCodigoHospital: Integer;
  begin
    vaCodigoHospital := StrToInt(TRegEx.Match(ipTag, '((?<=arquivoDownload)|(?<=arquivoVisualizar))\d{1,}(?=_)', [roIgnoreCase]).Value);
    vaLocalArquivo := TRegEx.Match(ipTag, '((?<=arquivoDownload' + IntToStr(vaCodigoHospital) + '_)|(?<=arquivoVisualizar' + IntToStr(vaCodigoHospital) + '_)).*', [roIgnoreCase]).Value;

    if TRegEx.IsMatch(ipTag, '^arquivoDownload', [roIgnoreCase]) then
      ppvSalvarArquivo(vaCodigoHospital, vaLocalArquivo)
    else
      ppvVisualizarArquivo(vaCodigoHospital, vaLocalArquivo);
  end;

var
  vaRVE: TRichViewEdit absolute Sender;
  vaRVFormattedData: TCustomRVFormattedData;
  vaCustomRVItemInfo: TCustomRVItemInfo;
  vaItemNo: Integer;
  vaTag: TRVTag;
begin
  if (Sender is TRichViewEdit) then
    begin
      vaRVE.GetJumpPointLocation(id, vaRVFormattedData, vaItemNo);
      vaCustomRVItemInfo := vaRVFormattedData.GetItem(vaItemNo);
      vaTag := vaCustomRVItemInfo.Tag;

      if TRegEx.IsMatch(vaTag, '^(e-mail|link)', [roIgnoreCase, roSingleLine]) then
        plcLink(vaTag, vaItemNo, vaRVFormattedData)
      else
        begin
          if TRegEx.IsMatch(vaTag, '^status', [roIgnoreCase, roSingleLine]) then
            plcLeitoresMensagem(vaTag)
          else
            begin
              if TRegEx.IsMatch(vaTag, '^pesquisar', [roIgnoreCase]) then
                plcPesquisar(vaTag)
              else
                begin
                  if TRegEx.IsMatch(vaTag, '^arquivo', [roIgnoreCase]) then
                    plcArquivo(vaTag);
                end;
            end;
        end;
    end;
end;

procedure TfrmChatTela.ppvConfigFonteAtualizarVisualizacao;
begin
  if (not VarIsNull(cbConfigFonteNome.EditValue)) and (cbConfigFonteNome.EditValue <> '') then
    begin
      lblConfigFonteVisualizacao.Style.Font.Name := cbConfigFonteNome.EditValue;
      lblConfigFonteVisualizacao.Caption := cbConfigFonteNome.EditValue;
    end;

  lblConfigFonteVisualizacao.Style.Font.Size := StrToIntDef(EditConfigFonteTamanho.EditingText, 8);
end;

procedure TfrmChatTela.ppvDeletarAnexo(Sender: TObject);
begin
  if (Sender is TChatPanel) and Assigned(FChatPanelSelecionado) and (TChatPanel(Sender).Parent = slbAnexos) then
    begin
      FChatPanelSelecionado.Mensagem.fpuDeletarAnexo(TChatPanel(Sender).Tag);
      lblAnexos.Caption := TRegEx.Replace(lblAnexos.Caption, '(?<=Tot: ).*', FormatFloat(',0.00', FChatPanelSelecionado.Mensagem.AnexosTotal / 1048576) + 'MB', [roIgnoreCase, roSingleLine]);
      lblAnexosQtde.Caption := TRegEx.Replace(lblAnexosQtde.Caption, '\d{1,}', IntToStr(FChatPanelSelecionado.Mensagem.AnexosQtde), [roIgnoreCase, roSingleLine]);
      pnlConversaAnexos.Visible := FChatPanelSelecionado.Mensagem.AnexosQtde > 0;
    end;
end;

procedure TfrmChatTela.ppvDescompactarArquivo(const ipArquivo: TBytesStream;
  const ipDestinoArquivo: string);
var
  vaBytesStream: TBytesStream;
begin
  if Assigned(ipArquivo) then
    begin
      try
        ppvDescompactarArquivo(ipArquivo, vaBytesStream);
        vaBytesStream.SaveToFile(ipDestinoArquivo);
      finally
        if Assigned(vaBytesStream) then
          FreeAndNil(vaBytesStream);
      end;
    end;
end;

procedure TfrmChatTela.ppvDescompactarArquivo(const ipArquivo: TBytesStream;
  var ioArquivoDescompactado: TBytesStream);
  function ExtractTempDir: String;
  var
    vaBuffer: array [0 .. 144] of Char;
  begin
    GetTempPath(144, vaBuffer);
    Result := IncludeTrailingPathDelimiter(StrPas(vaBuffer));
  end;

  function DescompactarArquivo(ipPastaDestino: string): string;
  var
    vaZip: TZipFile;
  begin
    vaZip := TZipFile.Create;
    Result := '';

    try
      vaZip.Open(ipArquivo, zmRead);
      vaZip.ExtractAll(IncludeTrailingPathDelimiter(ipPastaDestino)); // Local onde o arquivo será descompactado
      Result := vaZip.FileName[0];
    finally
      FreeAndNil(vaZip);
    end;
  end;

var
  vaPastaTemp, vaNomeArquivo: string;
begin
  ioArquivoDescompactado := TBytesStream.Create;

  try
    vaPastaTemp := ExtractTempDir + 'ProMedicoArquivosTemp';
    vaNomeArquivo := DescompactarArquivo(vaPastaTemp);
    ioArquivoDescompactado.LoadFromFile(IncludeTrailingPathDelimiter(vaPastaTemp) + vaNomeArquivo);
    DeleteFile(IncludeTrailingPathDelimiter(vaPastaTemp) + vaNomeArquivo);
  except
    on E: Exception do
      begin
        if Assigned(ioArquivoDescompactado) then
          FreeAndNil(ioArquivoDescompactado);

        MessageTela('Falha ao descompactar o arquivo.' + sLineBreak + E.Message);
      end;
  end;
end;

procedure TfrmChatTela.ppvFecharConversa(Sender: TObject);
var
  i: Integer;
  vaChatPanelConversaAba: TChatPanelConversaAba absolute Sender;
begin
  if Sender is TChatPanelConversaAba then
    begin
      if vaChatPanelConversaAba = FChatPanelSelecionado then
        begin
          i := 0;

          while (i < slbConversasListaUsuarios.ComponentCount) and (vaChatPanelConversaAba.Name <> slbConversasListaUsuarios.Components[i].Name) do
            Inc(i);

          if i < (slbConversasListaUsuarios.ComponentCount - 1) then
            TChatPanelConversaAba(slbConversasListaUsuarios.Components[i + 1]).Selecionado := True
          else
            begin
              if i > 0 then
                TChatPanelConversaAba(slbConversasListaUsuarios.Components[i - 1]).Selecionado := True
              else
                begin
                  FChatPanelSelecionado := nil;
                  pgcPrincipal.ActivePage := tabInicial;
                end;
            end;
        end;

      // Se a aba (panel) que foi fechada é uma conversa e não se refere ao usuário do sistema e nem ao grupo
      // "Todos",  então tem informar que a conversa foi fechada para não abrí-la automaticamente quando o
      // chat for aberto futuramente
      if (vaChatPanelConversaAba.TipoAba in [TChatTipoAba.taConversaGrupo, TChatTipoAba.taConversaUsuario]) and
        (not(fpvCodigoUsuario(vaChatPanelConversaAba.Identificador) in [0, FCodigoUsuarioSistema])) then
        begin
          // Informando que o panel foi fechado (Conversa inativa)
          ppvMudarStatusConversa(vaChatPanelConversaAba.Identificador, False);
        end;
    end;
end;

procedure TfrmChatTela.ppvFecharTelaVisualizacoesMensagem(Sender: TObject;
  var Key: Word; Shift: TShiftState);
begin
  if (Key = VK_ESCAPE) and (Sender is TForm) then
    TForm(Sender).Close;
end;

procedure TfrmChatTela.ppvIncluirStatusMensagem(ipCelula: TRVTableCellData;
  const ipParagrafo: Integer; const ipCodigoLeitura: string);
var
  vaGraphic: TGraphic;
  vaPicture: TPicture;
begin
  vaPicture := DMChat.ImgCollectionItemStatusMensagemLida.Picture;

  if Assigned(vaPicture) then
    begin
      vaGraphic := TGraphicClass(vaPicture.Graphic.ClassType).Create;
      vaGraphic.Assign(vaPicture.Graphic);
      ipCelula.AddHotPictureTag('', vaGraphic, ipParagrafo, rvvaMiddle, 'status' + ipCodigoLeitura);
    end;
end;

procedure TfrmChatTela.ppvInformarMensagensLidas(const ipIdentificador: string);
var
  vaCodigoHospital, vaCodigoUsuario: Integer;
  vaCdsUsuario, vaCdsMensagem: TpmClientDataSet;
  vaUsuarioLogado: TChatIdentificacaoUsuario;
  vaMensagensLidas: string;
begin
  vaCodigoHospital := fpvCodigoHospital(ipIdentificador);
  vaCodigoUsuario := fpvCodigoUsuario(ipIdentificador);

  if not fpvUsuarioLogado(vaCodigoHospital, vaUsuarioLogado) then
    begin
      MessageTela('Usuário logado não encontrado.');
      Exit;
    end;

  vaCdsUsuario := nil;
  vaCdsMensagem := nil;

  try
    vaCdsUsuario := fpvClonarClientDataSet(DMChat.cdsUsuarios);
    vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);

    vaCdsUsuario.Filter := 'CODIGO = ' + IntToStr(vaCodigoUsuario) + ' AND CODIGO_HOSPITAL = ' + IntToStr(vaCodigoHospital);
    vaCdsUsuario.Filtered := True;

    if vaCdsUsuario.RecordCount = 1 then
      begin
        if vaCdsUsuario.FieldByName('USUARIO_GRUPO').AsInteger = 1 then
          vaCdsMensagem.Filter := 'CODIGO_DESTINATARIO = ' + IntToStr(vaCodigoUsuario) + ' AND CODIGO_HOSPITAL = ' + IntToStr(vaCodigoHospital) + ' AND MENSAGEM_LIDA = 0'
        else
          vaCdsMensagem.Filter := 'CODIGO_REMETENTE = ' + IntToStr(vaCodigoUsuario) + ' AND CODIGO_DESTINATARIO = ' + IntToStr(vaUsuarioLogado.CodigoUsuario) + ' AND CODIGO_HOSPITAL = ' + IntToStr(vaCodigoHospital) + ' AND MENSAGEM_LIDA = 0';

        vaCdsMensagem.Filtered := True;
        vaCdsMensagem.First;
        vaMensagensLidas := '';

        while not vaCdsMensagem.Eof do
          begin
            vaMensagensLidas := vaMensagensLidas + ';' + IntToStr(vaCdsMensagem.FieldByName('CODIGO').AsInteger);
            vaCdsMensagem.Next;
          end;

        vaMensagensLidas := Copy(vaMensagensLidas, 2);

        if Assigned(FAoConfirmarLeituraMensagens) and (vaMensagensLidas <> '') then
          FAoConfirmarLeituraMensagens(vaUsuarioLogado, vaMensagensLidas);
      end;
  finally
    if Assigned(vaCdsUsuario) then
      begin
        vaCdsUsuario.Close;
        FreeAndNil(vaCdsUsuario);
      end;

    if Assigned(vaCdsMensagem) then
      begin
        vaCdsMensagem.Close;
        FreeAndNil(vaCdsMensagem);
      end;
  end;

  if vaMensagensLidas <> '' then
    ppuMensagensLidas(vaCodigoUsuario, vaCodigoHospital, vaMensagensLidas);
end;

procedure TfrmChatTela.ppvMudarStatusConversa(const ipIdentificador: string;
  const ipConversaAtiva: Boolean);
var
  vaUsuarioLoagado, vaUsuarioConversa: TChatIdentificacaoUsuario;
begin
  vaUsuarioConversa.CodigoUsuario := fpvCodigoUsuario(ipIdentificador);

  if Assigned(FAoMudarStatusConversa) and (vaUsuarioConversa.CodigoUsuario <> FCodigoUsuarioSistema) then
    begin
      vaUsuarioConversa.CodigoHospital := fpvCodigoHospital(ipIdentificador);

      vaUsuarioLoagado.CodigoHospital := vaUsuarioConversa.CodigoHospital;
      vaUsuarioLoagado.CodigoUsuario := FUsuarioLogado.Items[vaUsuarioConversa.CodigoHospital].IdentificacaoUsuario.CodigoUsuario;

      FAoMudarStatusConversa(vaUsuarioLoagado, vaUsuarioConversa, ipConversaAtiva);
    end;
end;

procedure TfrmChatTela.ppvFecharTelaVisualizacoesMensagem(Sender: TObject);
begin
  if (Sender is TButton) and (TButton(Sender).Owner is TForm) then
    TForm(TButton(Sender).Owner).Close;
end;

procedure TfrmChatTela.ppvPegarArquivoArrastato(var Msg: TMessage);
var
  i, FileCount, BufferSize: Word;
  Drop: HDROP;
  FileName: string;
  vaArquivos: TStringList;
begin
  // Pega o manipulador (handle) da operação "arrastar e soltar" (drag-and-drop)
  if Msg.Msg = WM_DROPFILES then
    begin
      Drop := Msg.wParam;
      FileCount := DragQueryFile(Drop, $FFFFFFFF, nil, 0); // Pega a quantidade de arquivos soltos (dropped)

      if FileCount = 0 then
        begin
          MessageTela('Nenhum arquivo selecinado.');
          Exit;
        end;

      try
        // Anexando os arquivos
        vaArquivos := TStringList.Create;

        for i := 0 to FileCount - 1 do // Pega todos os nomes de arquivos e Adiciona-os na lista
          begin
            BufferSize := DragQueryFile(Drop, i, nil, 0); // Obtém o comprimento necessário para o nome do arquivo, sem contar o caractere nulo do fim da string
            SetLength(FileName, BufferSize + 1); // O +1 é p/ nulo do fim da string

            if DragQueryFile(Drop, i, PChar(FileName), BufferSize + 1) = BufferSize then
              vaArquivos.Add(string(PChar(FileName)))
            else
              MessageTela('Erro ao obter nome do arquivo.');
          end;

        if vaArquivos.Count > 0 then
          ppvAnexarArquivos(vaArquivos);
      finally
        FreeAndNil(vaArquivos);
      end;

      Msg.Result := 0;
    end
  else
    FOriginalWindowProc(Msg);
end;

procedure TfrmChatTela.ppvPesquisaUsuario;
var
  vaCodigoHospital: string;
  vaUsuarioLogado: TArray<TPair<Integer, TChatUsuarioLogado>>;
  vaPair: TPair<Integer, TChatUsuarioLogado>;
begin
  EditNomeUsuario.PostEditValue;
  DMChat.cdsUsuarios.Filtered := False;

  // Filtrando o usuário pelo nome
  if VarIsNull(EditNomeUsuario.EditValue) or (EditNomeUsuario.EditValue = '') then
    DMChat.cdsUsuarios.Filter := ''
  else
    DMChat.cdsUsuarios.Filter := 'nome like (' + QuotedStr(EditNomeUsuario.EditValue + '%') + ')';

  // Filtrando os usuários e os grupos por hospital
  if not ckbTodosHospitais.Checked then
    begin
      // Usuários
      if DMChat.cdsUsuarios.Filter <> '' then
        DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ' and ';

      if not VarIsNull(cbHospital.EditValue) then
        begin
          DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + 'codigo_hospital = ' + IntToStr(cbHospital.EditValue);
          vaCodigoHospital := cbHospital.EditValue;
        end
      else
        begin
          DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + 'codigo_hospital = 0';
          vaCodigoHospital := '0';
        end;

      // Grupos
      if (not DMChat.cdsGrupos.Filtered) or (not TRegEx.IsMatch(DMChat.cdsGrupos.Filter, '^codigo_hospital = ' + vaCodigoHospital + '$', [roIgnoreCase, roSingleLine])) then
        begin
          DMChat.cdsGrupos.Filtered := False;
          DMChat.cdsGrupos.Filter := 'codigo_hospital = ' + vaCodigoHospital;
          DMChat.cdsGrupos.Filtered := True;
          DMChat.cdsGrupos.First;
          cbGrupo.EditValue := DMChat.cdsGruposCODIGO.AsInteger;
        end;
    end
  else
    begin
      // Grupos
      DMChat.cdsGrupos.Filtered := False;
      DMChat.cdsGrupos.Filter := '';
    end;

  // Filtrando os usuário por grupo
  if (not ckbTodosGrupos.Checked) and (not DMChat.cdsUsuarios.Filtered) then
    begin
      if DMChat.cdsUsuarios.Filter = '' then
        DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ' ('
      else
        DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ' and (';

      if VarIsNull(cbGrupo.EditValue) or (cbGrupo.EditValue = 0) then
        begin
          if VarIsNull(cbGrupo.EditValue) then
            // Não selecionou nenhum grupo, então não vamos trazer nenhum registro
            DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + 'codigo = 0 and codigo > 1'
          else
            begin
              // Grupo "Todos", então vamos trazer todos os usuários mais o próprio grupo
              DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter +
                'codigo_hospital = ' + IntToStr(DMChat.cdsGruposCODIGO_HOSPITAL.AsInteger) + ' and ' +
                '(usuario_grupo = 0 or codigo = 0)';
            end;
        end
      else
        begin
          // Selecionou um grupo, então vamos trazer todos os usuários do grupo mais o próprio grupo
          DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter +
            'codigo_hospital = ' + IntToStr(DMChat.cdsGruposCODIGO_HOSPITAL.AsInteger) + ' and ' +
            '(codigo = ' + IntToStr(cbGrupo.EditValue);

          try
            DMChat.cdsGrupos_Usuarios.Filtered := False;
            DMChat.cdsGrupos_Usuarios.Filter := 'codigo_grupo = ' + IntToStr(cbGrupo.EditValue) + ' and codigo_hospital = ' + IntToStr(DMChat.cdsGruposCODIGO_HOSPITAL.AsInteger);
            DMChat.cdsGrupos_Usuarios.Filtered := True;
            DMChat.cdsGrupos_Usuarios.First;

            while not DMChat.cdsGrupos_Usuarios.Eof do
              begin
                DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ' or codigo = ' + IntToStr(DMChat.cdsGrupos_UsuariosCODIGO_USUARIO.AsInteger);
                DMChat.cdsGrupos_Usuarios.Next;
              end;
          finally
            DMChat.cdsGrupos_Usuarios.Filtered := False;
            DMChat.cdsGrupos_Usuarios.Filter := '';
          end;

          DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ')';
        end;

      DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ')';
    end;

  // Eliminando da pesquisa o usuário logado, pois o usuário não vai enviar mensagem para ele mesmo
  if not DMChat.cdsUsuarios.Filtered then
    begin
      vaUsuarioLogado := FUsuarioLogado.ToArray;

      for vaPair in vaUsuarioLogado do
        begin
          if DMChat.cdsUsuarios.Filter <> '' then
            DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter + ' and ';

          DMChat.cdsUsuarios.Filter := DMChat.cdsUsuarios.Filter +
            '((codigo <> ' + IntToStr(vaPair.Value.IdentificacaoUsuario.CodigoUsuario) +
            ' and codigo_hospital = ' + IntToStr(vaPair.Value.IdentificacaoUsuario.CodigoHospital) +
            ') or (codigo_hospital <> ' + IntToStr(vaPair.Value.IdentificacaoUsuario.CodigoHospital) + '))';
        end;
    end;

  // Efetuando a pesquisa
  DMChat.cdsUsuarios.Filtered := True;
end;

procedure TfrmChatTela.ppvPreencherRichViewEdit(const ipCdsMensagem,
  ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit;
  ipSomenteRegistroSelecionado: Boolean);
begin
  ppvPreencherRichViewEdit(ipCdsMensagem, ipCdsMensagem_Anexo, ipRVE, '', False, ipSomenteRegistroSelecionado);
end;

procedure TfrmChatTela.ppvPreencherRichViewEdit(const ipCdsMensagem,
  ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit);
begin
  ppvPreencherRichViewEdit(ipCdsMensagem, ipCdsMensagem_Anexo, ipRVE, '', False, False);
end;

procedure TfrmChatTela.ppvPreencherRichViewEdit(const ipCdsMensagem,
  ipCdsMensagem_Anexo: TpmClientDataSet; ipRVE: TRichViewEdit;
  const ipDestacarTextoPesquisa: string; const ipExibirLinkVisualizacaoPesquisa,
  ipSomenteRegistroSelecionado: Boolean);

  function flcConfigTabela(const ipLinhas, ipColunas: Integer; const ipRichViewEdit: TRichViewEdit): TRVTableItemInfo;
  var
    X, Y: Integer;
  begin
    // Criando a tabela e adicionando no RichViewEdit
    Result := TRVTableItemInfo.CreateEx(ipLinhas, ipColunas, ipRichViewEdit.RVData);
    ipRichViewEdit.AddItem('', Result);

    // Configurando a tabela
    Result.Options := [];
    Result.BorderWidth := 1;
    Result.BorderStyle := rvtbColor;
    Result.BorderColor := $00CACACA;

    Result.VisibleBorders.Left := False;
    Result.VisibleBorders.Right := False;
    Result.VisibleBorders.Top := True;
    Result.VisibleBorders.Bottom := False;

    Result.BorderVSpacing := 0;
    Result.BorderHSpacing := 0;

    Result.CellPadding := 0;
    Result.CellHPadding := 0;
    Result.CellVPadding := 0;
    Result.CellBorderWidth := 0;

    // Limpando o conteúdo de todas as células
    for X := 0 to Result.RowCount - 1 do
      begin
        for Y := 0 to Result.ColCount - 1 do
          Result.Cells[X, Y].Clear;
      end;
  end;

  procedure plcIncluirTextoComImagens(ipCelula: TRVTableCellData; const ipTexto: string; const ipEstiloTexto, ipNroParagrafo: Integer; const ipIncluirSmileys: Boolean);
  var
    vaCodigosImagens: TMatchCollection;
    vaCodigo: TMatch;
    vaTexto, vaNomeImagem: string;
    vaNroParagrafo: Integer;
    vaImagem: TcxImageCollectionItem;
    vaGraphic: TGraphic;
  begin
    // Verificando se existem smileys
    if (not ipIncluirSmileys) or (not TRegEx.IsMatch(ipTexto, FSmileysExpressaoRegular, [roIgnoreCase])) then
      ipCelula.AddTextBlockNLA(ipTexto, ipEstiloTexto, ipNroParagrafo, 'texto')
    else
      begin
        vaNroParagrafo := ipNroParagrafo;
        vaTexto := ipTexto;

        // Pegando os smileys
        vaCodigosImagens := TRegEx.Matches(ipTexto, FSmileysExpressaoRegular, [roIgnoreCase]);

        for vaCodigo in vaCodigosImagens do
          begin
            // Incluindo o texto que está antes do smiley
            ipCelula.AddTextBlockNLA(TRegEx.Match(vaTexto, '.*?(?=' + TRegEx.Escape(vaCodigo.Value) + ')', [roIgnoreCase]).Value, ipEstiloTexto, vaNroParagrafo, 'texto');

            // A partir deste ponto não haverá um parágrafo definito, para não incluir uma nova linha
            vaNroParagrafo := -1;

            // Incluindo o smiley
            if FSmileys.TryGetValue(AnsiLowerCase(vaCodigo.Value), vaNomeImagem) then
              begin
                try
                  DMChat.ImgCollectionSmileys.Items.FindItemByName(vaNomeImagem, vaImagem);
                  vaGraphic := TGraphicClass(vaImagem.Picture.Graphic.ClassType).Create;
                  vaGraphic.Assign(vaImagem.Picture.Graphic);
                  ipCelula.AddPictureExTag('', vaGraphic, vaNroParagrafo, rvvaMiddle, 'Smiley');
                except
                  ipCelula.AddTextBlockNLA(vaCodigo.Value, ipEstiloTexto, vaNroParagrafo, 'texto');
                end;
              end
            else
              ipCelula.AddTextBlockNLA(vaCodigo.Value, ipEstiloTexto, vaNroParagrafo, 'texto');

            // Pegando todo o texto que está após o link
            vaTexto := TRegEx.Match(vaTexto, '(?<=' + TRegEx.Escape(vaCodigo.Value) + ').*', []).Value;
          end;

        // Imprimindo o texto restante
        if vaTexto <> '' then
          ipCelula.AddTextBlockNLA(vaTexto, ipEstiloTexto, vaNroParagrafo, 'texto');
      end;
  end;

  procedure plcIncluirAnexo(ipCelula: TRVTableCellData);
  const
    coSalvar = 'arquivoDownload';
    coVisualizar = 'arquivoVisualizar';
  var
    vaGraphic: TGraphic;
    vaPicture: TPicture;
    vaBytesStream: TBytesStream;
    vaTabela: TRVTableItemInfo;
    vaThumbnail: Boolean;
    vaIdentificacaoArquivo: string;
  begin
    vaGraphic := nil;
    vaPicture := nil;
    vaBytesStream := nil;
    vaThumbnail := not ipCdsMensagem_Anexo.FieldByName('THUMBNAIL').IsNull;
    vaIdentificacaoArquivo := IntToStr(ipCdsMensagem_Anexo.FieldByName('CODIGO_HOSPITAL').AsInteger) + '_' + ipCdsMensagem_Anexo.FieldByName('LOCAL').AsString;

    try
      if vaThumbnail then
        begin
          vaBytesStream := TBytesStream.Create;
          TBlobField(ipCdsMensagem_Anexo.FieldByName('THUMBNAIL')).SaveToStream(vaBytesStream);
          vaBytesStream.Position := 0;
          vaGraphic := fpvImagem(vaBytesStream, TWICImageFormat.wifJpeg);
        end
      else
        begin
          vaPicture := fpvIconeArquivo(ExtractFileExt(ipCdsMensagem_Anexo.FieldByName('NOME').AsString));

          if Assigned(vaPicture.Graphic) then
            begin
              vaGraphic := TGraphicClass(vaPicture.Graphic.ClassType).Create;
              vaGraphic.Assign(vaPicture.Graphic);
            end;
        end;
    finally
      if Assigned(vaBytesStream) then
        FreeAndNil(vaBytesStream);

      if Assigned(vaPicture) then
        FreeAndNil(vaPicture);
    end;

    vaTabela := TRVTableItemInfo.CreateEx(1, 2, ipRVE.RVData);
    ipCelula.AddItem('', vaTabela);

    // Configurando a tabela
    vaTabela.Options := [];
    vaTabela.BorderWidth := 0;
    vaTabela.Color := clNone;

    vaTabela.VisibleBorders.Left := False;
    vaTabela.VisibleBorders.Right := False;
    vaTabela.VisibleBorders.Top := False;
    vaTabela.VisibleBorders.Bottom := False;

    vaTabela.BorderVSpacing := 0;
    vaTabela.BorderHSpacing := 0;

    vaTabela.CellPadding := 0;
    vaTabela.CellHPadding := 0;
    vaTabela.CellVPadding := 0;
    vaTabela.CellBorderWidth := 0;

    vaTabela.Cells[0, 0].BestWidth := 1;
    vaTabela.Cells[0, 0].VAlign := rvcMiddle;
    vaTabela.Cells[0, 0].Clear;

    if Assigned(vaGraphic) then
      begin
        if vaThumbnail then
          vaTabela.Cells[0, 0].AddHotPictureTag('', vaGraphic, 4, rvvaMiddle, coVisualizar + vaIdentificacaoArquivo)
        else
          vaTabela.Cells[0, 0].AddHotPictureTag('', vaGraphic, 4, rvvaMiddle, coSalvar + vaIdentificacaoArquivo);
      end;

    vaTabela.Cells[0, 1].VAlign := rvcMiddle;
    vaTabela.Cells[0, 1].Clear;

    vaTabela.Cells[0, 1].AddTextBlockNLA(
      ipCdsMensagem_Anexo.FieldByName('NOME').AsString + ' - ' + fpvTamanhoFormatado(ipCdsMensagem_Anexo.FieldByName('TAMANHO_ORIG').AsLargeInt),
      0, 4, 'texto');

    vaTabela.Cells[0, 1].AddTextBlockNLA('Salvar', 4, 4, coSalvar + vaIdentificacaoArquivo);

    if not ipCdsMensagem_Anexo.FieldByName('THUMBNAIL').IsNull then
      begin
        vaTabela.Cells[0, 1].AddTextBlockNLA(' | ', 0, -1, 'texto');
        vaTabela.Cells[0, 1].AddTextBlockNLA('Visualizar', 4, -1, coVisualizar + vaIdentificacaoArquivo);
      end;
  end;

var
  vaChatPanelConversaAba: TChatPanelConversaAba;
  vaTabela: TRVTableItemInfo;
  vaCdsUsuario, vaCdsMensagem: TpmClientDataSet;
  vaLabel: TLabel;
  vaData: TDate;
  vaTexto: string;
  i, vaQtdeLinhas, vaNroParagrafo, vaLinha: Integer;
  vaLinhas: System.TArray<string>;
  vaLinks: TMatchCollection;
  vaLink: TMatch;
  vaIncluirSmileys, vaConversaEmGrupo, vaPararRepeticao: Boolean;
  vaUsuarioLogado: TChatIdentificacaoUsuario;
begin
  // **************************
  // Parágrafos               *
  // 0 - ParagrafoGenerico    * Este parágrafo existe por casa da tabela que usa o primeiro parágrafo como referência para se posicionar dentro do componente (TRichViewEdit)
  // 1 - ParagrafoRemetente   *
  // 2 - ParagrafoDataHora    *
  // 3 - ParagrafoMensagem    *
  // 4 - ParagrafoDivisaoData *
  // -------------------------*
  // Estilos                  *
  // 0 - FontRemetente        *
  // 1 - FontDataHora         *
  // 2 - FontMensagem         *
  // 3 - FontDivisaoData      *
  // **************************

  // Se não tem nada no ClientDataSet, então basta limpar o RichViewEdit
  if ipCdsMensagem.RecordCount = 0 then
    begin
      ipRVE.Clear;
      ipRVE.Change;
      ipRVE.Format;
      Exit;
    end;

  vaData := StrToDate('01/01/1900');
  vaLabel := nil;
  vaCdsUsuario := nil;
  vaPararRepeticao := True;

  // Pesquisando o usuário logado
  if not fpvUsuarioLogado(ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger, vaUsuarioLogado) then
    begin
      MessageTela('Falha ao carregar as mensagens.' + sLineBreak + 'Não foi possível identificar o usuário logado.');
      Exit;
    end;

  // Verificando se a conversa é em grupo
  try
    // *************************************
    // Mensagem                            *
    // Sem remetente: Enviada pelo sistema *
    // Sem destinatário: Grupo "todos"     *
    // *************************************

    // Se o destinatário for zero, então está no grupo "todos"
    vaConversaEmGrupo := ipCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsInteger = 0;

    if not vaConversaEmGrupo then
      begin
        vaCdsUsuario := fpvClonarClientDataSet(DMChat.cdsUsuarios);

        // Verificando se o destinatário é um grupo
        if vaCdsUsuario.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([ipCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsInteger, ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger]), []) then
          vaConversaEmGrupo := vaCdsUsuario.FieldByName('USUARIO_GRUPO').AsInteger = 1;
      end;
  finally
    if Assigned(vaCdsUsuario) then
      begin
        vaCdsUsuario.Close;
        FreeAndNil(vaCdsUsuario);
      end;
  end;

  // Verificando se é para carregar todas as mensagens do ClientDataSet ou se é para carregar uma mensagem específica
  if not ipSomenteRegistroSelecionado then
    begin
      // Carregar todas as mensagens,
      // então vamos posicionar na primeira mensagem e limpar o RichViewEdit
      ipCdsMensagem.First;
      ipCdsMensagem.IndexFieldNames := 'DATAHORA_ENVIO;CODIGO';
      ipRVE.Clear;
    end
  else
    begin
      // Carregar uma mensagem específica,
      // então vamos manter o que está no RichViewEdit e vamos pesquisar a última mensagem
      // recebida para saber se precisa incluir uma divisão por data dentro do texto

      try
        // Pesquisando a data do último registro inserido
        vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);

        if vaConversaEmGrupo then
          begin
            vaCdsMensagem.Filter :=
              'codigo < ' + ipCdsMensagem.FieldByName('CODIGO').AsString + ' and ' +
              'codigo_destinatario = ' + ipCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsString + ' and ' +
              'codigo_hospital = ' + ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsString;
          end
        else
          begin
            vaCdsMensagem.Filter :=
              'codigo < ' + ipCdsMensagem.FieldByName('CODIGO').AsString + ' and ' +
              'codigo_hospital = ' + ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsString + ' and ' +
              '((codigo_destinatario = ' + ipCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsString + ' and ' +
              '  codigo_remetente = ' + IntToStr(vaUsuarioLogado.CodigoUsuario) + ') or ' +
              ' (codigo_destinatario = ' + IntToStr(vaUsuarioLogado.CodigoUsuario) + ' and ' +
              '  codigo_remetente = ' + ipCdsMensagem.FieldByName('CODIGO_DESTINATARIO').AsString + '))';
          end;

        vaCdsMensagem.Filtered := True;

        if vaCdsMensagem.RecordCount > 0 then
          begin
            vaCdsMensagem.IndexFieldNames := 'DATAHORA_ENVIO';
            vaCdsMensagem.Last;
            vaData := StrToDate(FormatDateTime('dd/mm/yyyy', vaCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime));
          end;
      finally
        vaCdsMensagem.Close;
        FreeAndNil(vaCdsMensagem);
      end;
    end;

  try
    if ipCdsMensagem.RecordCount > 0 then
      begin
        vaCdsUsuario := fpvClonarClientDataSet(DMChat.cdsUsuarios);
        vaLabel := TLabel.Create(nil);

        // Carregando as mensagens para o RichViewEdit
        repeat
          // Verificando se há a necessidade de incluir a divisão da data
          if FormatDateTime('dd/mm/yyyy', vaData) <> FormatDateTime('dd/mm/yyyy', ipCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime) then
            begin
              vaTabela := flcConfigTabela(1, 1, ipRVE);
              vaTabela.Color := clSilver;
              vaData := ipCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime;
              vaTabela.Cells[0, 0].AddTextBlockNLA(TUtils.fpuCapitalize(TRegEx.Replace(FormatDateTime('dddd, dd of mmmm of yyyy', vaData), 'of', 'de', [roSingleLine, roIgnoreCase])), 3, 5);
            end;

          // Tabela da mensagem (uma linha e quatro colunas). Obs.: Pode haver duas linhas, caso deva exibir o link de visualização da mensagem
          // Primeira coluna: Nome de quem enviou a mensagem
          // Segunda coluna: Mensagem
          // Terceira coluna: Data e hora de envio
          // Quarta coluna: Leitores da mensagem
          if ipExibirLinkVisualizacaoPesquisa then
            begin
              vaTabela := flcConfigTabela(2, 4, ipRVE);
              vaLinha := 1;
            end
          else
            begin
              vaLinha := 0;
              vaTabela := flcConfigTabela(1, 4, ipRVE);
            end;

          // Identificando a tabela
          vaTabela.Tag := IntToStr(ipCdsMensagem.FieldByName('CODIGO').AsInteger) + '_' + IntToStr(ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger);

          // Ajustando o tamanho das células
          if vaLinha = 1 then
            begin
              vaChatPanelConversaAba := TChatPanelConversaAba(slbConversasListaUsuarios.FindComponent('pnlPesquisa'));

              vaTabela.MergeCells(0, 0, 4, 1, False);
              vaTabela.Cells[0, 0].Color := clWhite;
              vaTabela.Cells[0, 0].AddTextBlockNLA(
                'Visualizar',
                4,
                3,
                'pesquisar#CodMsg' + IntToStr(ipCdsMensagem.FieldByName('CODIGO').AsInteger) +
                '#idUserConversa' + vaChatPanelConversaAba.Identificador +
                '#DestacarTexto' + ipDestacarTextoPesquisa);
            end;

          vaTabela.Cells[vaLinha, 0].BestWidth := 100;
          vaTabela.Cells[vaLinha, 2].BestWidth := 100;
          vaTabela.Cells[vaLinha, 3].BestWidth := 20;

          // A princípio todas as mensagens terão smilyes
          vaIncluirSmileys := True;

          // Primeira coluna: Remetente da mensagem
          if ipCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger = 0 then
            begin
              // Mensagem do sistema
              vaTabela.Cells[vaLinha, 0].AddTextBlockNLA('Pro-Médico', 1, 1);

              // As mensagens do sistema não terão smileys
              vaIncluirSmileys := False;
            end
          else
            begin
              // Mensagem de algum usuário

              if vaCdsUsuario.Locate('CODIGO;CODIGO_HOSPITAL', VarArrayOf([ipCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger, ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger]), []) then
                begin
                  // Este label serve para ajustar o tamanho do nome do rementente da mensam ao espaço (100 px) atual da célula
                  vaLabel.Font.Name := DMChat.RVStyle1.TextStyles.Items[1].FontName;
                  vaLabel.Font.Size := DMChat.RVStyle1.TextStyles.Items[1].Size;
                  vaLabel.Font.Style := DMChat.RVStyle1.TextStyles.Items[1].Style;
                  vaLabel.Caption := TUtils.fpuCapitalize(vaCdsUsuario.FieldByName('NOME').AsString);

                  if vaLabel.Width > 96 then
                    begin
                      vaLabel.Caption := vaLabel.Caption + '...';

                      while (vaLabel.Width > 96) do
                        vaLabel.Caption := TRegEx.Match(vaLabel.Caption, '.+?(?=.\.\.\.)', [roSingleLine, roIgnoreCase]).Value + '...';
                    end;

                  vaTabela.Cells[vaLinha, 0].AddTextBlockNLA(vaLabel.Caption, 1, 1);
                end
              else
                vaTabela.Cells[vaLinha, 0].AddTextBlockNLA('Erro: Usuário não identificado', 1, 1);
            end;

          // Segunda coluna: Mensagem
          // A mensagem será quebrada em linhas e cada linha será um novo parágrafo para facilitar o código.
          // Em cada linha será separado o texto dos links.
          // Em cada texto serão separadas as palavras dos smileys
          // O código será escrito seguindo a ordem da explicação acima

          // O texto será incluído, somentente se tiver algo escrito
          if Trim(ipCdsMensagem.FieldByName('MENSAGEM').AsString) <> '' then
            begin
              // Pegando as linhas do texto (cada linha será um novo parágrafo)
              vaLinhas := TRegEx.Split(ipCdsMensagem.FieldByName('MENSAGEM').AsString, '\r\n', []);
              vaQtdeLinhas := Length(vaLinhas);

              // Adicionando as linhas
              for i := 0 to vaQtdeLinhas - 1 do
                begin
                  if (i + 1) = vaQtdeLinhas then
                    vaNroParagrafo := 3 // Este parágrafo possui um espaço após o parágrafo e deve ser usado somente na última linha do texto
                  else
                    vaNroParagrafo := 4; // Este parágrafo não possui espaço após o parágrafo

                  // Verificando se existem links na linha
                  vaLinks := TRegEx.Matches(vaLinhas[i], '(^|(?<=(\s|\(|\[|\{|\r)))((http(s\d?)?\:\/\/|www\.).+?|[\w\.]+?@[\w\.]+?\.[a-z0-9]{2,})(?=(\s|\)|\]|\}|,|;|\.\s|$))', [roIgnoreCase, roSingleLine]);

                  if vaLinks.Count = 0 then
                    // Nenhum link encontrado, então vamos apenas adicionar o texto e os smileys
                    plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], vaLinhas[i], 0, vaNroParagrafo, vaIncluirSmileys)
                  else
                    begin
                      // Existem links, então vamos adicioná-los

                      // Passando para a variável vaTexto todo o texto da linha, pois esta será uma variável de controle. Enquanto houver texto nesta variável,
                      // haverá impressão na tela
                      vaTexto := vaLinhas[i];

                      // Incluindo todos os links
                      for vaLink in vaLinks do
                        begin
                          // Incluindo o texto que está antes do link
                          plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], TRegEx.Match(vaTexto, '.*?(?=' + TRegEx.Escape(vaLink.Value) + ')', []).Value, 0, vaNroParagrafo, vaIncluirSmileys);

                          // A partir deste ponto não haverá um parágrafo definito, para não incluir uma nova linha
                          vaNroParagrafo := -1;

                          // Incluindo o link
                          if TRegEx.IsMatch(vaLink.Value, '[\w\.]+?@[\w\.]+?\.[a-z0-9]', [roIgnoreCase, roSingleLine]) then
                            vaTabela.Cells[vaLinha, 1].AddTextBlockNLA(vaLink.Value, 4, -1, 'e-mail')
                          else
                            vaTabela.Cells[vaLinha, 1].AddTextBlockNLA(vaLink.Value, 4, -1, 'link');

                          // Pegando todo o texto que está após o link
                          vaTexto := TRegEx.Match(vaTexto, '(?<=' + TRegEx.Escape(vaLink.Value) + ').*', []).Value;
                        end;

                      // Incluindo na linha o texto restante, ou seja, todo o texto que está após o último link da linha, caso ainda haja texto a ser incluído
                      if vaTexto <> '' then
                        plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], vaLinhas[i], 0, vaNroParagrafo, vaIncluirSmileys);
                    end;
                end;
            end;

            // Incluindo os anexos da mensagem na céluala
          try
            // Filtrando os anexos antes de incluir o texto para saber qual parágrafo deve ser utilizado no texto
            ipCdsMensagem_Anexo.Filtered := False;
            ipCdsMensagem_Anexo.Filter :=
              'CODIGO_MENSAGEM = ' + IntToStr(ipCdsMensagem.FieldByName('CODIGO').AsInteger) + ' AND ' +
              'CODIGO_HOSPITAL = ' + IntToStr(ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger);

            ipCdsMensagem_Anexo.Filtered := True;
            ipCdsMensagem_Anexo.First;

            while not ipCdsMensagem_Anexo.Eof do
              begin
                plcIncluirAnexo(vaTabela.Cells[vaLinha, 1]);
                ipCdsMensagem_Anexo.Next;
              end;
          finally
            ipCdsMensagem_Anexo.Filtered := False;
            ipCdsMensagem_Anexo.Filter := '';
          end;

          // Diferenciando a mensagem por cor
          if ipCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger = 0 then
            begin
              // Mensagem enviada pelo sistema

              if ipCdsMensagem.FieldByName('TIPO_MENSAGEM').AsInteger = 1 then
                begin
                  // Mensagem de alerta do sistema
                  vaTabela.Color := $00D5D5FF;
                  vaTabela.Cells[vaLinha, 0].Color := $00BFBFFF;
                end
              else
                begin
                  // Mensagem normal do sistema
                  vaTabela.Color := $00D7FFD7;
                  vaTabela.Cells[vaLinha, 0].Color := $00B9FFB9;
                end;
            end
          else
            begin
              if (ipCdsMensagem.FieldByName('CODIGO_REMETENTE').AsInteger = vaUsuarioLogado.CodigoUsuario) and
                (ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger = vaUsuarioLogado.CodigoHospital) then
                begin
                  // O usuário logado enviou a mensagem
                  vaTabela.Color := clWhite;
                  vaTabela.Cells[vaLinha, 0].Color := $00DFDFDF;
                end
              else
                begin
                  // O usuário logado recebeu a mensagem
                  vaTabela.Color := $00FBEEE3;
                  vaTabela.Cells[vaLinha, 0].Color := $00F8E3D1;
                end;
            end;

          // Terceira coluna: Data e hora de envio
          vaTabela.Cells[vaLinha, 2].AddTextBlockNLA(FormatDateTime('dd-mmm-yy hh:mm', ipCdsMensagem.FieldByName('DATAHORA_ENVIO').AsDateTime), 2, 2);

          // Quarta coluna: Leitores da mensagem
          if ipCdsMensagem.FieldByName('MENSAGEM_LIDA').AsInteger = 1 then
            begin
              ppvIncluirStatusMensagem(
                vaTabela.Cells[vaLinha, 3],
                2,
                IntToStr(ipCdsMensagem.FieldByName('CODIGO').AsInteger) + '_' +
                IntToStr(ipCdsMensagem.FieldByName('CODIGO_HOSPITAL').AsInteger));
            end;

          // Passando para a próxima mensagem, caso seja para passar em todos os registros
          if not ipSomenteRegistroSelecionado then
            begin
              ipCdsMensagem.Next;
              vaPararRepeticao := ipCdsMensagem.Eof;
            end;

        until vaPararRepeticao;

        ipRVE.Change;
        ipRVE.Format;
        ipRVE.VScrollPos := ipRVE.VScrollMax;
      end;
  finally
    if Assigned(vaCdsUsuario) then
      begin
        vaCdsUsuario.Close;
        FreeAndNil(vaCdsUsuario);
      end;

    if Assigned(vaLabel) then
      FreeAndNil(vaLabel);
  end;
end;

procedure TfrmChatTela.ppvSalvarArquivo(const ipCodigoHospital: Integer;
  const ipLocalArquivo: string);
var
  vaArquivo: TBytesStream;
  vaDestinoArquivo, vaNomeArquivo, vaExtensaoArquivo: string;
begin
  // Selecionando o local onde o arquivo será salvo
  if SelectDirectory('Selecione uma pasta para salvar o arquivo', 'C:\', vaDestinoArquivo) then
    begin
      // Fazendo o download do arquivo
      vaArquivo := fpvDownloadArquivo(ipCodigoHospital, ipLocalArquivo);

      if not Assigned(vaArquivo) then
        begin
          MessageTela('Arquivo não encontrado.');
          Exit;
        end;

      // Extraindo o nome do arquivo
      vaNomeArquivo := ExtractFileName(ipLocalArquivo);

      if TRegEx.IsMatch(vaNomeArquivo, '_\d{1,}\.zip$', [roIgnoreCase]) then
        vaNomeArquivo := TRegEx.Match(vaNomeArquivo, '.*(?=' + TRegEx.Escape(TRegEx.Match(vaNomeArquivo, '_\d{1,}\.zip$', [roIgnoreCase]).Value) + ')', [roIgnoreCase]).Value;

      vaExtensaoArquivo := ExtractFileExt(vaNomeArquivo);

      while FileExists(IncludeTrailingPathDelimiter(vaDestinoArquivo) + vaNomeArquivo) do
        begin
          if TRegEx.IsMatch(vaNomeArquivo, '(?<=\()\d{1,}(?=\)' + TRegEx.Escape(vaExtensaoArquivo) + '$)', [roIgnoreCase]) then
            vaNomeArquivo := TRegEx.Replace(vaNomeArquivo, '(?<=\()\d{1,}(?=\)' + TRegEx.Escape(vaExtensaoArquivo) + '$)',
              IntToStr(StrToInt(TRegEx.Match(vaNomeArquivo, '(?<=\()\d{1,}(?=\)' + TRegEx.Escape(vaExtensaoArquivo) + '$)', [roIgnoreCase]).Value) + 1), [roIgnoreCase])
          else
            vaNomeArquivo := TRegEx.Match(vaNomeArquivo, '.*(?=' + TRegEx.Escape(vaExtensaoArquivo) + '$)', [roIgnoreCase]).Value + '(1)' + vaExtensaoArquivo;
        end;

      // Salvando o arquivo na pasta selecionada
      ppvDescompactarArquivo(vaArquivo, IncludeTrailingPathDelimiter(vaDestinoArquivo) + vaNomeArquivo);
      MessageTela('Arquivo salvo em:' + sLineBreak + IncludeTrailingPathDelimiter(vaDestinoArquivo) + vaNomeArquivo);
    end;
end;

procedure TfrmChatTela.ppvSelecionarArquivo(Sender: TObject);
var
  vaChatPanelArquivo: TChatPanelArquivo absolute Sender;
begin
  if (Sender is TChatPanelArquivo) then
    begin
      if vaChatPanelArquivo.TipoArquivo = TChatTipoArquivo.taqImagem then
        ppvVisualizarArquivo(fpvCodigoHospital(vaChatPanelArquivo.Identificador), vaChatPanelArquivo.EnderecoArquivo)
      else
        ppvSalvarArquivo(fpvCodigoHospital(vaChatPanelArquivo.Identificador), vaChatPanelArquivo.EnderecoArquivo);
    end;
end;

procedure TfrmChatTela.ppvSelecionarConversa(Sender: TObject);
var
  vaChatPanelConversaAba: TChatPanelConversaAba absolute Sender;
  vaStringStream: TStringStream;
  vaOffSet: Integer;
  vaUsuarioLogado: TChatUsuarioLogado;
  vaCdsUsuarios, vaCdsMensagem, vaCdsMensagemAnexo: TpmClientDataSet;
  vaConversaEmGrupo: Boolean;
begin
  vaCdsUsuarios := nil;
  vaCdsMensagem := nil;
  vaCdsMensagemAnexo := nil;

  if Sender is TChatPanel then
    begin
      // Ações do panel que acabou de ser desmarcado
      if (not vaChatPanelConversaAba.Selecionado) then
        begin
          // Antes de carregar a nova conversa, vamos salvar o que está escrito, mas não foi enviado ainda
          vaStringStream := TStringStream.Create;

          try
            rveMensagensEdit.SaveTextToStream('', vaStringStream, 0, False, True);
            vaStringStream.Position := 0;
            vaChatPanelConversaAba.Mensagem.MensagemTXT := vaStringStream.ReadString(vaStringStream.Size);
          finally
            FreeAndNil(vaStringStream);
          end;
        end;

      // Ações do panel que acabou de ser selecionado
      if vaChatPanelConversaAba.Selecionado and ((not Assigned(FChatPanelSelecionado)) or (vaChatPanelConversaAba <> FChatPanelSelecionado)) then
        begin
          if Assigned(FChatPanelSelecionado) then
            FChatPanelSelecionado.Selecionado := False;

          FChatPanelSelecionado := vaChatPanelConversaAba;

          // Carregando os dados do usuário logado
          if not fpvUsuarioLogado(fpvCodigoHospital(FChatPanelSelecionado.Identificador), vaUsuarioLogado) then
            begin
              MessageTela('Não foi possível identificar o usuário logado.');
              Exit;
            end;

          // Carregando os dados do usuário selecionado
          ppvAtualizarDadosUsuarioTela(vaChatPanelConversaAba.Identificador, vaChatPanelConversaAba);

          // Limpando os dados da conversa anterior
          rveMensagens.Clear;

          // Verificando se há a necessidade de pesquisar as conversas no banco de dados
          vaCdsUsuarios := fpvClonarClientDataSet(DMChat.cdsUsuarios);
          vaCdsUsuarios.IndexFieldNames := 'CODIGO;CODIGO_HOSPITAL';
          vaConversaEmGrupo := False;

          try
            if vaCdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(vaChatPanelConversaAba.Identificador), []) then
              begin
                vaConversaEmGrupo := vaCdsUsuarios.FieldByName('USUARIO_GRUPO').AsInteger = 1;

                if (vaCdsUsuarios.FieldByName('CARREGAR_MENSAGENS').AsInteger = 1) then
                  ppvCarregarMensgensBancoDados(vaChatPanelConversaAba.Identificador);
              end;

            // Filtrando as mensagens
            vaCdsMensagem := fpvClonarClientDataSet(DMChat.cdsMensagem);
            vaCdsMensagem.Filtered := False;

            vaCdsMensagemAnexo := fpvClonarClientDataSet(DMChat.cdsMensagem_Anexo);

            if vaConversaEmGrupo then
              begin
                vaCdsMensagem.IndexFieldNames := 'CODIGO_DESTINATARIO;CODIGO_HOSPITAL';
                vaCdsMensagem.Filter :=
                  'codigo_destinatario = ' + IntToStr(fpvCodigoUsuario(vaChatPanelConversaAba.Identificador)) + ' and ' +
                  'codigo_hospital = ' + IntToStr(fpvCodigoHospital(vaChatPanelConversaAba.Identificador));
              end
            else
              begin
                vaCdsMensagem.IndexFieldNames := 'CODIGO_HOSPITAL;CODIGO_REMETENTE;CODIGO_DESTINATARIO';
                vaCdsMensagem.Filter :=
                  'codigo_hospital = ' + IntToStr(fpvCodigoHospital(vaChatPanelConversaAba.Identificador)) + ' and ' +
                  '((codigo_remetente = ' + IntToStr(fpvCodigoUsuario(vaChatPanelConversaAba.Identificador)) + ' and ' +
                  '  codigo_destinatario = ' + IntToStr(vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario) + ') or ' +
                  ' (codigo_remetente = ' + IntToStr(vaUsuarioLogado.IdentificacaoUsuario.CodigoUsuario) + ' and ' +
                  '  codigo_destinatario = ' + IntToStr(fpvCodigoUsuario(vaChatPanelConversaAba.Identificador)) + '))';
              end;

            vaCdsMensagem.Filtered := True;

            // Carregando as conversas na tela
            ppvPreencherRichViewEdit(vaCdsMensagem, vaCdsMensagemAnexo, rveMensagens);
          finally
            if Assigned(vaCdsUsuarios) then
              begin
                vaCdsUsuarios.Close;
                FreeAndNil(vaCdsUsuarios);
              end;

            if Assigned(vaCdsMensagem) then
              begin
                vaCdsMensagem.Close;
                FreeAndNil(vaCdsMensagem);
              end;

            if Assigned(vaCdsMensagemAnexo) then
              begin
                vaCdsMensagemAnexo.Close;
                FreeAndNil(vaCdsMensagemAnexo);
              end;
          end;

          // Reportando a leitura das mensagens
//          ppvInformarMensagensLidas(vaChatPanelConversaAba.Identificador);

          // Carregando os arquivos da conversa selecionada (Arquivos que já foram enviados)
          ppvCarregarArquivos(vaChatPanelConversaAba.Identificador);

          // Carregando os anexos da conversa selecionada (Arquivos que ainda não foram enviados)
          ppvCarregarAnexos(vaChatPanelConversaAba);

          // Limpando o campo de mensagem da conversa anterior e carregando a mensagem da nova conversa que ainda não foi enviada
          rveMensagensEdit.Clear;

          // Selecionando a aba do editor de conversa
          pgcPrincipal.ActivePage := tabConversa;
          pnlAlertaConversa.Visible := fpvVisualizarSomenteMensagensEnviadas(vaChatPanelConversaAba.Identificador);

          try
            vaStringStream := TStringStream.Create(vaChatPanelConversaAba.Mensagem.MensagemTXT);

            if Assigned(vaStringStream) then
              begin
                vaStringStream.Position := 0;
                rveMensagensEdit.LoadTextFromStream(vaStringStream, 0, 0, True);
              end;
          finally
            if Assigned(vaStringStream) then
              FreeAndNil(vaStringStream);
          end;

          rveMensagensEdit.Change;
          rveMensagensEdit.Format;

          // Posicionando o cursor no final do texto
          vaOffSet := rveMensagensEdit.GetOffsAfterItem(rveMensagensEdit.ItemCount - 1);
          rveMensagensEdit.SetSelectionBounds(rveMensagensEdit.ItemCount - 1, vaOffSet, rveMensagensEdit.ItemCount - 1, vaOffSet);

          // Focando no RichViewEdit
          if Self.Showing then
            rveMensagensEdit.SetFocus;

          if DMChat.cdsUsuarios.Locate('CODIGO;CODIGO_HOSPITAL', fpvCodigosUsuarioHospital(FChatPanelSelecionado.Identificador), []) then
            begin
              if DMChat.cdsUsuariosATIVO_INATIVO.AsInteger = 0 then
                begin
                  if DMChat.cdsUsuariosNOME.AsString = 'TODOS' then
                    DMChat.Ac_Smiles.Enabled := vaUsuarioLogado.EnviaMensagemGrupoTodos
                  else
                    DMChat.Ac_Smiles.Enabled := True;
                end
              else
                DMChat.Ac_Smiles.Enabled := False;

              DMChat.Ac_Anexar.Enabled := DMChat.Ac_Smiles.Enabled;
            end;
        end;

      // Ações do panel que está selecionado e foi selecionado novamente
      if Assigned(FChatPanelSelecionado) and (vaChatPanelConversaAba = FChatPanelSelecionado) then
        begin
          if vaChatPanelConversaAba.Selecionado and (pgcPrincipal.ActivePage = tabConversa) and Self.Showing then
            rveMensagensEdit.SetFocus;
        end;
    end;
end;

procedure TfrmChatTela.ppvSelecionarUsuarioGrupo(Sender: TObject);
begin
  if (Sender is TChatPanelConversa) then
    ppvAdicionarConversa(TChatPanelConversa(Sender).Identificador, True, False);
end;

procedure TfrmChatTela.ppvTelaVisualizacoesMensagemMouseWeelDown(
  Sender: TObject; Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);
var
  vaComponente: TComponent;
  vaVertScrollBar: TcxScrollBoxScrollBarOptions;
begin
  if Sender is TForm then
    begin
      vaComponente := TForm(Sender).FindComponent('sbxListaNomes');

      if Assigned(vaComponente) and (vaComponente is TcxScrollBox) then
        begin
          vaVertScrollBar := TcxScrollBox(vaComponente).VertScrollBar;

          if (vaVertScrollBar.Position + vaVertScrollBar.Increment) <= vaVertScrollBar.Range then
            vaVertScrollBar.Position := vaVertScrollBar.Position + vaVertScrollBar.Increment
          else
            vaVertScrollBar.Position := vaVertScrollBar.Range;
        end;
    end;
end;

procedure TfrmChatTela.ppvTelaVisualizacoesMensagemMouseWeelUp(
  Sender: TObject; Shift: TShiftState; MousePos: TPoint; var Handled: Boolean);
var
  vaComponente: TComponent;
  vaVertScrollBar: TcxScrollBoxScrollBarOptions;
begin
  if Sender is TForm then
    begin
      vaComponente := TForm(Sender).FindComponent('sbxListaNomes');

      if Assigned(vaComponente) and (vaComponente is TcxScrollBox) then
        begin
          vaVertScrollBar := TcxScrollBox(vaComponente).VertScrollBar;

          if (vaVertScrollBar.Position - vaVertScrollBar.Increment) >= 0 then
            vaVertScrollBar.Position := vaVertScrollBar.Position - vaVertScrollBar.Increment
          else
            vaVertScrollBar.Position := 0;
        end;
    end;
end;

procedure TfrmChatTela.ppvVisualizarArquivo(const ipCodigoHospital: Integer;
  const ipLocalArquivo: string);
var
  vaArquivo, vaArquivoDescompactado: TBytesStream;
  vafrmZoomImg: TfrmZoomImg;
  vaGraphic: TGraphic;
  vaGraphicClass: TGraphicClass;
  vaPicture: TPicture;
  vaGalleryControlItem: TdxGalleryControlItem;
begin
  vaArquivo := nil;
  vaArquivoDescompactado := nil;
  vaGraphic := nil;
  vaPicture := nil;

  // Fazendo o download do arquivo
  vaArquivo := fpvDownloadArquivo(ipCodigoHospital, ipLocalArquivo);

  if not Assigned(vaArquivo) then
    begin
      MessageTela('Arquivo não encontrado.');
      Exit;
    end;

  // Visualizando o arquivo
  vafrmZoomImg := TfrmZoomImg.Create(Self);

  try
    ppvDescompactarArquivo(vaArquivo, vaArquivoDescompactado);
    vafrmZoomImg.BorderStyle := bsSingle;
    vafrmZoomImg.pnConteudoEsquerda.Align := alClient;
    vafrmZoomImg.ImgMax.Properties.FitMode := ifmNormal;
    vafrmZoomImg.Ac_SavarImagem.Visible := True;
    vafrmZoomImg.pnAcoes.Visible := True;
    vafrmZoomImg.PanelAcoesSempreVisivel := True;
    vafrmZoomImg.btnDuplicar.Visible := False;
    vafrmZoomImg.AparecerGalerias := False;
    vafrmZoomImg.Caption := ExtractFileName(ipLocalArquivo);

    if TRegEx.IsMatch(vafrmZoomImg.Caption, '_\d{1,}\.zip$', [roIgnoreCase]) then
      vafrmZoomImg.Caption := TRegEx.Match(vafrmZoomImg.Caption, '.*(?=' + TRegEx.Escape(TRegEx.Match(vafrmZoomImg.Caption, '_\d{1,}\.zip$', [roIgnoreCase]).Value) + ')', [roIgnoreCase]).Value;

    vafrmZoomImg.NomeImagem := vafrmZoomImg.Caption;

    try
      if fpvFindGraphicClass(vaArquivoDescompactado, vaGraphicClass) then
        begin
          vaGraphic := vaGraphicClass.Create;
          vaArquivoDescompactado.Position := 0;
          vaGraphic.LoadFromStream(vaArquivoDescompactado);

          vaPicture := TPicture.Create;
          vaPicture.Graphic := vaGraphic;

          vafrmZoomImg.ImgMax.Picture := vaPicture;
        end;
    finally
      if Assigned(vaGraphic) then
        FreeAndNil(vaGraphic);

      if Assigned(vaPicture) then
        FreeAndNil(vaPicture);
    end;

    vafrmZoomImg.ShowModal;
  finally
    FreeAndNil(vafrmZoomImg);

    if Assigned(vaArquivo) then
      FreeAndNil(vaArquivo);

    if Assigned(vaArquivoDescompactado) then
      FreeAndNil(vaArquivoDescompactado);
  end;
end;

procedure TfrmChatTela.rveMensagensEditKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  inherited;

  if (Key = VK_RETURN) and (not((ssCtrl in Shift) or (ssShift in Shift))) then
    begin
      Key := 0;
      DMChat.Ac_Enviar.Execute;
    end;
end;

procedure TfrmChatTela.rveMensagensEditKeyPress(Sender: TObject; var Key: Char);
begin
  inherited;
  // Este evento foi criado apenas para que o "Enter" não funcione como "Tab" no rveMensagensEdit,
  // pois este possui suas próprias funcionalidades
end;

procedure TfrmChatTela.rveMensagensKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  inherited;

  if not(Key in [VK_RETURN, VK_F1 .. VK_F24]) then
    rveMensagensEdit.SetFocus;
end;

procedure TfrmChatTela.SetAoConfirmarLeituraMensagens(const Value: TChatConfirmarLeituraMensagens);
begin
  FAoConfirmarLeituraMensagens := Value;
end;

procedure TfrmChatTela.SetAoEnviarMensagem(const Value: TChatEnviarMensagem);
begin
  FAoEnviarMensagem := Value;
end;

procedure TfrmChatTela.SetAoFazerDownloadArquivo(
  const Value: TChatDownloadArquivo);
begin
  FAoFazerDownloadArquivo := Value;
end;

procedure TfrmChatTela.SetAoMudarStatusConversa(
  const Value: TChatMudarStatusConversa);
begin
  FAoMudarStatusConversa := Value;
end;

procedure TfrmChatTela.SetAoPesquisar(const Value: TChatPesquisarMensagens);
begin
  FAoPesquisar := Value;
end;

procedure TfrmChatTela.SetAoPesquisarConfiguracoes(
  const Value: TChatPesquisarConfiguracoes);
begin
  FAoPesquisarConfiguracoes := Value;
end;

procedure TfrmChatTela.SetAoPesquisarLeitores(
  const Value: TChatPesquisarLeitoresMensagens);
begin
  FAoPesquisarLeitores := Value;
end;

procedure TfrmChatTela.SetAoSalvarConfiguracoes(
  const Value: TChatSalvarConfiguracoes);
begin
  FAoSalvarConfiguracoes := Value;
end;

end.
