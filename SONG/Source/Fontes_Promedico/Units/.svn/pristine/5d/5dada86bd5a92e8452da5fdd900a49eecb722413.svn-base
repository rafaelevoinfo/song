unit pChatTipos;

interface

uses
  System.Classes, System.SysUtils, RVEdit, RVStyle, System.Generics.Collections,
  Winapi.Windows, System.Zip, Vcl.Graphics, System.IniFiles, dxGDIPlusClasses,
  Vcl.Imaging.jpeg, System.Math, System.Win.ComObj, System.Variants, RVItem,
  System.RegularExpressions, Vcl.ExtCtrls, Vcl.Controls, cxGraphics, pDMChat,
  RVTable, Vcl.StdCtrls, Data.DB, pUtils, System.DateUtils, pMethod2009,
  Vcl.Imaging.PngImage, Vcl.Imaging.GIFImg, System.AnsiStrings, RichView;

type
  // Criando tipos
  TChatFormatoStream = (ftDocx, ftHtml, ftRtf, ftRvf, ftTxt);
  TChatTipoAba = (taConfiguracao, taConversaGrupo, taConversaUsuario, taPesquisa);
  TChatTipoArquivo = (taqImagem, taqOutros);
  TChatTipoPesquisa = (tpqCodigo, tpqCodigoMesagensProximas, tpqUltimasMensagens, tpqData, tpqDataTexto, tpqTexto);
  TChatEstiloRich = (erNormal, erResultadoPesquisa);

  // Criando os registros
  TChatIdentificacaoUsuario = record
  private
    FCodigoUsuario: Integer;
    FCodigoHospital: Integer;
    procedure SetCodigoHospital(const Value: Integer);
    procedure SetCodigoUsuario(const Value: Integer);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatIdentificacaoUsuario);
    property CodigoHospital: Integer read FCodigoHospital write SetCodigoHospital;
    property CodigoUsuario: Integer read FCodigoUsuario write SetCodigoUsuario;
    { Public declarations }
  end;

  TChatUsuarioLogado = record
  private
    FEnviaMensagemGrupoTodos: Boolean;
    FIdentificacaoUsuario: TChatIdentificacaoUsuario;
    procedure SetEnviaMensagemGrupoTodos(const Value: Boolean);
    procedure SetIdentificacaoUsuario(const Value: TChatIdentificacaoUsuario);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatUsuarioLogado);
    property EnviaMensagemGrupoTodos: Boolean read FEnviaMensagemGrupoTodos write SetEnviaMensagemGrupoTodos;
    property IdentificacaoUsuario: TChatIdentificacaoUsuario read FIdentificacaoUsuario write SetIdentificacaoUsuario;
    { Public declarations }
  end;

  TChatConversa = record
  private
    FIdentificacaoUsuario: TChatIdentificacaoUsuario;
    FNotificar: Boolean;
    FSelecionar: Boolean;
    procedure SetIdentificacaoUsuario(const Value: TChatIdentificacaoUsuario);
    procedure SetNotificar(const Value: Boolean);
    procedure SetSelecionar(const Value: Boolean);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatConversa);
    property IdentificacaoUsuario: TChatIdentificacaoUsuario read FIdentificacaoUsuario write SetIdentificacaoUsuario;
    property Notificar: Boolean read FNotificar write SetNotificar;
    property Selecionar: Boolean read FSelecionar write SetSelecionar;
    { Public declarations }
  end;

  TChatDadosConversa = record
  private
    FAnexos: OleVariant;
    FMensagens: OleVariant;
    FPosicaoScroll: Integer;
    procedure SetAnexos(const Value: OleVariant);
    procedure SetMensagens(const Value: OleVariant);
    procedure SetPosicaoScroll(const Value: Integer);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatDadosConversa);
    property Anexos: OleVariant read FAnexos write SetAnexos;
    property Mensagens: OleVariant read FMensagens write SetMensagens;
    property PosicaoScroll: Integer read FPosicaoScroll write SetPosicaoScroll;
    { Public declarations }
  end;

  TChatStatus = record
  private
    FIdentificacaoUsuario: TChatIdentificacaoUsuario;
    FStatus: Integer;
    procedure SetIdentificacaoUsuario(const Value: TChatIdentificacaoUsuario);
    procedure SetStatus(const Value: Integer);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatStatus);
    property IdentificacaoUsuario: TChatIdentificacaoUsuario read FIdentificacaoUsuario write SetIdentificacaoUsuario;
    property Status: Integer read FStatus write SetStatus;
    { Public declarations }
  end;

  TChatHospital = record
  private
    FCodigo: Integer;
    FNomeFantasia: string;
    FRazaoSocial: string;
    procedure SetCodigo(const Value: Integer);
    procedure SetNomeFantasia(const Value: string);
    procedure SetRazaoSocial(const Value: string);
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatHospital);
    property Codigo: Integer read FCodigo write SetCodigo;
    property NomeFantasia: string read FNomeFantasia write SetNomeFantasia;
    property RazaoSocial: string read FRazaoSocial write SetRazaoSocial;
    { Public declarations }
  end;

  TChatAnexoPropriedades = record
  private
    FExtencao: string;
    FId: Integer;
    FNome: string;
    FTamanho: Int64;
    FTamanhoFormatado: string;
    FTamanhoOriginal: Int64;
    FTamanhoOriginalFtd: string;
    { Private declarations }
  public
    procedure ppuCopiarDe(const ipOrigem: TChatAnexoPropriedades);
    property Extencao: string read FExtencao;
    property Id: Integer read FId;
    property Nome: string read FNome;
    property Tamanho: Int64 read FTamanho;
    property TamanhoFomatado: string read FTamanhoFormatado;
    property TamanhoOriginal: Int64 read FTamanhoOriginal;
    property TamanhoOriginalFtd: string read FTamanhoOriginalFtd;
    { Public declarations }
  end;

  // Declarando algumas classes necessárias para os eventos.
  // Essas classes estão implementadas na parte de criação
  // das classes
  TChatConfiguracoes = class;
  TChatDadosUsuario = class;
  TChatMensagem = class;

  // Criando eventos
  TChatAnexoLimiteAtingido = procedure(const ipArquivosRecusados: TStrings) of object;
  TChatConfirmarLeituraMensagens = procedure(const ipUsuarioLeu: TChatIdentificacaoUsuario; const ipMensagensLidas: string) of object;
  TChatDownloadArquivo = function(const ipCodigoHospital: Integer; const ipEnerecoArquivo: string): TBytesStream of object;
  TChatEnviarMensagem = procedure(const ipMensagem: TChatMensagem; const ipDestinatarios: TArray<TChatDadosUsuario>) of object;
  TChatMudarStatusConversa = procedure(const ipUsuarioLogado, ipUsuarioConversa: TChatIdentificacaoUsuario; const ipConversaAtiva: Boolean) of object;
  TChatPesquisarAnexos = function(const ipUsuarioLoagado, ipUsuarioConversa: TChatIdentificacaoUsuario; const ipQuantidadeAnexos, ipCodigoMensagem: Integer; const ipUsuarioSistema, ipPesqSomenteMsgEnviadas: Boolean): OleVariant of object;
  TChatPesquisarConfiguracoes = function(const ipUsuarioLogado: TChatIdentificacaoUsuario): TChatConfiguracoes of object;
  TChatPesquisarGrupos = function(const ipCodigoHospital: Integer; const ipCodigosGrupos: string; const ipGruposAtivos, ipGruposInativos: Boolean): OleVariant of object;
  TChatPesquisarLeitoresMensagens = function(const ipCodigoHospital, ipCodigoMensagem: Integer): OleVariant of object;
  TChatPesquisarUsuarios = function(const ipCodigoHospital: Integer; const ipCodigosUsuarios: string; const ipUsuariosAtivos, ipUsuariosInativos: Boolean; const ipTipoPapelUsuarioSistema: Integer): OleVariant of object;
  TChatPesquisarMensagens = function(const ipTipoPesquisa: TChatTipoPesquisa; const ipTexto: string; const ipDataInicial, ipDataFinal: TDate; const ipUsuarioLoagado, ipUsuarioConversa: TChatIdentificacaoUsuario; const ipUsuarioSistema, ipPesqSomenteMsgEnviadas: Boolean): OleVariant of object;
  TChatSalvarConfiguracoes = procedure(const ipConfiguracoes: TChatConfiguracoes; const ipUsuario: TChatIdentificacaoUsuario) of object;

  // Criando as classes
  TChatDadosUsuario = class
  private
    FFotoUsuario: TPicture;
    FIdentificacao: TChatIdentificacaoUsuario;
    FNome: string;
    procedure SetFotoUsuario(const Value: TPicture);
    procedure SetIdentificacao(const Value: TChatIdentificacaoUsuario);
    procedure SetNome(const Value: string);
    { Private declarations }
  public
    constructor Create;
    destructor Destroy; override;
    procedure ppuCopiarDe(const ipOrigem: TChatDadosUsuario);
    property FotoUsuario: TPicture read FFotoUsuario write SetFotoUsuario;
    property Identificacao: TChatIdentificacaoUsuario read FIdentificacao write SetIdentificacao;
    property Nome: string read FNome write SetNome;
    { Public declarations }
  end;

  TChatDadosPesquisa = class
  private
    FDadosConversa: TChatDadosConversa;
    FDataInicial: TDate;
    FDataFinal: TDate;
    FFotoUsuario: TPicture;
    FIdentificador: string;
    FNomeHospital: string;
    FNomeFuncao: string;
    FNomeUsuario: string;
    FPesquisarData: Boolean;
    FTexto: String;
    procedure SetDadosConversa(const Value: TChatDadosConversa);
    procedure SetDataFinal(const Value: TDate);
    procedure SetDataInicial(const Value: TDate);
    procedure SetFotoUsuario(const Value: TPicture);
    procedure SetIdentificador(const Value: string);
    procedure SetNomeFuncao(const Value: string);
    procedure SetNomeHospital(const Value: string);
    procedure SetNomeUsuario(const Value: string);
    procedure SetPesquisarData(const Value: Boolean);
    procedure SetTexto(const Value: String);
    { Private declarations }
  public
    constructor Create;
    destructor Destroy; override;
    procedure ppuCopiarDe(const ipOrigem: TChatDadosPesquisa);
    property DadosConversa: TChatDadosConversa read FDadosConversa write SetDadosConversa;
    property DataInicial: TDate read FDataInicial write SetDataInicial;
    property DataFinal: TDate read FDataFinal write SetDataFinal;
    property FotoUsuario: TPicture read FFotoUsuario write SetFotoUsuario;
    property Identificador: string read FIdentificador write SetIdentificador;
    property NomeHospital: string read FNomeHospital write SetNomeHospital;
    property NomeFuncao: string read FNomeFuncao write SetNomeFuncao;
    property NomeUsuario: string read FNomeUsuario write SetNomeUsuario;
    property PesquisarData: Boolean read FPesquisarData write SetPesquisarData;
    property Texto: String read FTexto write SetTexto;
    { Public declarations }
  end;

  TChatConfiguracoes = class
  private
    FEMail: string;
    FFonteNome: string;
    FFonteTamanho: Integer;
    FFoto: TPicture;
    FNovasMensagensApenasAlerta: Integer;
    FPermitirAlterarAlertaMensagens: Boolean;
    FTelefone: string;
    procedure SetEMail(const Value: string);
    procedure SetFonteNome(const Value: string);
    procedure SetFonteTamanho(const Value: Integer);
    procedure SetFoto(const Value: TPicture);
    procedure SetNovasMensagensApenasAlerta(const Value: Integer);
    procedure SetPermitirAlterarAlertaMensagens(const Value: Boolean);
    procedure SetTelefone(const Value: string);
    { Private declarations }
  public
    constructor Create;
    procedure ppuCopiarDe(const ipOrigem: TChatConfiguracoes);
    property EMail: string read FEMail write SetEMail;
    property FonteNome: string read FFonteNome write SetFonteNome;
    property FonteTamanho: Integer read FFonteTamanho write SetFonteTamanho;
    property Foto: TPicture read FFoto write SetFoto;
    property NovasMensagensApenasAlerta: Integer read FNovasMensagensApenasAlerta write SetNovasMensagensApenasAlerta;
    property PermitirAlterarAlertaMensagens: Boolean read FPermitirAlterarAlertaMensagens write SetPermitirAlterarAlertaMensagens;
    property Telefone: string read FTelefone write SetTelefone;
    { Public declarations }
  end;

  TChatUsuario = class
  private
    FAtivoInativo: Integer;
    FEMail: string;
    FFoto: TPicture;
    FFotoThumbnail: TPicture;
    FFuncao: string;
    FGrupoUsuarios: TArray<Integer>;
    FIdentificacaoUsuario: TChatIdentificacaoUsuario;
    FNome: string;
    FPromedico: Integer;
    FStatus: Integer;
    FUsuarioGrupo: Integer;
    procedure SetAtivoInativo(const Value: Integer);
    procedure SetEMail(const Value: string);
    procedure SetFoto(const Value: TPicture);
    procedure SetFotoThumbnail(const Value: TPicture);
    procedure SetFuncao(const Value: string);
    procedure SetGrupoUsuarios(const Value: TArray<Integer>);
    procedure SetIdentificacaoUsuario(const Value: TChatIdentificacaoUsuario);
    procedure SetNome(const Value: string);
    procedure SetPromedico(const Value: Integer);
    procedure SetStatus(const Value: Integer);
    procedure SetUsuarioGrupo(const Value: Integer);
    { Private declarations }
  public
    constructor Create;
    destructor Destroy; override;
    procedure ppuCopiarDe(const ipOrigem: TChatUsuario);
    property AtivoInativo: Integer read FAtivoInativo write SetAtivoInativo;
    property EMail: string read FEMail write SetEMail;
    property Foto: TPicture read FFoto write SetFoto;
    property FotoThumbnail: TPicture read FFotoThumbnail write SetFotoThumbnail;
    property Funcao: string read FFuncao write SetFuncao;
    property GrupoUsuarios: TArray<Integer> read FGrupoUsuarios write SetGrupoUsuarios;
    property IdentificacaoUsuario: TChatIdentificacaoUsuario read FIdentificacaoUsuario write SetIdentificacaoUsuario;
    property Nome: string read FNome write SetNome;
    property Promedico: Integer read FPromedico write SetPromedico;
    property Status: Integer read FStatus write SetStatus;
    property UsuarioGrupo: Integer read FUsuarioGrupo write SetUsuarioGrupo;
    { Public declarations }
  end;

  TChatAnexo = class
  private
    FArquivo: TBytesStream;
    FArquivoThumbnail: TBytesStream;
    FEndereco: string; // Este endereço é usado para informar o caminho completo do arquivo no servidor (incluindo o nome que ele foi gravado)
    FId: Integer; // Este identificador será utilizado na classe TChatMensagem para atribuir um número único para o objeto
    FNome: string;
    FTamanhoOriginal: Int64;
    function fpvTamanhoFormatado(const ipTamanho: Int64): string;
    function GetExtencao: string;
    function GetTamanho: Int64;
    function GetPropriedades: TChatAnexoPropriedades;
    function GetTamanhoFormatado: string;
    function GetTamanhoOriginalFtd: string;
    procedure SetEndereco(const Value: string);
    { Private declarations }
  public
    constructor Create;
    destructor Destroy; override;
    procedure ppuAnexarArquivo(const ipArquivo: TFileStream; const ipArquivoThumbnail: TBytesStream; const ipNome: string; const ipTamanhoOriginal: Int64);
    procedure ppuCopiarDe(const ipOrigem: TChatAnexo);
    property Arquivo: TBytesStream read FArquivo;
    property ArquivoThumbnail: TBytesStream read FArquivoThumbnail;
    property Endereco: string read FEndereco write SetEndereco;
    property Extencao: string read GetExtencao;
    property Id: Integer read FId;
    property Nome: string read FNome;
    property Propriedades: TChatAnexoPropriedades read GetPropriedades;
    property Tamanho: Int64 read GetTamanho;
    property TamanhoFormatado: string read GetTamanhoFormatado;
    property TamanhoOriginal: Int64 read FTamanhoOriginal;
    property TamanhoOriginalFtd: string read GetTamanhoOriginalFtd;
    { Public declarations }
  end;

  TChatMensagem = class
  private
    FAnexos: TList<TChatAnexo>;
    FAnexosLimite: Int64;
    FAnexosNextId: Integer;
    FAoAtingirLimiteAnexos: TChatAnexoLimiteAtingido;
    FDestinatario: TChatIdentificacaoUsuario;
    FMensagemRVF: TBytesStream;
    FRemetente: TChatIdentificacaoUsuario;
    FTipoMensagem: Integer;
    function fpvRetornaIndiceAnexo(const ipId: Integer): Integer;
    function fpvRetornaStreamFormatado(const ipFormato: TChatFormatoStream): TBytesStream;
    function fpvRetornaString(const ipFormato: TChatFormatoStream): string;
    function GetAnexosPropriedades: TArray<TChatAnexoPropriedades>;
    function GetAnexosQtde: Integer;
    function GetAnexosTotal: Int64;
    function GetMensagemDOCX: TBytesStream;
    function GetMensagemHTML: string;
    function GetMensagemRTF: TBytesStream;
    function GetMensagemRVF: TBytesStream;
    function GetMensagemTXT: string;
    procedure ppvCarrearStream(const ipFormato: TChatFormatoStream; const ipBytesStream: TBytesStream);
    procedure SetAnexosLimite(const Value: Int64);
    procedure SetAoAtingirLimiteAnexos(const Value: TChatAnexoLimiteAtingido);
    procedure SetDestinatario(const Value: TChatIdentificacaoUsuario);
    procedure SetMensagemRTF(const Value: TBytesStream);
    procedure SetMensagemRVF(const Value: TBytesStream);
    procedure SetMensagemTXT(const Value: string);
    procedure SetRemetente(const Value: TChatIdentificacaoUsuario);
    procedure SetTipoMensagem(const Value: Integer);
    { Private declarations }
  public
    constructor Create;
    destructor Destroy; override;
    function fpuAnexarArquivos(const ipArquivos: TStrings): TArray<TChatAnexoPropriedades>;
    function fpuDeletarAnexo(const ipId: Integer): Boolean;
    function fpuPropriedadeAnexo(const ipId: Integer): TChatAnexoPropriedades;
    procedure ppuCopiarDe(const ipOrigem: TChatMensagem);
    procedure ppuLimparAnexos;
    procedure ppuLimparMensagem;
    property Anexos: TList<TChatAnexo> read FAnexos;
    property AnexosLimite: Int64 read FAnexosLimite write SetAnexosLimite;
    property AnexosTotal: Int64 read GetAnexosTotal;
    property AnexosPropriedades: TArray<TChatAnexoPropriedades> read GetAnexosPropriedades;
    property AnexosQtde: Integer read GetAnexosQtde;
    property AoAtingirLimiteAnexos: TChatAnexoLimiteAtingido read FAoAtingirLimiteAnexos write SetAoAtingirLimiteAnexos;
    property Destinatario: TChatIdentificacaoUsuario read FDestinatario write SetDestinatario;
    property MensagemDOCX: TBytesStream read GetMensagemDOCX;
    property MensagemHTML: string read GetMensagemHTML;
    property MensagemRTF: TBytesStream read GetMensagemRTF write SetMensagemRTF;
    property MensagemRVF: TBytesStream read GetMensagemRVF write SetMensagemRVF;
    property MensagemTXT: string read GetMensagemTXT write SetMensagemTXT;
    property Remetente: TChatIdentificacaoUsuario read FRemetente write SetRemetente;
    property TipoMensagem: Integer read FTipoMensagem write SetTipoMensagem;
    { Public declarations }
  end;

  TChatFuncoes = class
  private
    const
      coMinGraphicSize = 44;
    { Private declarations }
  public
    class function fpuCodigoHospital(const ipIdentificador: string): Integer;
    class function fpuCodigosUsuarioHospital(const ipIdentificador: string): Variant;
    class function fpuCodigoUsuario(const ipIdentificador: string): Integer;
    class function fpuFindGraphicClass(const ipBuffer; const ipBufferSize: Int64; out ioGraphicClass: TGraphicClass): Boolean; overload;
    class function fpuFindGraphicClass(const ipStream: TStream; out ioGraphicClass: TGraphicClass): Boolean; overload;
    class function fpuIconeArquivo(const ipExtensaoArquivo: string; const ipDMChat: TDMChat): TPicture;
    class function fpuImagem(const ipBytesStream: TBytesStream; const ipFormatoSecundario: TWICImageFormat): TGraphic;
    class function fpuMontaIdentificador(const ipCodigoUsuario, ipCodigoHospital: Integer): string;
    class function fpuTamanhoFormatado(const ipTamanho: Int64): string;
    class procedure ppuAdicionarSmileysTela(const ipWidthParentSmileys: Integer; const ipOwnerAndParentSmileys: TWinControl; const ipImageCollectionItems: TcxImageCollectionItems; const ipOnClickSmileys: TNotifyEvent; var ioSmileysExpressaoRegular: string; var ioSmileys: TDictionary<string, string>);
    class procedure ppuConverterSmileysParaTexto(const ipRVE: TRichViewEdit);
    class procedure ppuConverterTextoParaSmileys(const ipRVE: TRichViewEdit; const ipDMChat: TDMChat; const ipSmileys: TDictionary<string, string>; const ipSmileysExpressaoRegular: string);
    class procedure ppuIncluirStatusMensagem(ipCelula: TRVTableCellData; const ipParagrafo: Integer; const ipCodigoLeitura: string; ipMsgLida: Boolean; const ipDMChat: TDMChat);
    class procedure ppuInserirSmileysRichViewEdit(const ipGraphic: TGraphic; const ipIdentificacao: string; const ipRVE: TRichViewEdit);
    class procedure ppuPreencherRichViewEdit(const ipMensagem: OleVariant; ipRVE: TRichViewEdit; const ipIdentificador: string; const ipPosicaoScroll: Integer; const ipDestacarTextoPesquisa: string;
      const ipExibirLinkVisualizacaoPesquisa, ipExibirLinkVoltarPesquisa, ipLimparRichViewEdit: Boolean; const ipCodigoMensagemDestacar: Integer; const ipEstilo: TChatEstiloRich;
      const ipDMChat: TDMChat; const ipSmileys: TDictionary<string, string>; const ipSmileysExpressaoRegular: string; const ipAoConfirmarLeituraMensagens: TChatConfirmarLeituraMensagens;
      const ipUsuarioLogado: TChatIdentificacaoUsuario; var ioDataUltimaMensagemRichView: TDateTime; var ioDadosConversas: TDictionary<string, TChatDadosConversa>; var ioCodigoPrimeiraMsgNaoLida: Integer);
    { Public declarations }
  end;

implementation

{ TChatAnexo }

constructor TChatAnexo.Create;
begin
  FArquivo := nil;
  FArquivoThumbnail := nil;
  FEndereco := '';
  FId := 0;
  FNome := '';
end;

destructor TChatAnexo.Destroy;
begin
  if Assigned(FArquivo) then
    FreeAndNil(FArquivo);

  if Assigned(FArquivoThumbnail) then
    FreeAndNil(FArquivoThumbnail);

  inherited Destroy;
end;

function TChatAnexo.GetExtencao: string;
begin
  Result := ExtractFileExt(FNome);
end;

function TChatAnexo.GetPropriedades: TChatAnexoPropriedades;
begin
  Result.FExtencao := Extencao;
  Result.FId := FId;
  Result.FNome := FNome;
  Result.FTamanho := Tamanho;
  Result.FTamanhoFormatado := TamanhoFormatado;
  Result.FTamanhoOriginal := TamanhoOriginal;
  Result.FTamanhoOriginalFtd := TamanhoOriginalFtd;
end;

function TChatAnexo.GetTamanho: Int64;
begin
  Result := 0;

  if Assigned(FArquivo) then
    Result := FArquivo.Size;
end;

function TChatAnexo.GetTamanhoFormatado: string;
begin
  Result := '0B';

  if Assigned(FArquivo) then
    Result := fpvTamanhoFormatado(FArquivo.Size);
end;

function TChatAnexo.GetTamanhoOriginalFtd: string;
begin
  Result := fpvTamanhoFormatado(FTamanhoOriginal);
end;

function TChatAnexo.fpvTamanhoFormatado(const ipTamanho: Int64): string;
const
  KB = 1024;
  MB = 1024 * KB;
  GB = 1024 * MB;
begin
  Result := '0B';

  if ipTamanho > 0 then
    begin
      case ipTamanho of
        0 .. (KB - 1):
          Result := FormatFloat(',0', ipTamanho) + 'B';
        KB .. (MB - 1):
          Result := FormatFloat(',0.00', ipTamanho / KB) + 'KB';
        MB .. (GB - 1):
          Result := FormatFloat(',0.00', ipTamanho / MB) + 'MB';
      else
        Result := FormatFloat(',0.00', ipTamanho / GB) + 'GB';
      end;
    end;
end;

procedure TChatAnexo.ppuAnexarArquivo(const ipArquivo: TFileStream;
  const ipArquivoThumbnail: TBytesStream; const ipNome: string;
  const ipTamanhoOriginal: Int64);
begin
  if Assigned(ipArquivo) then
    begin
      if not Assigned(FArquivo) then
        FArquivo := TBytesStream.Create;

      FArquivo.Clear;
      FArquivo.LoadFromStream(ipArquivo);

      if Assigned(ipArquivoThumbnail) then
        begin
          if not Assigned(FArquivoThumbnail) then
            FArquivoThumbnail := TBytesStream.Create;

          FArquivoThumbnail.Clear;
          FArquivoThumbnail.LoadFromStream(ipArquivoThumbnail);
        end
      else
        begin
          if Assigned(FArquivoThumbnail) then
            FreeAndNil(FArquivoThumbnail);
        end;

      FTamanhoOriginal := ipTamanhoOriginal;

      if ipNome = '' then
        FNome := ExtractFileName(ipArquivo.FileName)
      else
        FNome := ipNome;
    end
  else
    begin
      if Assigned(FArquivo) then
        FreeAndNil(FArquivo);

      if Assigned(FArquivoThumbnail) then
        FreeAndNil(FArquivoThumbnail);

      FNome := '';
      FTamanhoOriginal := 0;
    end;
end;

procedure TChatAnexo.ppuCopiarDe(const ipOrigem: TChatAnexo);
begin
  if Assigned(ipOrigem) then
    begin
      if Assigned(ipOrigem.FArquivo) then
        begin
          if Assigned(FArquivo) then
            FArquivo.Clear
          else
            FArquivo := TBytesStream.Create;

         ipOrigem.FArquivo.Position := 0;
         FArquivo.Position := 0;
         FArquivo.CopyFrom(ipOrigem.FArquivo, ipOrigem.FArquivo.Size);
         FArquivo.Position := 0;
         ipOrigem.FArquivo.Position := 0;
        end
      else
        begin
          if Assigned(FArquivo) then
            FreeAndNil(FArquivo);
        end;

      if Assigned(ipOrigem.FArquivoThumbnail) then
        begin
          if Assigned(FArquivoThumbnail) then
            FArquivoThumbnail.Clear
          else
            FArquivoThumbnail := TBytesStream.Create;

         ipOrigem.FArquivoThumbnail.Position := 0;
         FArquivoThumbnail.Position := 0;
         FArquivoThumbnail.CopyFrom(ipOrigem.FArquivoThumbnail, ipOrigem.FArquivoThumbnail.Size);
         FArquivoThumbnail.Position := 0;
         ipOrigem.FArquivoThumbnail.Position := 0;
        end
      else
        begin
          if Assigned(FArquivoThumbnail) then
            FreeAndNil(FArquivoThumbnail);
        end;

      FEndereco := ipOrigem.FEndereco;
      FId := ipOrigem.FId;
      FNome := ipOrigem.FNome;
      FTamanhoOriginal := ipOrigem.FTamanhoOriginal;
    end;
end;

procedure TChatAnexo.SetEndereco(const Value: string);
begin
  FEndereco := Value;
end;

{ TChatMensagem }

constructor TChatMensagem.Create;
begin
  FAnexos := nil;
  FAnexosLimite := 0;
  FAnexosNextId := 1;
  FAoAtingirLimiteAnexos := nil;
  FDestinatario.CodigoHospital := 0;
  FDestinatario.CodigoUsuario := 0;
  FMensagemRVF := nil;
  FRemetente.CodigoHospital := 0;
  FRemetente.CodigoUsuario := 0;
  FTipoMensagem := 0;
end;

destructor TChatMensagem.Destroy;
var
  i: Integer;
  vaChatAnexo: TChatAnexo;
begin
  if Assigned(FMensagemRVF) then
    FreeAndNil(FMensagemRVF);

  if Assigned(FAnexos) then
    begin
      for i := 0 to FAnexos.Count - 1 do
        begin
          vaChatAnexo := FAnexos.Items[i];

          if Assigned(vaChatAnexo) then
            FreeAndNil(vaChatAnexo);
        end;

      FreeAndNil(FAnexos);
    end;

  inherited Destroy;
end;

function TChatMensagem.fpuAnexarArquivos(const ipArquivos: TStrings): TArray<TChatAnexoPropriedades>;
  function ExtractTempDir: String;
  var
    vaBuffer : array[0..144] of Char;
  begin
    GetTempPath(144, vaBuffer);
    Result := IncludeTrailingPathDelimiter(StrPas(vaBuffer));
  end;

  function CompactarArquivo(ipArquivo, ipPastaDestino: string): string;
  var
    vaZip: TZipFile;
    vaNomeArquivo, vaDestino: string;
  begin
    vaZip := TZipFile.Create;

    try
      vaNomeArquivo := Copy(ExtractFileName(ipArquivo), 1, Pos(ExtractFileExt(ipArquivo), ExtractFileName(ipArquivo)) - 1) + '.zip';
      vaDestino := IncludeTrailingPathDelimiter(ipPastaDestino) + vaNomeArquivo;
      vaZip.Open(vaDestino, zmWrite); // Local e nome do arquivo compactado
      vaZip.Add(ipArquivo); // Compactando o arquivo
    finally
      FreeAndNil(vaZip);
    end;

    Result := vaDestino;
  end;

var
  vaPastaTemp, vaArquivo, vaArquivoCompactado, vaNomeArquivo: string;
  i, vaNewHeight, vaOldHeight, vaNewWidth, vaOldWidth: Integer;
  vaTamanhoOriginal: Int64;
  vaArquivoFileStream: TFileStream;
  vaThumbanilBytesStream: TBytesStream;
  vaAnexo: TChatAnexo;
  vaAnexosRecusados: TStringList;
  vadxSmartImage: TdxSmartImage;
  vaBitmap, vaBitmapThumbnail: TBitmap;
  vaJPEGImage: TJPEGImage;
begin
  SetLength(Result, 0);
  vaAnexosRecusados := TStringList.Create;

  if Assigned(ipArquivos) then
    begin
      if not Assigned(FAnexos) then
        FAnexos := TList<TChatAnexo>.Create;

      // Pegando a pasta temporária do Windows
      vaPastaTemp := ExtractTempDir + 'ProMedicoArquivosTemp';

      // Se não existir, então cria a pasa ProMedicoArquivosTemp dentro da pasta temporária do Windows
      if not DirectoryExists(vaPastaTemp) then
        CreateDir(vaPastaTemp);

      vaArquivoFileStream := nil;
      vaThumbanilBytesStream := nil;
      vaBitmap := nil;
      vaBitmapThumbnail := nil;
      vaJPEGImage := nil;

      try
        for vaArquivo in ipArquivos do
          begin
            if FileExists(vaArquivo) then
              begin
                vaTamanhoOriginal := 0;
                vaNomeArquivo := '';

                // Abrindo o arquivo, somente leitura, para pegar o tamanho e a extenção do arquivo antes da compactação
                try
                  vaArquivoFileStream := TFileStream.Create(vaArquivo, fmOpenRead);
                  vaTamanhoOriginal := vaArquivoFileStream.Size;
                  vaNomeArquivo := ExtractFileName(vaArquivo);
                finally
                  FreeAndNil(vaArquivoFileStream);
                end;

                try
                  try
                    try
                      // Criando um thumbnail do arquivo.
                      // Se a imagem possuir altura ou largura maior do que 100 pixels, ela será reduzida.
                      // Todo thumbnail será do tipo jpg.

                      vadxSmartImage := TdxSmartImage.Create;
                      vadxSmartImage.LoadFromFile(vaArquivo); // Se ocorrer erro na leitura do arquivo é porque não é uma imagem, nesse caso o thumbnail será nil
                      vaBitmap := vadxSmartImage.GetAsBitmap;
                      vaBitmapThumbnail := TBitmap.Create;

                      if (vaBitmap.Height > 100) or (vaBitmap.Width > 100) then
                        begin
                          vaOldHeight := vaBitmap.Height;
                          vaOldWidth := vaBitmap.Width;

                          if vaOldHeight >= vaOldWidth then
                            begin
                              vaNewHeight := 100;

                              if vaOldHeight = vaOldWidth then
                                vaNewWidth := vaNewHeight
                              else
                                vaNewWidth := Trunc(SimpleRoundTo(100 / vaOldHeight * vaOldWidth, 0));
                            end
                          else
                            begin
                              vaNewHeight := Trunc(SimpleRoundTo(100 / vaOldWidth * vaOldHeight, 0));
                              vaNewWidth := 100;
                            end;

                          vaBitmapThumbnail.Height := vaNewHeight;
                          vaBitmapThumbnail.Width := vaNewWidth;
                        end;

                      vaBitmapThumbnail.Canvas.StretchDraw(vaBitmapThumbnail.Canvas.ClipRect, vaBitmap);
                      vaJPEGImage := TJPEGImage.Create;
                      vaJPEGImage.Assign(vaBitmapThumbnail);
                      vaThumbanilBytesStream := TBytesStream.Create; // Não destruir esta variável neste "try", pois ela será utilizada logo abaixo na função ppuAnexarArquivo
                      vaJPEGImage.SaveToStream(vaThumbanilBytesStream);
                    except
                      on E: Exception do
                        begin
                          if Assigned(vaThumbanilBytesStream) then
                            FreeAndNil(vaThumbanilBytesStream);
                        end;
                    end;
                  finally
                    if Assigned(vadxSmartImage) then
                      FreeAndNil(vadxSmartImage);

                    if Assigned(vaBitmap) then
                      FreeAndNil(vaBitmap);

                    if Assigned(vaBitmapThumbnail) then
                      FreeAndNil(vaBitmapThumbnail);

                    if Assigned(vaJPEGImage) then
                      FreeAndNil(vaJPEGImage);
                  end;

                  // Compactando o arquivo
                  vaArquivoCompactado := CompactarArquivo(vaArquivo, vaPastaTemp);

                  // Abrindo o arquivo compactado
                  vaArquivoFileStream := TFileStream.Create(vaArquivoCompactado, fmOpenRead);

                  // Verificando se há espaço suficiente para anexar o arquivo
                  if (FAnexosLimite >= (AnexosTotal + vaArquivoFileStream.Size)) or (FAnexosLimite <= 0) then
                    begin
                      // Anexando o arquivo
                      vaAnexo := TChatAnexo.Create;
                      vaAnexo.ppuAnexarArquivo(vaArquivoFileStream, vaThumbanilBytesStream, vaNomeArquivo, vaTamanhoOriginal);

                      // Adicionando um identificador e adicionando o anexo na lista de anexos
                      vaAnexo.FId := FAnexosNextId;
                      Inc(FAnexosNextId);
                      FAnexos.Add(vaAnexo);

                      // Adicionando as informações do arquivo no array de retorno
                      i := Length(Result);
                      SetLength(Result, i + 1);
                      Result[i] := vaAnexo.Propriedades;
                    end
                  else
                    // Arquivo não anexado
                    vaAnexosRecusados.Add(vaArquivo);
                finally
                  if Assigned(vaArquivoFileStream) then
                    FreeAndNil(vaArquivoFileStream);

                  if Assigned(vaThumbanilBytesStream) then
                    FreeAndNil(vaThumbanilBytesStream);
                end;

                if FileExists(vaArquivoCompactado) then
                  DeleteFile(PChar(vaArquivoCompactado));
              end;
          end;
      finally
        if FAnexos.Count = 0 then
          FreeAndNil(FAnexos);
      end;
    end;

  // Se atingiu o limite, então vamos disparar o evento de limite atingido
  try
    if Assigned(FAoAtingirLimiteAnexos) and (vaAnexosRecusados.Count > 0) then
      FAoAtingirLimiteAnexos(vaAnexosRecusados);
  finally
    FreeAndNil(vaAnexosRecusados);
  end;
end;

function TChatMensagem.fpuDeletarAnexo(const ipId: Integer): Boolean;
var
  i: Integer;
  vaAnexo: TChatAnexo;
begin
  Result := False;
  i := fpvRetornaIndiceAnexo(ipId);

  if i >= 0 then
    begin
      vaAnexo := FAnexos.Items[i];
      FreeAndNil(vaAnexo);
      FAnexos.Delete(i);
      Result := True;
    end;
end;

function TChatMensagem.fpuPropriedadeAnexo(
  const ipId: Integer): TChatAnexoPropriedades;
var
  i: Integer;
begin
  Result.FExtencao := '';
  Result.FId := 0;
  Result.FNome := '';
  Result.FTamanho := 0;
  Result.FTamanhoFormatado := '0B';
  i := fpvRetornaIndiceAnexo(ipId);

  if i >= 0 then
    Result := FAnexos.Items[i].Propriedades;
end;

function TChatMensagem.fpvRetornaIndiceAnexo(const ipId: Integer): Integer;
var
  i: Integer;
begin
  Result := -1;

  if Assigned(FAnexos) then
    begin
      i := 0;

      while (i < FAnexos.Count) and (Result = -1) do
        begin
          if Assigned(FAnexos.Items[i]) and (FAnexos.Items[i].Id = ipId) then
            Result := i;

          Inc(i);
        end;
    end;
end;

function TChatMensagem.fpvRetornaStreamFormatado(
  const ipFormato: TChatFormatoStream): TBytesStream;
var
  vaRvEdit: TRichViewEdit;
  vaRvStyle: TRVStyle;
begin
  Result := nil;
  vaRvEdit := nil;
  vaRvStyle := nil;

  try
    if Assigned(FMensagemRVF) then
      begin
        if (ipFormato in [ftHtml, ftTxt]) then
          Result := TStringStream.Create
        else
          Result := TBytesStream.Create;

        FMensagemRVF.Position := 0;

        if ipFormato <> ftRvf then
          begin
            vaRvStyle := TRVStyle.Create(nil);

            vaRvEdit := TRichViewEdit.Create(nil);
            vaRvEdit.Style := vaRvStyle;
            vaRvEdit.Clear;
            vaRvEdit.LoadRVFFromStream(FMensagemRVF);
            vaRvEdit.Change;
          end;

        case ipFormato of
          ftDocx: vaRvEdit.SaveDocXToStream(Result, False);
          ftHtml: vaRvEdit.SaveHTMLToStream(Result, '', '', '', []);
          ftRtf: vaRvEdit.SaveRTFToStream(Result, False);
          ftRvf: Result.LoadFromStream(FMensagemRVF);
          ftTxt: vaRvEdit.SaveTextToStream('', Result, 0, False, True);
        end;
      end;
  finally
    if Assigned(vaRvEdit) then
      FreeAndNil(vaRvEdit);

    if Assigned(vaRvStyle) then
      FreeAndNil(vaRvStyle);
  end;
end;

function TChatMensagem.fpvRetornaString(
  const ipFormato: TChatFormatoStream): string;
var
  vaStringStream: TStringStream;
begin
  Result := '';

  try
    if ipFormato = ftHtml then
      vaStringStream := TStringStream(fpvRetornaStreamFormatado(ftHtml))
    else
      vaStringStream := TStringStream(fpvRetornaStreamFormatado(ftTxt));

    if Assigned(vaStringStream) then
      begin
        vaStringStream.Position := 0;
        Result := vaStringStream.ReadString(vaStringStream.Size);
      end;
  finally
    if Assigned(vaStringStream) then
      FreeAndNil(vaStringStream);
  end;
end;

function TChatMensagem.GetAnexosPropriedades: TArray<TChatAnexoPropriedades>;
var
  i: Integer;
begin
  SetLength(Result, 0);

  if Assigned(FAnexos) then
    begin
      SetLength(Result, FAnexos.Count);

      for i := 0 to FAnexos.Count - 1 do
        Result[i] := FAnexos.Items[i].Propriedades;
    end;
end;

function TChatMensagem.GetAnexosQtde: Integer;
begin
  Result := 0;

  if Assigned(FAnexos) then
    Result := FAnexos.Count;
end;

function TChatMensagem.GetAnexosTotal: Int64;
var
  i: Integer;
begin
  Result := 0;

  if Assigned(FAnexos) then
    begin
      for i := 0 to FAnexos.Count - 1 do
        Result := Result + FAnexos.Items[i].Tamanho;
    end;
end;

function TChatMensagem.GetMensagemDOCX: TBytesStream;
begin
  Result := fpvRetornaStreamFormatado(ftDocx);
end;

function TChatMensagem.GetMensagemHTML: string;
begin
  Result := fpvRetornaString(ftHtml);
end;

function TChatMensagem.GetMensagemRTF: TBytesStream;
begin
  Result := fpvRetornaStreamFormatado(ftRtf);
end;

function TChatMensagem.GetMensagemRVF: TBytesStream;
begin
  Result := fpvRetornaStreamFormatado(ftRvf);
end;

function TChatMensagem.GetMensagemTXT: string;
begin
  Result := fpvRetornaString(ftTxt);
end;

procedure TChatMensagem.ppuCopiarDe(const ipOrigem: TChatMensagem);
var
  i: Integer;
  vaChatAnexo: TChatAnexo;
begin
  if Assigned(ipOrigem) then
    begin
      ppuLimparAnexos;
      ppuLimparMensagem;

      if Assigned(ipOrigem.FAnexos) then
        begin
          FAnexos := TList<TChatAnexo>.Create;

          for i := 0 to ipOrigem.FAnexos.Count - 1 do
            begin
              vaChatAnexo := TChatAnexo.Create;
              vaChatAnexo.ppuCopiarDe(ipOrigem.FAnexos.Items[i]);
              FAnexos.Add(vaChatAnexo);
            end;
        end;

      FAnexosLimite := ipOrigem.FAnexosLimite;
      FAnexosNextId := ipOrigem.FAnexosNextId;
      FAoAtingirLimiteAnexos := ipOrigem.FAoAtingirLimiteAnexos;
      FDestinatario.ppuCopiarDe(ipOrigem.Destinatario);

      if Assigned(ipOrigem.FMensagemRVF) then
        begin
          FMensagemRVF := TBytesStream.Create;
          ipOrigem.FMensagemRVF.Position := 0;
          FMensagemRVF.Position := 0;
          FMensagemRVF.CopyFrom(ipOrigem.FMensagemRVF, ipOrigem.FMensagemRVF.Size);
          FMensagemRVF.Position := 0;
          ipOrigem.FMensagemRVF.Position := 0;
        end;

      FRemetente.ppuCopiarDe(ipOrigem.Remetente);
      FTipoMensagem := ipOrigem.FTipoMensagem;
    end;
end;

procedure TChatMensagem.ppuLimparAnexos;
var
  vaAnexo: TChatAnexo;
  i: Integer;
begin
  if Assigned(FAnexos) then
    begin
      for i := 0 to FAnexos.Count - 1 do
        begin
          vaAnexo := FAnexos.Items[i];

          if Assigned(vaAnexo) then
            FreeAndNil(vaAnexo);
        end;

      FreeAndNil(FAnexos);
    end;
end;

procedure TChatMensagem.ppuLimparMensagem;
begin
  if Assigned(FMensagemRVF) then
    FreeAndNil(FMensagemRVF);
end;

procedure TChatMensagem.ppvCarrearStream(const ipFormato: TChatFormatoStream;
  const ipBytesStream: TBytesStream);
var
  vaRvEdit: TRichViewEdit;
  vaRvStyle: TRVStyle;
begin
  vaRvEdit := nil;
  vaRvStyle := nil;

  try
    if not Assigned(ipBytesStream) then
      begin
        if Assigned(FMensagemRVF) then
          FreeAndNil(FMensagemRVF);
      end
    else
      begin
        if Assigned(FMensagemRVF) then
          FMensagemRVF.Clear
        else
          FMensagemRVF := TBytesStream.Create;

        ipBytesStream.Position := 0;

        if ipFormato = ftRvf then
          FMensagemRVF.LoadFromStream(ipBytesStream)
        else
          begin
            vaRvStyle := TRVStyle.Create(nil);

            vaRvEdit := TRichViewEdit.Create(nil);
            vaRvEdit.Style := vaRvStyle;
            vaRvEdit.Clear;

            case ipFormato of
              ftRtf: vaRvEdit.LoadRTFFromStream(ipBytesStream);
              ftTxt: vaRvEdit.LoadTextFromStream(ipBytesStream, 0, 0, True);
            end;

            vaRvEdit.Change;
            vaRvEdit.SaveRVFToStream(FMensagemRVF, False);
          end;
      end;
  finally
    if Assigned(vaRvEdit) then
      FreeAndNil(vaRvEdit);

    if Assigned(vaRvStyle) then
      FreeAndNil(vaRvStyle);
  end;
end;

procedure TChatMensagem.SetAnexosLimite(const Value: Int64);
begin
  if Value < 0 then
    FAnexosLimite := 0
  else
    FAnexosLimite := Value;
end;

procedure TChatMensagem.SetAoAtingirLimiteAnexos(
  const Value: TChatAnexoLimiteAtingido);
begin
  FAoAtingirLimiteAnexos := Value;
end;

procedure TChatMensagem.SetDestinatario(const Value: TChatIdentificacaoUsuario);
begin
  FDestinatario.ppuCopiarDe(Value);
end;

procedure TChatMensagem.SetMensagemRTF(const Value: TBytesStream);
begin
  ppvCarrearStream(ftRtf, Value);
end;

procedure TChatMensagem.SetMensagemRVF(const Value: TBytesStream);
begin
  ppvCarrearStream(ftRvf, Value);
end;

procedure TChatMensagem.SetMensagemTXT(const Value: string);
var
  vaStringStream: TStringStream;
begin
  if Value = '' then
    begin
      if Assigned(FMensagemRVF) then
        FreeAndNil(FMensagemRVF);
    end
  else
    begin
      vaStringStream := TStringStream.Create(Value);

      try
        ppvCarrearStream(ftTxt, vaStringStream);
      finally
        if Assigned(vaStringStream) then
          FreeAndNil(vaStringStream);
      end;
    end;
end;

procedure TChatMensagem.SetRemetente(const Value: TChatIdentificacaoUsuario);
begin
  FRemetente.ppuCopiarDe(Value);
end;

procedure TChatMensagem.SetTipoMensagem(const Value: Integer);
begin
  FTipoMensagem := Value;
end;

{ TChatUsuario }

constructor TChatUsuario.Create;
begin
  FIdentificacaoUsuario.CodigoUsuario := 0;
  FIdentificacaoUsuario.CodigoHospital := 0;
  FEMail := '';
  FFoto := nil;
  FFotoThumbnail := nil;
  FFuncao := '';
  SetLength(FGrupoUsuarios, 0);
  FNome := '';
  FPromedico := 0;
  FStatus := 0;
  FUsuarioGrupo := 0;
end;

destructor TChatUsuario.Destroy;
begin
  if Assigned(FFoto) then
    FreeAndNil(FFoto);

  if Assigned(FFotoThumbnail) then
    FreeAndNil(FFotoThumbnail);

  inherited;
end;

procedure TChatUsuario.ppuCopiarDe(const ipOrigem: TChatUsuario);
var
  i: Integer;
begin
  FAtivoInativo := ipOrigem.FAtivoInativo;
  FEMail := ipOrigem.FEMail;

  if Assigned(ipOrigem.FFoto) then
    begin
      if not Assigned(FFoto) then
        FFoto := TPicture.Create;

      FFoto.Assign(ipOrigem.FFoto);
    end
  else
    begin
      if Assigned(FFoto) then
        FreeAndNil(FFoto);
    end;

  if Assigned(ipOrigem.FFotoThumbnail) then
    begin
      if not Assigned(FFotoThumbnail) then
        FFotoThumbnail := TPicture.Create;

      FFotoThumbnail.Assign(ipOrigem.FFotoThumbnail);
    end
  else
    begin
      if Assigned(FFotoThumbnail) then
        FreeAndNil(FFotoThumbnail);
    end;

  FFuncao := ipOrigem.FFuncao;

  SetLength(FGrupoUsuarios, Length(ipOrigem.FGrupoUsuarios));

  for i := Low(ipOrigem.FGrupoUsuarios) to High(ipOrigem.FGrupoUsuarios) do
    FGrupoUsuarios[i] := ipOrigem.FGrupoUsuarios[i];

  FIdentificacaoUsuario.ppuCopiarDe(ipOrigem.FIdentificacaoUsuario);
  FNome := ipOrigem.FNome;
  FPromedico := ipOrigem.FPromedico;
  FStatus := ipOrigem.FStatus;
  FUsuarioGrupo := ipOrigem.FUsuarioGrupo;
end;

procedure TChatUsuario.SetAtivoInativo(const Value: Integer);
begin
  FAtivoInativo := Value;
end;

procedure TChatUsuario.SetEMail(const Value: string);
begin
  FEMail := Value;
end;

procedure TChatUsuario.SetFoto(const Value: TPicture);
begin
  if Assigned(Value) then
    begin
      if not Assigned(FFoto) then
        FFoto := TPicture.Create;

      FFoto.Assign(Value);
    end
  else
    begin
      if Assigned(FFoto) then
        FreeAndNil(FFoto);
    end;
end;

procedure TChatUsuario.SetFotoThumbnail(const Value: TPicture);
begin
  if Assigned(Value) then
    begin
      if not Assigned(FFotoThumbnail) then
        FFotoThumbnail := TPicture.Create;

      FFotoThumbnail.Assign(Value);
    end
  else
    begin
      if Assigned(FFotoThumbnail) then
        FreeAndNil(FFotoThumbnail);
    end;
end;

procedure TChatUsuario.SetFuncao(const Value: string);
begin
  FFuncao := Value;
end;

procedure TChatUsuario.SetGrupoUsuarios(const Value: TArray<Integer>);
var
  i: Integer;
begin
  SetLength(FGrupoUsuarios, Length(Value));

  for i := Low(Value) to High(Value) do
    FGrupoUsuarios[i] := Value[i];
end;

procedure TChatUsuario.SetIdentificacaoUsuario(
  const Value: TChatIdentificacaoUsuario);
begin
  FIdentificacaoUsuario.ppuCopiarDe(Value);
end;

procedure TChatUsuario.SetNome(const Value: string);
begin
  FNome := Value;
end;

procedure TChatUsuario.SetPromedico(const Value: Integer);
begin
  FPromedico := Value;
end;

procedure TChatUsuario.SetStatus(const Value: Integer);
begin
  FStatus := Value;
end;

procedure TChatUsuario.SetUsuarioGrupo(const Value: Integer);
begin
  FUsuarioGrupo := Value;
end;

{ TChatStatus }

procedure TChatStatus.ppuCopiarDe(const ipOrigem: TChatStatus);
begin
  FIdentificacaoUsuario.ppuCopiarDe(ipOrigem.FIdentificacaoUsuario);
  FStatus := ipOrigem.FStatus;
end;

procedure TChatStatus.SetIdentificacaoUsuario(
  const Value: TChatIdentificacaoUsuario);
begin
  FIdentificacaoUsuario.ppuCopiarDe(Value);
end;

procedure TChatStatus.SetStatus(const Value: Integer);
begin
  FStatus := Value;
end;

{ TChatHospital }

procedure TChatHospital.ppuCopiarDe(const ipOrigem: TChatHospital);
begin
  FCodigo := ipOrigem.FCodigo;
  FNomeFantasia := ipOrigem.FNomeFantasia;
  FRazaoSocial := ipOrigem.FRazaoSocial;
end;

procedure TChatHospital.SetCodigo(const Value: Integer);
begin
  FCodigo := Value;
end;

procedure TChatHospital.SetNomeFantasia(const Value: string);
begin
  FNomeFantasia := Value;
end;

procedure TChatHospital.SetRazaoSocial(const Value: string);
begin
  FRazaoSocial := Value;
end;

{ TChatIdentificacaoUsuario }

procedure TChatIdentificacaoUsuario.ppuCopiarDe(
  const ipOrigem: TChatIdentificacaoUsuario);
begin
  FCodigoUsuario := ipOrigem.FCodigoUsuario;
  FCodigoHospital := ipOrigem.FCodigoHospital;
end;

procedure TChatIdentificacaoUsuario.SetCodigoHospital(const Value: Integer);
begin
  FCodigoHospital := Value;
end;

procedure TChatIdentificacaoUsuario.SetCodigoUsuario(const Value: Integer);
begin
  FCodigoUsuario := Value;
end;

{ TChatUsuarioLogado }

procedure TChatUsuarioLogado.ppuCopiarDe(const ipOrigem: TChatUsuarioLogado);
begin
  FEnviaMensagemGrupoTodos := ipOrigem.FEnviaMensagemGrupoTodos;
  FIdentificacaoUsuario.ppuCopiarDe(ipOrigem.FIdentificacaoUsuario);
end;

procedure TChatUsuarioLogado.SetEnviaMensagemGrupoTodos(const Value: Boolean);
begin
  FEnviaMensagemGrupoTodos := Value;
end;

procedure TChatUsuarioLogado.SetIdentificacaoUsuario(
  const Value: TChatIdentificacaoUsuario);
begin
  FIdentificacaoUsuario.ppuCopiarDe(Value);
end;

{ TChatConfiguracoes }

constructor TChatConfiguracoes.Create;
begin
  FEMail := '';
  FFonteNome := 'Arial';
  FFonteTamanho := 10;
  FFoto := nil;
  FNovasMensagensApenasAlerta := 0;
  FPermitirAlterarAlertaMensagens := False;
  FTelefone := '';
end;

procedure TChatConfiguracoes.ppuCopiarDe(const ipOrigem: TChatConfiguracoes);
begin
  FEMail := ipOrigem.FEMail;
  FFonteNome := ipOrigem.FFonteNome;
  FFonteTamanho := ipOrigem.FFonteTamanho;

  if Assigned(ipOrigem.FFoto) then
    begin
      if not Assigned(FFoto) then
        FFoto := TPicture.Create;

      FFoto.Assign(ipOrigem.FFoto);
    end
  else
    begin
      if Assigned(FFoto) then
        FreeAndNil(FFoto);
    end;

  FNovasMensagensApenasAlerta := ipOrigem.FNovasMensagensApenasAlerta;
  FPermitirAlterarAlertaMensagens := ipOrigem.FPermitirAlterarAlertaMensagens;
  FTelefone := ipOrigem.FTelefone;
end;

procedure TChatConfiguracoes.SetEMail(const Value: string);
begin
  FEMail := Value;
end;

procedure TChatConfiguracoes.SetFonteNome(const Value: string);
begin
  FFonteNome := Value;
end;

procedure TChatConfiguracoes.SetFonteTamanho(const Value: Integer);
begin
  FFonteTamanho := Value;
end;

procedure TChatConfiguracoes.SetFoto(const Value: TPicture);
begin
  if Assigned(Value) then
    begin
      if not Assigned(FFoto) then
        FFoto := TPicture.Create;

      FFoto.Assign(Value);
    end
  else
    begin
      if Assigned(FFoto) then
        FreeAndNil(FFoto);
    end;
end;

procedure TChatConfiguracoes.SetNovasMensagensApenasAlerta(
  const Value: Integer);
begin
  FNovasMensagensApenasAlerta := Value;
end;

procedure TChatConfiguracoes.SetPermitirAlterarAlertaMensagens(
  const Value: Boolean);
begin
  FPermitirAlterarAlertaMensagens := Value;
end;

procedure TChatConfiguracoes.SetTelefone(const Value: string);
begin
  FTelefone := Value;
end;

{ TChatConversa }

procedure TChatConversa.ppuCopiarDe(const ipOrigem: TChatConversa);
begin
  FIdentificacaoUsuario.ppuCopiarDe(ipOrigem.FIdentificacaoUsuario);
  FNotificar := ipOrigem.FNotificar;
  FSelecionar := ipOrigem.FSelecionar;
end;

procedure TChatConversa.SetIdentificacaoUsuario(
  const Value: TChatIdentificacaoUsuario);
begin
  FIdentificacaoUsuario.ppuCopiarDe(Value);
end;

procedure TChatConversa.SetNotificar(const Value: Boolean);
begin
  FNotificar := Value;
end;

procedure TChatConversa.SetSelecionar(const Value: Boolean);
begin
  FSelecionar := Value;
end;

{ TChatDadosConversa }

procedure TChatDadosConversa.ppuCopiarDe(const ipOrigem: TChatDadosConversa);
begin
  FAnexos := ipOrigem.FAnexos;
  FMensagens := ipOrigem.FMensagens;
  FPosicaoScroll := ipOrigem.FPosicaoScroll;
end;

procedure TChatDadosConversa.SetAnexos(const Value: OleVariant);
begin
  FAnexos := Value;
end;

procedure TChatDadosConversa.SetMensagens(const Value: OleVariant);
begin
  FMensagens := Value;
end;

procedure TChatDadosConversa.SetPosicaoScroll(const Value: Integer);
begin
  FPosicaoScroll := Value;
end;

{ TChatDadosPesquisa }

constructor TChatDadosPesquisa.Create;
begin
  FDadosConversa.Anexos := null;
  FDadosConversa.Mensagens := null;
  FDadosConversa.PosicaoScroll := 0;
  FDataInicial := 0;
  FDataFinal := 0;
  FFotoUsuario := nil;
  FIdentificador := '';
  FNomeHospital := '';
  FNomeFuncao := '';
  FNomeUsuario := '';
  FPesquisarData := False;
  FTexto := '';
end;

destructor TChatDadosPesquisa.Destroy;
begin
  if Assigned(FFotoUsuario) then
    FreeAndNil(FFotoUsuario);

  inherited;
end;

procedure TChatDadosPesquisa.ppuCopiarDe(const ipOrigem: TChatDadosPesquisa);
begin
  FDadosConversa.ppuCopiarDe(ipOrigem.FDadosConversa);
  FDataInicial := ipOrigem.FDataInicial;
  FDataFinal := ipOrigem.FDataFinal;

  if Assigned(ipOrigem.FFotoUsuario) then
    begin
      if not Assigned(FFotoUsuario) then
        FFotoUsuario := TPicture.Create;

      FFotoUsuario.Assign(ipOrigem.FFotoUsuario);
    end
  else
    begin
      if Assigned(FFotoUsuario) then
        FreeAndNil(FFotoUsuario);
    end;

  FIdentificador := ipOrigem.FIdentificador;
  FNomeHospital := ipOrigem.FNomeHospital;
  FNomeFuncao := ipOrigem.FNomeFuncao;
  FNomeUsuario := ipOrigem.FNomeUsuario;
  FPesquisarData := ipOrigem.FPesquisarData;
  FTexto := ipOrigem.FTexto;
end;

procedure TChatDadosPesquisa.SetDadosConversa(const Value: TChatDadosConversa);
begin
  FDadosConversa.ppuCopiarDe(Value);
end;

procedure TChatDadosPesquisa.SetDataFinal(const Value: TDate);
begin
  FDataFinal := Value;
end;

procedure TChatDadosPesquisa.SetDataInicial(const Value: TDate);
begin
  FDataInicial := Value;
end;

procedure TChatDadosPesquisa.SetFotoUsuario(const Value: TPicture);
begin
  if Assigned(Value) then
    begin
      if not Assigned(FFotoUsuario) then
        FFotoUsuario := TPicture.Create;

      FFotoUsuario.Assign(Value);
    end
  else
    begin
      if Assigned(FFotoUsuario) then
        FreeAndNil(FFotoUsuario);
    end;
end;

procedure TChatDadosPesquisa.SetIdentificador(const Value: string);
begin
  FIdentificador := Value;
end;

procedure TChatDadosPesquisa.SetNomeFuncao(const Value: string);
begin
  FNomeFuncao := Value;
end;

procedure TChatDadosPesquisa.SetNomeHospital(const Value: string);
begin
  FNomeHospital := Value;
end;

procedure TChatDadosPesquisa.SetNomeUsuario(const Value: string);
begin
  FNomeUsuario := Value;
end;

procedure TChatDadosPesquisa.SetPesquisarData(const Value: Boolean);
begin
  FPesquisarData := Value;
end;

procedure TChatDadosPesquisa.SetTexto(const Value: String);
begin
  FTexto := Value;
end;

{ TChatAnexoPropriedades }

procedure TChatAnexoPropriedades.ppuCopiarDe(
  const ipOrigem: TChatAnexoPropriedades);
begin
  FExtencao := ipOrigem.FExtencao;
  FId := ipOrigem.FId;
  FNome := ipOrigem.FNome;
  FTamanho := ipOrigem.FTamanho;
  FTamanhoFormatado := ipOrigem.FTamanhoFormatado;
  FTamanhoOriginal := ipOrigem.FTamanhoOriginal;
  FTamanhoOriginalFtd := ipOrigem.FTamanhoOriginalFtd;
end;

{ TChatDadosUsuario }

constructor TChatDadosUsuario.Create;
begin
  FFotoUsuario := nil;
  FIdentificacao.CodigoUsuario := 0;
  FIdentificacao.CodigoUsuario := 0;
  FNome := '';
end;

destructor TChatDadosUsuario.Destroy;
begin
  if Assigned(FFotoUsuario) then
    FreeAndNil(FFotoUsuario);

  inherited;
end;

procedure TChatDadosUsuario.ppuCopiarDe(const ipOrigem: TChatDadosUsuario);
begin
  if Assigned(ipOrigem.FotoUsuario) then
    begin
      if not Assigned(FFotoUsuario) then
        FFotoUsuario := TPicture.Create;

      FFotoUsuario.Assign(ipOrigem.FFotoUsuario);
    end
  else
    begin
      if Assigned(FFotoUsuario) then
        FreeAndNil(FFotoUsuario);
    end;

  FIdentificacao.ppuCopiarDe(ipOrigem.FIdentificacao);
  FNome := ipOrigem.FNome;
end;

procedure TChatDadosUsuario.SetFotoUsuario(const Value: TPicture);
begin
  if Assigned(Value) then
    begin
      if not Assigned(FFotoUsuario) then
        FFotoUsuario := TPicture.Create;

      FFotoUsuario.Assign(Value);
    end
  else
    begin
      if Assigned(FFotoUsuario) then
        FreeAndNil(FFotoUsuario);
    end;
end;

procedure TChatDadosUsuario.SetIdentificacao(
  const Value: TChatIdentificacaoUsuario);
begin
  FIdentificacao.ppuCopiarDe(Value);
end;

procedure TChatDadosUsuario.SetNome(const Value: string);
begin
  FNome := Value;
end;

{ TChatFuncoes }

class function TChatFuncoes.fpuCodigoHospital(
  const ipIdentificador: string): Integer;
begin
  Result := StrToIntDef(TRegEx.Replace(TRegEx.Match(ipIdentificador, '(?<=_)n?\d{1,}$', [roIgnoreCase, roSingleLine]).Value, '^n', '-', [roIgnoreCase, roSingleLine]), 0);
end;

class function TChatFuncoes.fpuCodigosUsuarioHospital(
  const ipIdentificador: string): Variant;
begin
  Result := VarArrayOf([fpuCodigoUsuario(ipIdentificador), fpuCodigoHospital(ipIdentificador)]);
end;

class function TChatFuncoes.fpuCodigoUsuario(
  const ipIdentificador: string): Integer;
begin
  Result := StrToIntDef(TRegEx.Replace(TRegEx.Match(ipIdentificador, '^n?\d{1,}(?=_)', [roIgnoreCase, roSingleLine]).Value, '^n', '-', [roIgnoreCase, roSingleLine]), 0);
end;

class function TChatFuncoes.fpuFindGraphicClass(const ipBuffer;
  const ipBufferSize: Int64; out ioGraphicClass: TGraphicClass): Boolean;
var
  vaLongWords: array [Byte] of LongWord absolute ipBuffer;
  vaWords: array [Byte] of Word absolute ipBuffer;
begin
  ioGraphicClass := nil;
  Result := False;

  if ipBufferSize < coMinGraphicSize then
    Exit;

  case vaWords[0] of
    $4D42:
      ioGraphicClass := TBitmap;
    $D8FF:
      ioGraphicClass := TJPEGImage;
    $4949:
      if vaWords[1] = $002A then
        ioGraphicClass := TWicImage; // i.e., TIFF
    $4D4D:
      if vaWords[1] = $2A00 then
        ioGraphicClass := TWicImage; // i.e., TIFF
  else
    if Int64(ipBuffer) = $A1A0A0D474E5089 then
      ioGraphicClass := TPNGImage
    else
      begin
        if vaLongWords[0] = $9AC6CDD7 then
          ioGraphicClass := TMetafile
        else
          begin
            if (vaLongWords[0] = 1) and (vaLongWords[10] = $464D4520) then
              ioGraphicClass := TMetafile
            else
              begin
                if System.AnsiStrings.StrLComp(PAnsiChar(@ipBuffer), 'GIF', 3) = 0 then
                  ioGraphicClass := TGIFImage
                else
                  begin
                    if vaWords[1] = 1 then
                      ioGraphicClass := TIcon;
                  end;
              end;
          end;
      end;
  end;

  Result := (ioGraphicClass <> nil);
end;

class function TChatFuncoes.fpuFindGraphicClass(const ipStream: TStream;
  out ioGraphicClass: TGraphicClass): Boolean;
var
  vaBuffer: PByte;
  vaCurPos: Int64;
  vaBytesRead: Integer;
begin
  if ipStream is TCustomMemoryStream then
    begin
      vaBuffer := TCustomMemoryStream(ipStream).Memory;
      vaCurPos := ipStream.Position;
      Inc(vaBuffer, vaCurPos);
      Result := fpuFindGraphicClass(vaBuffer^, ipStream.Size - vaCurPos, ioGraphicClass);
    end
  else
    begin
      GetMem(vaBuffer, coMinGraphicSize);

      try
        vaBytesRead := ipStream.Read(vaBuffer^, coMinGraphicSize);
        ipStream.Seek(-vaBytesRead, soCurrent);
        Result := fpuFindGraphicClass(vaBuffer^, vaBytesRead, ioGraphicClass);
      finally
        FreeMem(vaBuffer);
      end;
    end;
end;

class function TChatFuncoes.fpuIconeArquivo(
  const ipExtensaoArquivo: string; const ipDMChat: TDMChat): TPicture;
var
  vaImagemSelecionada: TPicture;
  vaBytesStream: TBytesStream;
  vaGraphic: TGraphic;
begin
  Result := TPicture.Create;
  vaBytesStream := nil;

  // Retornando o ícone de acordo com a extensão do arquivo

  // Excel - csv, ods, prn, slsm, xla, xlam, xls, xlsb, xlsx, xlt, xltm, xltx, xps
  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(csv|ods|prn|slsm|xlam?|xls(b|x)?|xlt(m|x)?|xps)$', [roIgnoreCase, roSingleLine]) then
    vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoExcel.Picture
  else
    begin
      // Word - doc, docm, docx, dot, dotm, dotx, odt, rtf
      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(do(c|t)(m|x)?|rtf|odt)$', [roIgnoreCase, roSingleLine]) then
        vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoWord.Picture
      else
        begin
          // Power Point - odp, pot, potm, potx, ppam, ppa, pps, ppsm, ppsx, ppt, pptm, pptx
          if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(odp|pot(m|x)?|ppam?|pp(s|t)(m|x)?)$', [roIgnoreCase, roSingleLine]) then
            vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoPowerPoint.Picture
          else
            begin
              // Texto - TXT
              if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(txt)$', [roIgnoreCase, roSingleLine]) then
                vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoTexto.Picture
              else
                begin
                  // PDF
                  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?pdf$', [roIgnoreCase, roSingleLine]) then
                    vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoPDF.Picture
                  else
                    begin
                      // RAR
                      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?rar$', [roIgnoreCase, roSingleLine]) then
                        vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoRar.Picture
                      else
                        begin
                          // ZIP
                          if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?zip$', [roIgnoreCase, roSingleLine]) then
                            vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoZip.Picture
                          else
                            begin
                              // XML
                              if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(xml)$', [roIgnoreCase, roSingleLine]) then
                                vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoXML.Picture
                              else
                                begin
                                  // Configuração - DLL, INI, SYS
                                  if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(dll|ini|sys)$', [roIgnoreCase, roSingleLine]) then
                                    vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoConfiguracao.Picture
                                  else
                                    begin
                                      // Música - aac, ac3, mid, mp3, ogg, wav, wma
                                      if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(aac|ac3|mid|mp3|ogg|wav|wma)$', [roIgnoreCase, roSingleLine]) then
                                        vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoAudio.Picture
                                      else
                                        begin
                                          // Vídeo - avi, mkv, mov, mp4, mpeg, mpg, rm, rmvb, wmv
                                          if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(avi|mkv|mov|mp4|mpeg|mpg|rm|rmvb|wmv)$', [roIgnoreCase, roSingleLine]) then
                                            vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoVideo.Picture
                                          else
                                            begin
                                              // vaBitmap - bmp, eps, gif, ico, jpeg, jpg, pic, png
                                              if TRegEx.IsMatch(ipExtensaoArquivo, '^\.?(bmp|eps|gif|ico|jpe?g|pic|png)$', [roIgnoreCase, roSingleLine]) then
                                                vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoImagem.Picture
                                              else
                                                // Outros arquivos
                                                vaImagemSelecionada := ipDMChat.ImgCollectionItemArquivoDesconhecido.Picture;
                                            end;
                                        end;
                                    end;
                                end;
                            end;
                        end;
                    end;
                end;
            end;
        end;
    end;

  try
    vaBytesStream := TBytesStream.Create;
    vaImagemSelecionada.Graphic.SaveToStream(vaBytesStream);
    vaBytesStream.Position := 0;
    Result.Graphic := fpuImagem(vaBytesStream, TWICImageFormat.wifPng);
  finally
    if Assigned(vaBytesStream) then
      FreeAndNil(vaBytesStream);
  end;
end;

class function TChatFuncoes.fpuImagem(const ipBytesStream: TBytesStream;
  const ipFormatoSecundario: TWICImageFormat): TGraphic;

  procedure plcLerImagem;
  begin
    try
      ipBytesStream.Position := 0;
      Result.LoadFromStream(ipBytesStream);
    except
      if Assigned(Result) then
        FreeAndNil(Result);
    end;
  end;

var
  vaGraphicClass: TGraphicClass;
begin
  Result := nil;
  vaGraphicClass := nil;

  if Assigned(ipBytesStream) then
    begin
      ipBytesStream.Position := 0;

      if not fpuFindGraphicClass(ipBytesStream, vaGraphicClass) then
        begin
          // Não foi possível determinar a classe da imagem, então vamos utilizar
          // a classe secundária informada e tentar ler a imagem
          case ipFormatoSecundario of
            wifBmp:
              vaGraphicClass := TBitmap;
            wifPng:
              vaGraphicClass := TPNGImage;
            wifJpeg:
              vaGraphicClass := TJPEGImage;
            wifGif:
              vaGraphicClass := TGIFImage;
          end;
        end;

      Result := TGraphicClass(vaGraphicClass).Create;
      plcLerImagem;

      // Não foi possível ler a imagem ou foi informado um tipo secundário diferente dos que estão logo acima,
      // então vamos utilizar a classe TWICImage, pois esta classe aceita vários formatos de imagens
      if not Assigned(Result) then
        begin
          Result := TWicImage.Create;
          plcLerImagem;
        end;
    end;
end;

class function TChatFuncoes.fpuMontaIdentificador(const ipCodigoUsuario,
  ipCodigoHospital: Integer): string;
begin
  Result :=
    TRegEx.Replace(IntToStr(ipCodigoUsuario), '-', 'n', [roIgnoreCase, roSingleLine]) +
    '_' +
    TRegEx.Replace(IntToStr(ipCodigoHospital), '-', 'n', [roIgnoreCase, roSingleLine]);
end;

class function TChatFuncoes.fpuTamanhoFormatado(const ipTamanho: Int64): string;
const
  KB = 1024;
  MB = 1024 * KB;
  GB = 1024 * MB;
begin
  Result := '0B';

  if ipTamanho > 0 then
    begin
      case ipTamanho of
        0 .. (KB - 1):
          Result := FormatFloat(',0', ipTamanho) + 'B';
        KB .. (MB - 1):
          Result := FormatFloat(',0.00', ipTamanho / KB) + 'KB';
        MB .. (GB - 1):
          Result := FormatFloat(',0.00', ipTamanho / MB) + 'MB';
      else
        Result := FormatFloat(',0.00', ipTamanho / GB) + 'GB';
      end;
    end;
end;

class procedure TChatFuncoes.ppuAdicionarSmileysTela(
  const ipWidthParentSmileys: Integer;
  const ipOwnerAndParentSmileys: TWinControl;
  const ipImageCollectionItems: TcxImageCollectionItems;
  const ipOnClickSmileys: TNotifyEvent; var ioSmileysExpressaoRegular: string;
  var ioSmileys: TDictionary<string, string>);

var
  vaArrayChaves: System.TArray<string>;

  procedure plcAdicionarSmiley(const ipChave, ipNome: string);
  begin
    SetLength(vaArrayChaves, Length(vaArrayChaves) + 1);
    vaArrayChaves[High(vaArrayChaves)] := ipChave;
    ioSmileys.Add(ipChave, ipNome);
  end;

var
  vaLeft, vaTop, vaColuna, vaQtdeColuna: Integer;
  vaChave: string;
  vaImagem: TcxImageCollectionItem;
  vaImage: TImage;
begin
  SetLength(vaArrayChaves, 0);
  ioSmileys := TDictionary<string, string>.Create;

  plcAdicionarSmiley('>:(', 'People_AngryFace');
  plcAdicionarSmiley(':angustiado:', 'People_AnguishedFace');
  plcAdicionarSmiley(':atonito:', 'People_AstonishedFace');
  plcAdicionarSmiley(':s', 'People_ConfoundedFace');
  plcAdicionarSmiley('O.o', 'People_ConfusedFace');
  plcAdicionarSmiley(':''(', 'People_CryingFace');
  plcAdicionarSmiley(':desapontadomasaliviado:', 'People_DisappointedButRelievedFace');
  plcAdicionarSmiley(':desapontado:', 'People_DisappointedFace');
  plcAdicionarSmiley(':tonto:', 'People_DizzyFace');
  plcAdicionarSmiley('-_-', 'People_ExpressionlessFace');
  plcAdicionarSmiley(':delicia:', 'People_FaceSavouringDeliciousFood');
  plcAdicionarSmiley(':@', 'People_FaceScreamingInFear');
  plcAdicionarSmiley(':*<3', 'People_FaceThrowingAKiss');
  plcAdicionarSmiley(''':<', 'People_FaceWithColdSweat');
  plcAdicionarSmiley(':trinunfo:', 'People_FaceWithLookOfTriumph');
  plcAdicionarSmiley(':#', 'People_FaceWithMedicalMask');
  plcAdicionarSmiley(':o', 'People_FaceWithOpenMouth');
  plcAdicionarSmiley(''':o', 'People_FaceWithOpenMouthAndColdSweat');
  plcAdicionarSmiley(':p', 'People_FaceWithStuckOutTongue');
  plcAdicionarSmiley('¦p', 'People_FaceWithStuckOutTongueAndTightlyClosedEyes');
  plcAdicionarSmiley(';p', 'People_FaceWithStuckOutTongueAndWinkingEye');
  plcAdicionarSmiley('kkkk', 'People_FaceWithTearsOfJoy');
  plcAdicionarSmiley(':silencio:', 'People_FaceWithoutMouth');
  plcAdicionarSmiley(':temeroso:', 'People_FearfulFace');
  plcAdicionarSmiley(':vergonha:', 'People_FlushedFace');
  plcAdicionarSmiley(':(', 'People_FrowningFaceWithOpenMouth');
  plcAdicionarSmiley(':careta:', 'People_GrimacingFace');
  plcAdicionarSmiley(':D', 'People_GrinningFace');
  plcAdicionarSmiley('3:<', 'People_Imp');
  plcAdicionarSmiley(':*', 'People_KissingFace');
  plcAdicionarSmiley('¦*', 'People_KissingFaceWithClosedEyes');
  plcAdicionarSmiley(':_(', 'People_LoudlyCryingFace');
  plcAdicionarSmiley(':|', 'People_NeutralFace');
  plcAdicionarSmiley(':pensativo:', 'People_PensiveFace');
  plcAdicionarSmiley(':raiva:', 'People_PoutingFace');
  plcAdicionarSmiley(':alivio:', 'People_RelievedFace');
  plcAdicionarSmiley('zzzz', 'People_SleepingFace');
  plcAdicionarSmiley(':sonolento:', 'People_SleepyFace');
  plcAdicionarSmiley('O:)', 'People_SmilingFaceWithHalo');
  plcAdicionarSmiley('<3)', 'People_SmilingFaceWithHeartShapedEyes');
  plcAdicionarSmiley('3:)', 'People_SmilingFaceWithHorns');
  plcAdicionarSmiley(''':D', 'People_SmilingFaceWithOpenMouthAndColdSweat');
  plcAdicionarSmiley('8-)', 'People_SmilingFaceWithSunglasses');
  plcAdicionarSmiley(':-1', 'People_SmirkingFace');
  plcAdicionarSmiley('(:|', 'People_TiredFace');
  plcAdicionarSmiley(':cansado:', 'People_WearyFace');
  plcAdicionarSmiley(';)', 'People_WinkingFace');
  plcAdicionarSmiley('>w<', 'People_WorriedFace');
  plcAdicionarSmiley('~:0', 'People_Baby');
  plcAdicionarSmiley('O~:0', 'People_BabyAngel');
  plcAdicionarSmiley('(:-)', 'People_Boy');
  plcAdicionarSmiley('8:^)', 'People_Girl');
  plcAdicionarSmiley(':princesa:', 'People_Princess');
  plcAdicionarSmiley(':homem:', 'People_Man');
  plcAdicionarSmiley(':mulher:', 'People_Woman');
  plcAdicionarSmiley(':noiva:', 'People_BrideWithVeil');
  plcAdicionarSmiley(':idoso:', 'People_OlderMan');
  plcAdicionarSmiley(':idosa:', 'People_OlderWoman');
  plcAdicionarSmiley(':casal:', 'People_ManAndWomanHoldingHands');
  plcAdicionarSmiley(':casalcoracao:', 'People_CoupleWithHeart');
  plcAdicionarSmiley(':familia:', 'People_Family');
  plcAdicionarSmiley(':noel:', 'People_FatherChristmas');
  plcAdicionarSmiley(':construcao:', 'People_ConstructionWorker');
  plcAdicionarSmiley(':policia:', 'People_PoliceOfficer');
  plcAdicionarSmiley(':caveira:', 'People_Skull');
  plcAdicionarSmiley(':fantasma:', 'People_Ghost');
  plcAdicionarSmiley('<3', 'Celebration_HeavyBlackHeart');
  plcAdicionarSmiley(':coracaopartido:', 'Celebration_BrokenHeart');
  plcAdicionarSmiley(':pegadas:', 'People_Footprints');
  plcAdicionarSmiley(':oracao:', 'People_PersonWithFoldedHands');
  plcAdicionarSmiley(':manicure:', 'People_NailPolish');
  plcAdicionarSmiley(':palmas:', 'People_ClappingHandsSign');
  plcAdicionarSmiley(':pare:', 'People_RaisedHand');
  plcAdicionarSmiley(':positivo:', 'People_ThumbsUpSign');
  plcAdicionarSmiley(':negativo:', 'People_ThumbsDownSign');
  plcAdicionarSmiley(':ok:', 'People_OkHandSign');
  plcAdicionarSmiley(':vitoria:', 'People_VictoryHand');
  plcAdicionarSmiley(':tchau:', 'People_WavingHandSign');
  plcAdicionarSmiley(':beijo:', 'People_KissMark');
  plcAdicionarSmiley(':cafe:', 'FoodDrink_HotBeverage');
  plcAdicionarSmiley(':cerveja:', 'FoodDrink_BeerMug');
  plcAdicionarSmiley(':brinde:', 'FoodDrink_ClinkingBeerMugs');
  plcAdicionarSmiley(':vinho:', 'FoodDrink_WineGlass');
  plcAdicionarSmiley(':coquitel:', 'FoodDrink_CocktailGlass');
  plcAdicionarSmiley(':coquiteltropical:', 'FoodDrink_TropicalDrink');
  plcAdicionarSmiley(':nuvem:', 'Nature_Cloud');
  plcAdicionarSmiley(':nublado:', 'Nature_SunBehindCloud');
  plcAdicionarSmiley(':chuva:', 'Nature_UmbrellaWithRainDrops');
  plcAdicionarSmiley(':fogo:', 'Nature_Fire');
  plcAdicionarSmiley(':cacto:', 'Nature_Cactus');
  plcAdicionarSmiley(':palmeira:', 'Nature_PalmTree');
  plcAdicionarSmiley(':pinheiro:', 'Nature_EvergreenTree');
  plcAdicionarSmiley(':arvore:', 'Nature_DeciduousTree');
  plcAdicionarSmiley(':flor:', 'Nature_CherryBlossom');
  plcAdicionarSmiley(':rosa:', 'Nature_Rose');
  plcAdicionarSmiley(':girassol:', 'Nature_Sunflower');
  plcAdicionarSmiley(':tulipa:', 'Nature_Tulip');

  if Length(vaArrayChaves) <> ipImageCollectionItems.Count then
    raise Exception.Create('A quantidade de imagens no componente ImgCollectionSmileys está' + sLineBreak + 'diferente da quantidade de imagens adicionadas na tela.');

  // Montando a expressão regular dos smileys para poder incluí-los no texto das mensagens e incluindo
  // o smiley na tela, par o usuário clicar
  ioSmileysExpressaoRegular := ':[a-z1-9]{1,}:';
  vaLeft := 4;
  vaTop := 4;
  vaColuna := 1;
  vaQtdeColuna := (ipWidthParentSmileys - 25) div 24; // 25 é igual a 4 pixels de espaçamento a esquerda, 4 de espaçamento a direita e 17 do scroll horizontal

  for vaChave in vaArrayChaves do
    begin
      // Montando a expressão regular
      if not TRegEx.IsMatch(vaChave, ':[a-z1-9]{1,}:', [roSingleLine, roIgnoreCase]) then
        ioSmileysExpressaoRegular := ioSmileysExpressaoRegular + '|' + TRegEx.Escape(vaChave);

      // Incluindo o "botão" dos smileys na tela, na mesma ordem em que foram informados
      vaImagem := nil;
      ipImageCollectionItems.FindItemByName(ioSmileys.Items[vaChave], vaImagem);

      if Assigned(vaImagem) then
        begin
          vaImage := TImage.Create(ipOwnerAndParentSmileys);
          vaImage.Parent := ipOwnerAndParentSmileys;
          vaImage.Height := 24;
          vaImage.Width := 24;
          vaImage.Center := True;
          vaImage.Hint := vaChave;
          vaImage.ShowHint := True;
          vaImage.Cursor := crHandPoint;
          vaImage.OnClick := ipOnClickSmileys;
          vaImage.Picture.Graphic := vaImagem.Picture.Graphic;
          vaImage.Top := vaTop;
          vaImage.Left := vaLeft;

          // Calculando o posicionamento da próxima imagem
          Inc(vaColuna);

          if vaColuna >= vaQtdeColuna then
            begin
              vaColuna := 1;
              vaTop := vaTop + vaImage.Height + 2;
            end;

          vaLeft := 4 + ((vaColuna - 1) * (vaImage.Width + 2));
        end;
    end;
end;

class procedure TChatFuncoes.ppuConverterSmileysParaTexto(
  const ipRVE: TRichViewEdit);
var
  vaItemNo, vaItemOffs: Integer;
  vaItemRVE: TCustomRVItemInfo;
  vaBytesStream: TBytesStream;
begin
  // Incluíndo o texto que está na Tag das imagens
  for vaItemNo := 0 to ipRVE.ItemCount - 1do
    begin
      vaItemRVE := ipRVE.GetItem(vaItemNo);

      if (vaItemRVE.ClassType = TRVGraphicItemInfo) then
        begin
          vaItemOffs := ipRVE.GetOffsAfterItem(vaItemNo);
          ipRVE.SetSelectionBounds(vaItemNo, vaItemOffs, vaItemNo, vaItemOffs);
          ipRVE.InsertTextA(vaItemRVE.Tag);
          ipRVE.Change;
        end;
    end;

  // Passando somente o texto para um stream, limpando o RichViewEdit e carregando somente texto de volta para o RichViewEdit
  vaBytesStream := TBytesStream.Create;

  try
    ipRVE.SaveTextToStream('', vaBytesStream, 0, False, True);
    ipRVE.Clear;
    ipRVE.Change;
    ipRVE.Format;
    vaBytesStream.Position := 0;
    ipRVE.LoadFromStream(vaBytesStream, TRVYesNoAuto.rvynaAuto);
    ipRVE.Change;
    ipRVE.Format;
  finally
    FreeAndNil(vaBytesStream);
  end;
end;

class procedure TChatFuncoes.ppuConverterTextoParaSmileys(
  const ipRVE: TRichViewEdit; const ipDMChat: TDMChat;
  const ipSmileys: TDictionary<string, string>;
  const ipSmileysExpressaoRegular: string);
var
  vaCodigosImagens: TMatchCollection;
  vaCodigo: TMatch;
  vaTexto, vaTextoParcial, vaNomeImagem: string;
  vaImagem: TcxImageCollectionItem;
  i, vaItemNo, vaItemOffs, vaComprimentoString: Integer;
  vaItemRVE: TCustomRVItemInfo;
  vaPrimeiroSmiley: Boolean;
begin
  vaItemNo := 0;

  while vaItemNo < ipRVE.ItemCount do
    begin
      vaItemRVE := ipRVE.GetItem(vaItemNo);

      // Armazenando o texto original em uma variável
      vaTexto := TRegEx.Replace(vaItemRVE.ItemText, TRegEx.Escape(Char(#0)), '', [roIgnoreCase]);

      if TRegEx.IsMatch(vaTexto, ipSmileysExpressaoRegular, [roIgnoreCase]) then
        begin
          // Posicionando o cursor logo após o item
          vaItemOffs := ipRVE.GetOffsAfterItem(vaItemNo);
          ipRVE.SetSelectionBounds(vaItemNo, vaItemOffs, vaItemNo, vaItemOffs);

          // Pegando os smileys
          vaCodigosImagens := TRegEx.Matches(vaTexto, ipSmileysExpressaoRegular, [roIgnoreCase]);
          vaPrimeiroSmiley := True;

          for vaCodigo in vaCodigosImagens do
            begin
              // Incluindo o texto que está antes do smiley
              vaTextoParcial := TRegEx.Match(vaTexto, '.*?(?=' + TRegEx.Escape(vaCodigo.Value) + ')', [roIgnoreCase]).Value;

              if vaPrimeiroSmiley then
                begin
                  vaItemRVE.ItemText := '';

                  if vaTextoParcial <> '' then
                    begin
                      for i := 1 to Length(vaTextoParcial) do
                        vaItemRVE.ItemText := vaItemRVE.ItemText + vaTextoParcial[i] + Char(#0);
                    end;
                end
              else
                begin
                  if vaTextoParcial <> '' then
                    begin
                      ipRVE.InsertTextA(vaTextoParcial, True);
                      ipRVE.Change;
                    end;
                end;

              // Incluindo o smiley
              if ipSmileys.TryGetValue(vaCodigo.Value, vaNomeImagem) and ipDMChat.ImgCollectionSmileys.Items.FindItemByName(vaNomeImagem, vaImagem) then
                ppuInserirSmileysRichViewEdit(vaImagem.Picture.Graphic, vaCodigo.Value, ipRVE);

              // Pegando todo o texto que está após o smiley
              vaTexto := TRegEx.Match(vaTexto, '(?<=' + TRegEx.Escape(vaCodigo.Value) + ').*', []).Value;
            end;

          // Imprimindo o texto restante
          if vaTexto <> '' then
            ipRVE.InsertTextA(vaTexto, True);

          ipRVE.Change;
          vaItemNo := 0;
        end
      else
        Inc(vaItemNo);
    end;
end;

class procedure TChatFuncoes.ppuIncluirStatusMensagem(
  ipCelula: TRVTableCellData; const ipParagrafo: Integer;
  const ipCodigoLeitura: string; ipMsgLida: Boolean; const ipDMChat: TDMChat);
var
  vaGraphic: TGraphic;
  vaPicture: TPicture;
  i: Integer;
begin
  if ipMsgLida then
    vaPicture := ipDMChat.ImgCollectionItemStatusMensagemLida.Picture
  else
    vaPicture := ipDMChat.ImgCollectionItemStatusMensagemRecebida.Picture;

  if Assigned(vaPicture) then
    begin
      if ipCelula.ItemCount > 0 then
        ipCelula.DeleteItems(0, ipCelula.ItemCount);

      vaGraphic := TGraphicClass(vaPicture.Graphic.ClassType).Create;
      vaGraphic.Assign(vaPicture.Graphic);
      ipCelula.AddHotPictureTag('', vaGraphic, ipParagrafo, rvvaMiddle, 'status' + ipCodigoLeitura);
    end;
end;

class procedure TChatFuncoes.ppuInserirSmileysRichViewEdit(
  const ipGraphic: TGraphic; const ipIdentificacao: string;
  const ipRVE: TRichViewEdit);
var
  vaGraphic: TGraphic;
  vaItemNo, vaItemOffs: Integer;
  vaItemRVG: TRVGraphicItemInfo;
begin
  vaGraphic := TGraphicClass(ipGraphic.ClassType).Create;
  vaGraphic.Assign(ipGraphic);
  vaItemRVG := TRVGraphicItemInfo.CreateEx(ipRVE.RVData, vaGraphic, rvvaMiddle);
  vaItemRVG.ParaNo := 0;
  vaItemRVG.Tag := ipIdentificacao;
  ipRVE.InsertItem('', vaItemRVG);
  ipRVE.Change;

  // Posicionando o cursor logo após a inserção do smiley
  vaItemNo := ipRVE.GetItemNo(vaItemRVG);
  vaItemOffs := ipRVE.GetOffsAfterItem(vaItemNo);
  ipRVE.SetSelectionBounds(vaItemNo, vaItemOffs, vaItemNo, vaItemOffs);
end;

class procedure TChatFuncoes.ppuPreencherRichViewEdit(
  const ipMensagem: OleVariant; ipRVE: TRichViewEdit;
  const ipIdentificador: string; const ipPosicaoScroll: Integer;
  const ipDestacarTextoPesquisa: string; const ipExibirLinkVisualizacaoPesquisa,
  ipExibirLinkVoltarPesquisa, ipLimparRichViewEdit: Boolean;
  const ipCodigoMensagemDestacar: Integer; const ipEstilo: TChatEstiloRich;
  const ipDMChat: TDMChat; const ipSmileys: TDictionary<string, string>;
  const ipSmileysExpressaoRegular: string;
  const ipAoConfirmarLeituraMensagens: TChatConfirmarLeituraMensagens;
  const ipUsuarioLogado: TChatIdentificacaoUsuario;
  var ioDataUltimaMensagemRichView: TDateTime;
  var ioDadosConversas: TDictionary<string, TChatDadosConversa>;
  var ioCodigoPrimeiraMsgNaoLida: Integer);

  function flcConfigTabela(const ipBorderWidth, ipLinhas, ipColunas: Integer; const ipRichViewEdit: TRichViewEdit): TRVTableItemInfo;
  var
    X, Y: Integer;
  begin
    // Criando a tabela e adicionando no RichViewEdit
    Result := TRVTableItemInfo.CreateEx(ipLinhas, ipColunas, ipRichViewEdit.RVData);
    ipRichViewEdit.AddItem('', Result);

    // Configurando a tabela
    Result.IgnoreBordersInvisible := true;
    Result.Options := [];
    Result.BorderWidth := ipBorderWidth;
    Result.BorderStyle := rvtbColor;
    Result.BorderColor := $00CACACA;

    Result.VisibleBorders.Left := False;
    Result.VisibleBorders.Right := False;
    Result.VisibleBorders.Top := ipBorderWidth > 0;
    Result.VisibleBorders.Bottom := False;

    Result.BorderVSpacing := 0;
    Result.BorderHSpacing := 0;

    Result.CellPadding := 0;
    Result.CellHPadding := 0;
    Result.CellVPadding := 2;
    Result.CellBorderWidth := 0;

    // Limpando o conteúdo de todas as células
    for X := 0 to Result.RowCount - 1 do
      begin
        for Y := 0 to Result.ColCount - 1 do
          Result.Cells[X, Y].Clear;
      end;
  end;

  procedure plcIncluirTextoComImagens(ipCelula: TRVTableCellData; const ipTexto: string; const ipEstiloTexto, ipNroParagrafo: Integer; const ipIncluirSmileys: Boolean);
  var
    vaCodigosImagens: TMatchCollection;
    vaCodigo: TMatch;
    vaTexto, vaNomeImagem: string;
    vaNroParagrafo: Integer;
    vaImagem: TcxImageCollectionItem;
    vaGraphic: TGraphic;
  begin
    // Verificando se existem smileys
    if (not ipIncluirSmileys) or (not TRegEx.IsMatch(ipTexto, ipSmileysExpressaoRegular, [roIgnoreCase])) then
      ipCelula.AddTextBlockNLA(ipTexto, ipEstiloTexto, ipNroParagrafo, 'texto')
    else
      begin
        vaNroParagrafo := ipNroParagrafo;
        vaTexto := ipTexto;

        // Pegando os smileys
        vaCodigosImagens := TRegEx.Matches(ipTexto, ipSmileysExpressaoRegular, [roIgnoreCase]);

        for vaCodigo in vaCodigosImagens do
          begin
            // Incluindo o texto que está antes do smiley
            ipCelula.AddTextBlockNLA(TRegEx.Match(vaTexto, '.*?(?=' + TRegEx.Escape(vaCodigo.Value) + ')', [roIgnoreCase]).Value, ipEstiloTexto, vaNroParagrafo, 'texto');

            // A partir deste ponto não haverá um parágrafo definito, para não incluir uma nova linha
            vaNroParagrafo := -1;

            // Incluindo o smiley
            if ipSmileys.TryGetValue(AnsiLowerCase(vaCodigo.Value), vaNomeImagem) then
              begin
                try
                  ipDMChat.ImgCollectionSmileys.Items.FindItemByName(vaNomeImagem, vaImagem);
                  vaGraphic := TGraphicClass(vaImagem.Picture.Graphic.ClassType).Create;
                  vaGraphic.Assign(vaImagem.Picture.Graphic);
                  ipCelula.AddPictureExTag('', vaGraphic, vaNroParagrafo, rvvaMiddle, 'Smiley');
                except
                  ipCelula.AddTextBlockNLA(vaCodigo.Value, ipEstiloTexto, vaNroParagrafo, 'texto');
                end;
              end
            else
              ipCelula.AddTextBlockNLA(vaCodigo.Value, ipEstiloTexto, vaNroParagrafo, 'texto');

            // Pegando todo o texto que está após o smiley
            vaTexto := TRegEx.Match(vaTexto, '(?<=' + TRegEx.Escape(vaCodigo.Value) + ').*', []).Value;
          end;

        // Imprimindo o texto restante
        if vaTexto <> '' then
          ipCelula.AddTextBlockNLA(vaTexto, ipEstiloTexto, vaNroParagrafo, 'texto');
      end;
  end;

  procedure plcIncluirAnexo(ipCelula: TRVTableCellData; ipCodigoHospital: Integer);
  const
    coSalvar = 'arquivoDownload';
    coVisualizar = 'arquivoVisualizar';
  var
    vaGraphic: TGraphic;
    vaPicture: TPicture;
    vaBytesStream: TBytesStream;
    vaTabela: TRVTableItemInfo;
    vaThumbnail: Boolean;
    vaIdentificacaoArquivo: string;
  begin
    vaGraphic := nil;
    vaPicture := nil;
    vaBytesStream := nil;
    vaThumbnail := not ipDMChat.cdsMensagemTHUMBNAIL.IsNull;
    vaIdentificacaoArquivo := IntToStr(ipCodigoHospital) + '_' + ipDMChat.cdsMensagemENDERECO_ANEXO.AsString;

    try
      if vaThumbnail then
        begin
          vaBytesStream := TBytesStream.Create;
          ipDMChat.cdsMensagemTHUMBNAIL.SaveToStream(vaBytesStream);
          vaBytesStream.Position := 0;
          vaGraphic := fpuImagem(vaBytesStream, TWICImageFormat.wifJpeg);
        end
      else
        begin
          vaPicture := fpuIconeArquivo(ipDMChat.cdsMensagemEXTENSAO.AsString, ipDMChat);

          if Assigned(vaPicture.Graphic) then
            begin
              vaGraphic := TGraphicClass(vaPicture.Graphic.ClassType).Create;
              vaGraphic.Assign(vaPicture.Graphic);
            end;
        end;
    finally
      if Assigned(vaBytesStream) then
        FreeAndNil(vaBytesStream);

      if Assigned(vaPicture) then
        FreeAndNil(vaPicture);
    end;

    vaTabela := TRVTableItemInfo.CreateEx(1, 2, ipRVE.RVData);
    ipCelula.AddItem('', vaTabela);

    // Configurando a tabela
    vaTabela.Options := [];
    vaTabela.BorderWidth := 0;
    vaTabela.Color := clNone;

    vaTabela.VisibleBorders.Left := False;
    vaTabela.VisibleBorders.Right := False;
    vaTabela.VisibleBorders.Top := False;
    vaTabela.VisibleBorders.Bottom := False;

    vaTabela.BorderVSpacing := 0;
    vaTabela.BorderHSpacing := 0;

    vaTabela.CellPadding := 0;
    vaTabela.CellHPadding := 0;
    vaTabela.CellVPadding := 0;
    vaTabela.CellBorderWidth := 0;

    vaTabela.Cells[0, 0].BestWidth := 1;
    vaTabela.Cells[0, 0].VAlign := rvcMiddle;
    vaTabela.Cells[0, 0].Clear;

    if Assigned(vaGraphic) then
      begin
        if vaThumbnail then
          vaTabela.Cells[0, 0].AddHotPictureTag('', vaGraphic, 4, rvvaMiddle, coVisualizar + vaIdentificacaoArquivo)
        else
          vaTabela.Cells[0, 0].AddHotPictureTag('', vaGraphic, 4, rvvaMiddle, coSalvar + vaIdentificacaoArquivo);
      end;

    vaTabela.Cells[0, 1].VAlign := rvcMiddle;
    vaTabela.Cells[0, 1].Clear;

    vaTabela.Cells[0, 1].AddTextBlockNLA(
      ipDMChat.cdsMensagemNOME_ARQUIVO.AsString + ' - ' + fpuTamanhoFormatado(ipDMChat.cdsMensagemTAMANHO_KB.AsInteger * 1024),
      0, 4, 'texto');

    vaTabela.Cells[0, 1].AddTextBlockNLA('Salvar', 4, 4, coSalvar + vaIdentificacaoArquivo);

    if not ipDMChat.cdsMensagemTHUMBNAIL.IsNull then
      begin
        vaTabela.Cells[0, 1].AddTextBlockNLA(' | ', 0, -1, 'texto');
        vaTabela.Cells[0, 1].AddTextBlockNLA('Visualizar', 4, -1, coVisualizar + vaIdentificacaoArquivo);
      end;
  end;

var
  vaTabela: TRVTableItemInfo;
  vaLabel: TLabel;
  vaTexto: string;
  i, vaCodigoHospital, vaCodigoMensagem, vaCodigoUltimaMensagem, vaQtdeLinhas, vaNroParagrafo, vaLinha, vaCodigoUltimoRemetente: Integer;
  vaLinhas: System.TArray<string>;
  vaLinks: TMatchCollection;
  vaLink: TMatch;
  vaIncluirSmileys, vaConversaEmGrupo, vaSepararMsg, vaMesmoDiaHoraMinuto: Boolean;
  vaDadosConversa: TChatDadosConversa;
  vaLeituraConfirmada: Boolean;
begin
  // **************************
  // Parágrafos               *
  // 0 - ParagrafoGenerico    * Este parágrafo existe por casa da tabela que usa o primeiro parágrafo como referência para se posicionar dentro do componente (TRichViewEdit)
  // 1 - ParagrafoRemetente   *
  // 2 - ParagrafoDataHora    *
  // 3 - ParagrafoMensagem    *
  // 4 - ParagrafoDivisaoData *
  // -------------------------*
  // Estilos                  *
  // 0 - FontRemetente        *
  // 1 - FontDataHora         *
  // 2 - FontMensagem         *
  // 3 - FontDivisaoData      *
  // **************************

  // Inicializando algumas variáveis
  vaLabel := nil;
  ioCodigoPrimeiraMsgNaoLida := 0;
  ioDataUltimaMensagemRichView := 0;
  vaCodigoUltimoRemetente := 0;

  // A variável está nula
  if VarIsNull(ipMensagem) then
    begin
      if ipLimparRichViewEdit then
        begin
          ipRVE.Clear;
          ipRVE.Change;
          ipRVE.Format;
        end;

      Exit;
    end;

  // Carregando os dados
  ipDMChat.cdsMensagem.Data := ipMensagem;

  // Se não tem nada no ClientDataSet
  if ipDMChat.cdsMensagem.RecordCount = 0 then
    begin
      if ipLimparRichViewEdit then
        begin
          ipRVE.Clear;
          ipRVE.Change;
          ipRVE.Format;
        end;

      ipDMChat.cdsMensagem.Close;
      Exit;
    end;

  vaCodigoHospital := fpuCodigoHospital(ipIdentificador);
  vaLabel := nil;

  // Verificando se a conversa é em grupo

  // *************************************
  // Mensagem                            *
  // Sem remetente: Enviada pelo sistema *
  // Sem destinatário: Grupo "todos"     *
  // *************************************

  // Se o destinatário for zero, então está no grupo "todos"
  vaConversaEmGrupo := ipDMChat.cdsMensagemCODIGO_SENHA_DESTINATARIO.AsInteger = 0;

  if not vaConversaEmGrupo then
    vaConversaEmGrupo := ipDMChat.cdsMensagemUSUARIO_GRUPO_DESTINATARIO.AsInteger = 1;

  try
    vaLabel := TLabel.Create(nil);
    vaLabel.Font.Name := ipDMChat.RVStyle1.TextStyles.Items[1].FontName;
    vaLabel.Font.Size := ipDMChat.RVStyle1.TextStyles.Items[1].Size;
    vaLabel.Font.Style := ipDMChat.RVStyle1.TextStyles.Items[1].Style;

    // Verificando se é para limpar o RichViewEdit
    if ipLimparRichViewEdit then
      ipRVE.Clear;

    // Iniciando a variável com um valor diferente da primeira mensagem
    vaCodigoUltimaMensagem := ipDMChat.cdsMensagemCODIGO.AsInteger - 1;

    // Incluindo no início um link para voltar a pesquisa
    if ipExibirLinkVoltarPesquisa then
      begin
        vaTabela := flcConfigTabela(1, 1, 1, ipRVE);
        vaTabela.Color := $00D2FFFF;

        vaTabela.MergeCells(0, 0, 4, 1, False);
        vaTabela.Cells[0, 0].AddTextBlockNLA(
          'Voltar para a pesquisa',
          4,
          3,
          'pesquisar#VoltarPesquisa' +
          '#idUserConversa' + ipIdentificador +
          '#DestacarTexto' + ipDestacarTextoPesquisa);
      end;

    // Buscando as informações da conversa para confirmar a leitura das mensagens
    vaDadosConversa := ioDadosConversas.Items[ipIdentificador];
    ipDMChat.cdsMensagem_Aux.Data := vaDadosConversa.Mensagens;
    ipDMChat.cdsMensagem_AuxMENSAGEM_LIDA.ProviderFlags := [pfInUpdate];
    ipDMChat.cdsMensagem_AuxMENSAGEM_LIDA_USUARIO_LOGADO.ProviderFlags := [pfInUpdate];

    //se nao limpou o richview temos que pegar a data e hora da ultima msg exibida para nao duplicar a data
    if (not ipLimparRichViewEdit) and (ipDMChat.cdsMensagem_Aux.RecordCount > 1) then
      begin
        ipDMChat.cdsMensagem_Aux.Last;
        //temos que voltar uma posicao porque a mensagem que acabou de receber já esta inclusa no cdsMensagem_Aux
        ipDMChat.cdsMensagem_Aux.Prior;

        ioDataUltimaMensagemRichView := ipDMChat.cdsMensagem_AuxDATA_HORA_ENVIO.AsDateTime;
        vaCodigoUltimoRemetente := ipDMChat.cdsMensagem_AuxCODIGO_SENHAUS_REMETENTE.AsInteger;
      end;

    // Carregando as mensagens no RichViewEdit
    while (not ipDMChat.cdsMensagem.Eof) do
      begin
        // Verificando se houve mudança de registro. Se houve mudança vamos preencher todos os dados da mensagens, se não
        // vamos preencher apenas o anexo
        if vaCodigoUltimaMensagem <> ipDMChat.cdsMensagemCODIGO.AsInteger then
          begin
            vaCodigoUltimaMensagem := ipDMChat.cdsMensagemCODIGO.AsInteger;

            // Confirmando a leitura da mensagem
            vaLeituraConfirmada := ipDMChat.cdsMensagemMENSAGEM_LIDA.AsInteger = 1;
            if (not vaLeituraConfirmada) and (ioCodigoPrimeiraMsgNaoLida = 0) then
              ioCodigoPrimeiraMsgNaoLida := ipDMChat.cdsMensagemCODIGO.AsInteger;

            if (ipDMChat.cdsMensagemMENSAGEM_LIDA_USUARIO_LOGADO.AsInteger = 0) and (ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger <> ipUsuarioLogado.CodigoUsuario) then
              begin
                try
                  if ipDMChat.cdsMensagem_Aux.RecordCount = ipDMChat.cdsMensagem.RecordCount then
                    ipDMChat.cdsMensagem_Aux.RecNo := ipDMChat.cdsMensagem.RecNo;

                  if ipDMChat.cdsMensagem_AuxCODIGO.AsInteger = ipDMChat.cdsMensagemCODIGO.AsInteger then
                    begin
                      if Assigned(ipAoConfirmarLeituraMensagens) then
                        ipAoConfirmarLeituraMensagens(ipUsuarioLogado, IntToStr(ipDMChat.cdsMensagem_AuxCODIGO.AsInteger));

                      if not(ipDMChat.cdsMensagem_Aux.State in [dsEdit, dsInsert]) then
                        ipDMChat.cdsMensagem_Aux.Edit;

                      ipDMChat.cdsMensagem_AuxMENSAGEM_LIDA.AsInteger := 1;
                      ipDMChat.cdsMensagem_AuxMENSAGEM_LIDA_USUARIO_LOGADO.AsInteger := 1;
                      ipDMChat.cdsMensagem_Aux.Post;
                    end
                  else
                    begin
                      if ipDMChat.cdsMensagem_Aux.Locate('CODIGO', ipDMChat.cdsMensagemCODIGO.AsInteger, []) then
                        begin
                          if Assigned(ipAoConfirmarLeituraMensagens) then
                            ipAoConfirmarLeituraMensagens(ipUsuarioLogado, IntToStr(ipDMChat.cdsMensagem_AuxCODIGO.AsInteger));

                          if not(ipDMChat.cdsMensagem_Aux.State in [dsEdit, dsInsert]) then
                            ipDMChat.cdsMensagem_Aux.Edit;

                          ipDMChat.cdsMensagem_AuxMENSAGEM_LIDA.AsInteger := 1;
                          ipDMChat.cdsMensagem_Aux.Post;
                        end;
                    end;

                  vaLeituraConfirmada := True;
                except
                  vaLeituraConfirmada := False;

                  if (ipDMChat.cdsMensagem_Aux.State in [dsEdit, dsInsert]) then
                    ipDMChat.cdsMensagem_Aux.Cancel;
                end;
              end;

            // Verificando se há a necessidade de incluir a divisão da data
            if FormatDateTime('dd/mm/yyyy', ioDataUltimaMensagemRichView) <> FormatDateTime('dd/mm/yyyy', ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime) then
              begin
                vaTabela := flcConfigTabela(1, 1, 1, ipRVE);
                vaTabela.Color := clSilver;

                vaTabela.Cells[0, 0].AddTextBlockNLA(TUtils.fpuCapitalize(TRegEx.Replace(FormatDateTime('dddd, dd of mmmm of yyyy', ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime), 'of', 'de', [roSingleLine, roIgnoreCase])), 3, 5);

                // Se mudou o dia, então não precisa testar mais nada
                vaMesmoDiaHoraMinuto := False;
              end
            else
              begin
                vaMesmoDiaHoraMinuto := (HourOf(ioDataUltimaMensagemRichView) = HourOf(ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime)) and
                  (MinuteOf(ioDataUltimaMensagemRichView) = MinuteOf(ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime));
              end;

            vaSepararMsg := (ipEstilo <> erNormal) or (not vaMesmoDiaHoraMinuto) or (vaCodigoUltimoRemetente <> ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger);
            vaCodigoUltimoRemetente := ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger;
            ioDataUltimaMensagemRichView := ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime;

            // Tabela da mensagem (uma linha e quatro colunas). Obs.: Pode haver duas linhas, caso deva exibir o link de visualização da mensagem
            // Primeira coluna: Nome de quem enviou a mensagem
            // Segunda coluna: Mensagem
            // Terceira coluna: Data e hora de envio
            // Quarta coluna: Leitores da mensagem
            if ipExibirLinkVisualizacaoPesquisa then
              begin
                vaTabela := flcConfigTabela(IfThen(vaSepararMsg, 1, 0), 2, 4, ipRVE);
                vaLinha := 1;
              end
            else
              begin
                vaLinha := 0;
                vaTabela := flcConfigTabela(IfThen(vaSepararMsg, 1, 0), 1, 4, ipRVE);
              end;

            // Identificando a tabela
            vaTabela.Tag := IntToStr(ipDMChat.cdsMensagemCODIGO.AsInteger) + '_' + IntToStr(vaCodigoHospital);

            // Ajustando o tamanho das células
            if ipExibirLinkVisualizacaoPesquisa then
              begin
                vaTabela.MergeCells(0, 0, 4, 1, False);
                vaTabela.Cells[0, 0].Color := clWhite;
                vaTabela.Cells[0, 0].AddTextBlockNLA(
                  'Visualizar',
                  4,
                  3,
                  'pesquisar#CodMsg' + IntToStr(ipDMChat.cdsMensagemCODIGO.AsInteger) +
                  '#idUserConversa' + ipIdentificador +
                  '#DestacarTexto' + ipDestacarTextoPesquisa);
              end;

            vaTabela.Cells[vaLinha, 0].BestWidth := 100; // Nome do remetente
            vaTabela.Cells[vaLinha, 2].BestWidth := 35; // Data e hora de envio da mensagem
            vaTabela.Cells[vaLinha, 3].BestWidth := 20; // Imagem de recebimento e leitura da mensagem

            // A princípio todas as mensagens terão smilyes
            vaIncluirSmileys := True;

            // Primeira coluna: Remetente da mensagem
            if ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger = 0 then
              begin
                 // Mensagem do sistema
                if vaSepararMsg then
                  vaTabela.Cells[vaLinha, 0].AddTextBlockNLA('Pro-Médico', 1, 1);

                // As mensagens do sistema não terão smileys
                vaIncluirSmileys := False;
              end
            else
              begin
                // Mensagem de algum usuário
                if vaSepararMsg then
                  begin
                    // Este label serve para ajustar o tamanho do nome do rementente da mensam ao espaço (100 px) atual da célula
                    vaLabel.Caption := TUtils.fpuCapitalize(ipDMChat.cdsMensagemNOME_REMETENTE.AsString);

                    if vaLabel.Width > 96 then
                      begin
                        vaLabel.Caption := vaLabel.Caption + '...';

                        while (vaLabel.Width > 96) do
                          vaLabel.Caption := TRegEx.Match(vaLabel.Caption, '.+?(?=.\.\.\.)', [roSingleLine, roIgnoreCase]).Value + '...';
                      end;

                    vaTabela.Cells[vaLinha, 0].AddTextBlockNLA(vaLabel.Caption, 1, 1);
                  end;
              end;

            // Segunda coluna: Mensagem
            // A mensagem será quebrada em linhas e cada linha será um novo parágrafo para facilitar o código.
            // Em cada linha será separado o texto dos links.
            // Em cada texto serão separadas as palavras dos smileys
            // O código será escrito seguindo a ordem da explicação acima

            // O texto será incluído, somentente se tiver algo escrito
            if Trim(ipDMChat.cdsMensagemTEXTO.AsString) <> '' then
              begin
                // Pegando as linhas do texto (cada linha será um novo parágrafo)
                vaLinhas := TRegEx.Split(ipDMChat.cdsMensagemTEXTO.AsString, '\r\n', []);
                vaQtdeLinhas := Length(vaLinhas);

                // Adicionando as linhas
                for i := 0 to vaQtdeLinhas - 1 do
                  begin
                    if (i + 1) = vaQtdeLinhas then
                      vaNroParagrafo := 3 // Este parágrafo possui um espaço após o parágrafo e deve ser usado somente na última linha do texto
                    else
                      vaNroParagrafo := 4; // Este parágrafo não possui espaço após o parágrafo

                    // Verificando se existem links na linha
                    vaLinks := TRegEx.Matches(vaLinhas[i], '(^|(?<=(\s|\(|\[|\{|\r)))((http(s\d?)?\:\/\/|www\.).+?|[\w\.]+?@[\w\.]+?\.[a-z0-9]{2,})(?=(\s|\)|\]|\}|,|;|\.\s|$))', [roIgnoreCase, roSingleLine]);

                    if vaLinks.Count = 0 then
                      // Nenhum link encontrado, então vamos apenas adicionar o texto e os smileys
                      plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], vaLinhas[i], 0, vaNroParagrafo, vaIncluirSmileys)
                    else
                      begin
                        // Existem links, então vamos adicioná-los

                        // Passando para a variável vaTexto todo o texto da linha, pois esta será uma variável de controle. Enquanto houver texto nesta variável,
                        // haverá impressão na tela
                        vaTexto := vaLinhas[i];

                        // Incluindo todos os links
                        for vaLink in vaLinks do
                          begin
                            // Incluindo o texto que está antes do link
                            plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], TRegEx.Match(vaTexto, '.*?(?=' + TRegEx.Escape(vaLink.Value) + ')', []).Value, 0, vaNroParagrafo, vaIncluirSmileys);

                            // A partir deste ponto não haverá um parágrafo definito, para não incluir uma nova linha
                            vaNroParagrafo := -1;

                            // Incluindo o link
                            if TRegEx.IsMatch(vaLink.Value, '[\w\.]+?@[\w\.]+?\.[a-z0-9]', [roIgnoreCase, roSingleLine]) then
                              vaTabela.Cells[vaLinha, 1].AddTextBlockNLA(vaLink.Value, 4, -1, 'e-mail')
                            else
                              vaTabela.Cells[vaLinha, 1].AddTextBlockNLA(vaLink.Value, 4, -1, 'link');

                            // Pegando todo o texto que está após o link
                            vaTexto := TRegEx.Match(vaTexto, '(?<=' + TRegEx.Escape(vaLink.Value) + ').*', []).Value;
                          end;

                        // Incluindo na linha o texto restante, ou seja, todo o texto que está após o último link da linha, caso ainda haja texto a ser incluído
                        if vaTexto <> '' then
                          plcIncluirTextoComImagens(vaTabela.Cells[vaLinha, 1], vaLinhas[i], 0, vaNroParagrafo, vaIncluirSmileys);
                      end;
                  end;
              end;

            // Terceira coluna: Data e hora de envio
            if vaSepararMsg then
              vaTabela.Cells[vaLinha, 2].AddTextBlockNLA(FormatDateTime('hh:mm', ipDMChat.cdsMensagemDATA_HORA_ENVIO.AsDateTime), 2, 2);

            // Quarta coluna: Leitores da mensagem, só irá aparecer nas mensagem enviadas, as recebidas nao irão aparecer
            if (ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger = ipUsuarioLogado.CodigoUsuario) then
              begin
                ppuIncluirStatusMensagem(
                  vaTabela.Cells[vaLinha, 3],
                  2,
                  IntToStr(ipDMChat.cdsMensagemCODIGO.AsInteger) + '_' +
                  IntToStr(vaCodigoHospital),
                  vaLeituraConfirmada,
                  ipDMChat);
              end;

            // Diferenciando a mensagem por cor
            if (ipCodigoMensagemDestacar <> 0) and (ipCodigoMensagemDestacar = ipDMChat.cdsMensagemCODIGO.AsInteger) then
              begin
                // Está fazendo uma pesquisa e selecionou uma mensagem específica, então vamos destacar
                // com uma cor diferente a mensagem selecionada
                // Amarelo
                vaTabela.Color := $00D2FFFF;
                vaTabela.Cells[vaLinha, 0].Color := $00B3FFFF;
              end
            else
              begin
                if ipDMChat.cdsMensagemTIPO.AsInteger = 1 then
                  begin
                    // Mensagem de alerta. A mensagem de alerta tem sempre a mesma cor, independente de quem tenha enviado
                    // Vermelho
                    vaTabela.Color := $00D5D5FF;
                    vaTabela.Cells[vaLinha, 0].Color := $00BFBFFF;
                  end
                else
                  begin
                    if ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger = 0 then
                      begin
                        // Mensagem enviada pelo sistema
                        // Verde
                        vaTabela.Color := $00D7FFD7;
                        vaTabela.Cells[vaLinha, 0].Color := $00B9FFB9;
                      end
                    else
                      begin
                        if (ipDMChat.cdsMensagemCODIGO_SENHAUS_REMETENTE.AsInteger = ipUsuarioLogado.CodigoUsuario) then
                          begin
                            // O usuário logado enviou a mensagem
                            // Branco e cinza
                            vaTabela.Color := clWhite;
                            vaTabela.Cells[vaLinha, 0].Color := $00DFDFDF;
                          end
                        else
                          begin
                            // O usuário logado recebeu a mensagem
                            // Azul
                            vaTabela.Color := $00FBEEE3;
                            vaTabela.Cells[vaLinha, 0].Color := $00F8E3D1;
                          end;
                      end;
                  end;
              end;
          end;

        // Incluindo os anexos da mensagem na céluala
        if (not ipDMChat.cdsMensagemCODIGO_MENSAGEM_ANEXO.IsNull) and (Trim(ipDMChat.cdsMensagemENDERECO_ANEXO.AsString) <> '') then
          plcIncluirAnexo(vaTabela.Cells[vaLinha, 1], vaCodigoHospital);

        // Passando para a próxima mensagem
        ipDMChat.cdsMensagem.Next;
      end;

    // Gravando a confirmação da leitura das mensagens
    vaDadosConversa.Mensagens := ipDMChat.cdsMensagem_Aux.Data;
    ioDadosConversas.Items[ipIdentificador] := vaDadosConversa;
  finally
    if ipDMChat.cdsMensagem.Active then
      ipDMChat.cdsMensagem.EmptyDataSet;

    ipDMChat.cdsMensagem.Close;

    if ipDMChat.cdsMensagem_Aux.Active then
      ipDMChat.cdsMensagem_Aux.EmptyDataSet;

    ipDMChat.cdsMensagem_Aux.Close;

    if Assigned(vaLabel) then
      FreeAndNil(vaLabel);
  end;

  ipRVE.Change;
  ipRVE.Format;
end;

end.
